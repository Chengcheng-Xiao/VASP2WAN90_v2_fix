diff -bruN src/mlwf.F ../vasp.5.4.4_mod/src/mlwf.F
--- src/mlwf.F	2017-04-20 10:03:58.000000000 +0100
+++ ../vasp.5.4.4_mod/src/mlwf.F	2020-06-25 17:50:36.070113515 +0100
@@ -6,6 +6,12 @@
  
       ! write the wave functions to UNK files
       LOGICAL, PRIVATE, SAVE :: WRITE_UNK
+      LOGICAL, PRIVATE, SAVE :: UNK_FMTED
+
+      ! write the wave functions to UNK files
+      LOGICAL, PRIVATE, SAVE :: WRITE_SPN
+      LOGICAL, PRIVATE, SAVE :: SPN_FMTED
+
       ! write the mmn and amn files when WANNIER90 runs in lib mode
       LOGICAL, PRIVATE, SAVE :: WRITE_MMN_AMN
 
@@ -195,6 +201,41 @@
                WRITE(IU0,*)'Error reading item ''LWRITE_UNK'' from file INCAR.'
             WRITE_UNK=.FALSE.
          ENDIF
+
+         ! 2020-06-22 CCX: added to determine UNK is formatted or not
+         UNK_FMTED=.FALSE.
+         CALL RDATAB(.FALSE.,INCAR,IU5,'LUNK_FMTED','=','#',';','L', &
+        &            IDUM,RDUM,CDUM,UNK_FMTED,CHARAC,N,1,IERR)
+         IF (((IERR/=0).AND.(IERR/=3)).OR. &
+        &                    ((IERR==0).AND.(N<1))) THEN
+            IF (IU0>=0) &
+               WRITE(IU0,*)'Error reading item ''LUNK_FMTED'' from file INCAR.'
+            UNK_FMTED=.FALSE.
+         ENDIF
+
+         ! 2020-06-25 CCX: Do we want to write the spn file?
+         WRITE_SPN=.FALSE.
+         CALL RDATAB(.FALSE.,INCAR,IU5,'LWRITE_SPN','=','#',';','L', &
+        &            IDUM,RDUM,CDUM,WRITE_SPN,CHARAC,N,1,IERR)
+         IF (((IERR/=0).AND.(IERR/=3)).OR. &
+        &                    ((IERR==0).AND.(N<1))) THEN
+            IF (IU0>=0) &
+               WRITE(IU0,*)'Error reading item ''LWRITE_SPN'' from file INCAR.'
+            WRITE_SPN=.FALSE.
+         ENDIF
+
+         ! 2020-06-25 CCX: Do we want to write the spn file?
+         SPN_FMTED=.FALSE.
+         CALL RDATAB(.FALSE.,INCAR,IU5,'LSPN_FMTED','=','#',';','L', &
+        &            IDUM,RDUM,CDUM,SPN_FMTED,CHARAC,N,1,IERR)
+         IF (((IERR/=0).AND.(IERR/=3)).OR. &
+        &                    ((IERR==0).AND.(N<1))) THEN
+            IF (IU0>=0) &
+               WRITE(IU0,*)'Error reading item ''LSPN_FMTED'' from file INCAR.'
+            SPN_FMTED=.FALSE.
+         ENDIF
+
+
          ! Do we want to write the mmn and amn files
          ! even though WANNIER90 runs in library mode?
          WRITE_MMN_AMN=.NOT.LWANNIER90_RUN
@@ -320,6 +361,9 @@
       REAL(q), ALLOCATABLE :: proj_x(:,:)
       REAL(q), ALLOCATABLE :: proj_zona(:)
       INTEGER, ALLOCATABLE :: exclude_bands(:)
+      ! CCX_2019-05-05: define proj_s and proj_s_qaxis
+      INTEGER, ALLOCATABLE :: proj_s(:)
+      REAL(q), ALLOCATABLE :: proj_s_qaxis(:,:)
       ! wannier90_run variables: input
       COMPLEX(q), ALLOCATABLE :: M_matrix(:,:,:,:,:)
       COMPLEX(q), ALLOCATABLE :: A_matrix(:,:,:,:)
@@ -329,6 +373,12 @@
       INTEGER NI,MI,NK,NKP,ICNTR
       INTEGER NKI,NKJ,ISP,ISPINOR,L,M,N,NP
       INTEGER NEXCLB,NPROJ
+      ! CCX_2019-05-06: spin quantization local variables
+      LOGICAL spin_z_pos,spin_z_neg
+      COMPLEX(q) FAC(2)
+      REAL(q) :: eps6=0.000001_q
+      REAL(q) xnorm
+      ! CCX_2019-05-06: end definition
       REAL(q) POS(3)
       REAL(q) KI(3),KJ(3)
       INTEGER IDUM,IERR
@@ -344,6 +394,12 @@
 
       COMPLEX(q),ALLOCATABLE ::  S(:,:)
       GDEF, ALLOCATABLE :: A(:,:),AP(:,:)
+      ! 2020-06-25 CCX adde temp spn mate
+      GDEF, ALLOCATABLE :: SPN(:,:,:)
+      ! 2020-06-25 CCX: add spn_matrix
+      GDEF, ALLOCATABLE :: spin_mat(:,:)
+      INTEGER :: spn_counter
+      CHARACTER (len=60)       :: SPN_header
       REAL(q), ALLOCATABLE :: ROTYLM(:,:)
       REAL(q), ALLOCATABLE :: HYBRID_ORBITAL(:)
 
@@ -364,12 +420,14 @@
 !        STOP
 !     END IF
 #endif
+
+! 2020-06-22 CCX: wannier90 CAN plot spinors.
       ! WANNIER90 cannot plot spinors
-      IF (WRITE_UNK.AND.WDES%LNONCOLLINEAR) THEN
-         IF (IO%IU0>=0) WRITE(IO%IU0,*) &
-        & 'MLWF_WANNIER90: ERROR: will not write spinors to UNK files, sorry ...'
-         WRITE_UNK=.FALSE.
-      ENDIF
+!      IF (WRITE_UNK.AND.WDES%LNONCOLLINEAR) THEN
+!         IF (IO%IU0>=0) WRITE(IO%IU0,*) &
+!        & 'MLWF_WANNIER90: ERROR: will not write spinors to UNK files, sorry ...'
+!         WRITE_UNK=.FALSE.
+!      ENDIF
 !
 ! allocation
       ALLOCATE(S(WDES%NB_TOT,WDES%NB_TOT))
@@ -449,8 +507,17 @@
 
       ALLOCATE(proj_site(3,num_bands_tot),proj_l(num_bands_tot),proj_m(num_bands_tot), &
      &   proj_radial(num_bands_tot),proj_z(3,num_bands_tot),proj_x(3,num_bands_tot), &
-     &   proj_zona(num_bands_tot),exclude_bands(num_bands_tot))
+     &   proj_zona(num_bands_tot),exclude_bands(num_bands_tot), &
+#ifdef VASP2WANNIER90v2
+! CCX_2019-05-05: allocate proj_s and proj_s_qaxis.
+     &   proj_s(num_bands_tot),proj_s_qaxis(3,num_bands_tot) &
+#endif
+     &   )
       proj_site=0; proj_l=0; proj_m=0; proj_radial=0; proj_z=0; proj_x=0; proj_zona=0; exclude_bands=0
+#ifdef VASP2WANNIER90v2
+! CCX_2019-05-05: initialize proj_s and proj_s_qaxis.
+      proj_s=0; proj_s_qaxis=0
+#endif
 
       ! Only one node will do the actual work,
       ! otherwise all will write to wannier90.wout
@@ -460,7 +527,12 @@
      &                   kpt_latt,num_bands_tot,num_atoms,atom_symbols,atoms_cart, &
      &                   gamma_only,spinors,nntot,nnlist,nncell,num_bands,num_wann, &
      &                   proj_site,proj_l,proj_m,proj_radial,proj_z,proj_x,proj_zona, &
-     &                   exclude_bands)
+     &                   exclude_bands, &
+#ifdef VASP2WANNIER90v2
+! CCX_2019-05-05: call wannier_setup to calculate proj_s and proj_s_qaxis
+     &                   proj_s,proj_s_qaxis &
+#endif
+     &                   )
 #endif
       ! Now communicate the output to the other nodes
       CALLMPI( M_sum_i(WDES%COMM,nntot,1) ) 
@@ -476,6 +548,11 @@
       CALLMPI( M_sum_d(WDES%COMM,proj_x,3*num_bands_tot) )
       CALLMPI( M_sum_d(WDES%COMM,proj_zona,num_bands_tot) )
       CALLMPI( M_sum_i(WDES%COMM,exclude_bands,num_bands_tot) )
+#ifdef VASP2WANNIER90v2
+! CCX_2019-05-05: bcast proj_s and proj_s_qaxis
+      CALLMPI( M_sum_i(WDES%COMM,proj_s,num_bands_tot) )
+      CALLMPI( M_sum_d(WDES%COMM,proj_s_qaxis,3*num_bands_tot) )
+#endif
 
       ALLOCATE(EXCLUDE_BAND(num_bands_tot))
       EXCLUDE_BAND=.FALSE. ; NEXCLB=0
@@ -577,6 +654,68 @@
 
       IF (IO%IU6>=0.AND.WRITE_MMN_AMN) CLOSE(99)
 
+      ! 2020-06-25 CCX: write SPN matrix
+      IF (WRITE_SPN .AND. WDES%COMM%NCPU.NE.1) THEN
+          IF (IO%IU0>=0) WRITE(*,*) 'MLWF_WANNIER90: WRITE_SPN in parallel not supported, skipping.'
+           WRITE_SPN=.FALSE.
+      ENDIF
+
+      IF (IO%IU6>=0.AND.WRITE_SPN) THEN
+        ALLOCATE(SPN(WDES%NB_TOT,WDES%NB_TOT,3))
+	ALLOCATE(spin_mat((num_bands+1)*num_bands/2,3))
+        IF (WDES%NRSPINORS==1) THEN
+           IF (IO%IU0>=0) WRITE(*,*) 'MLWF_WANNIER90: ERROR: WRITE_SPN specified, but collinear calculation.'
+           STOP
+        ELSE
+	  IF (SPN_FMTED) THEN
+            OPEN(UNIT=99,FILE=seed_name//'.spn',FORM="FORMATTED",STATUS='REPLACE')
+	    SPN_header = 'File generated by VASP: '//INFO%SZNAM1
+            WRITE(99,'(A)') SPN_header
+            WRITE(99,'(3I12)') num_bands,num_kpts
+          ELSE
+            OPEN(UNIT=99,FILE=seed_name//'.spn',FORM="UNFORMATTED",STATUS='REPLACE')
+	    SPN_header = 'File generated by VASP: '//INFO%SZNAM1
+            WRITE(99) SPN_header
+            WRITE(99) num_bands,num_kpts
+	  ENDIF
+        ENDIF
+      ENDIF
+
+      IF (WDES%NRSPINORS/=1.AND.WRITE_SPN) THEN
+	IF (IO%IU0>=0) WRITE(IO%IU0,*) "Calculating SPN."
+      ! runs over all k-points
+      spn_ki_loop: DO NKI=1,num_kpts
+         KI(:)=kpt_latt(:,NKI)
+         
+         CALL CALC_SPN_EXP(W,KI,P,CQIJ,LATT_CUR,T_INFO,SPN)
+	    
+	    !now, we nned to exclude some bands.
+            NI=0
+            spn_n_loop: DO N=1,WDES%NB_TOT
+   	      IF (EXCLUDE_BAND(N)) CYCLE spn_n_loop
+     	      spn_m_loop: DO M=1,N
+      	        IF (EXCLUDE_BAND(M)) CYCLE spn_m_loop
+      	        NI=NI+1
+		DO spn_counter=1,3
+      	          spin_mat(NI,spn_counter)=SPN(M,N,spn_counter)
+		ENDDO
+   	      ENDDO spn_m_loop
+	    ENDDO spn_n_loop
+
+            IF (SPN_FMTED) THEN
+              DO N=1,(num_bands+1)*num_bands/2
+                IF (IO%IU6>=0.AND.WRITE_SPN) WRITE(99,'(2ES26.16)') (spin_mat(N,spn_counter), spn_counter=1,3)
+              ENDDO
+            ELSE
+              IF (IO%IU6>=0.AND.WRITE_SPN) WRITE(99) ((spin_mat(N,spn_counter), spn_counter=1,3), N=1,(num_bands+1)*num_bands/2)
+            ENDIF
+      ENDDO spn_ki_loop
+      DEALLOCATE(spin_mat)
+      DEALLOCATE(SPN)
+
+      IF (IO%IU6>=0.AND.WRITE_SPN) CLOSE(99)
+      ENDIF
+
       ! and we might want to read an existing amn file
       IF (READ_AMN) THEN
       ! compute NPROJ 
@@ -584,6 +723,11 @@
       DO ISPINOR=1,WDES%NRSPINORS
       DO ICNTR=1,num_bands_tot
          IF (proj_l(ICNTR)==0.AND.proj_m(ICNTR)==0.AND.proj_radial(ICNTR)==0) CYCLE
+#ifdef VASP2WANNIER90v2
+! CCX_2019-05-05: only calculate corresponding spin channel
+         IF (WDES%NRSPINORS/=1.AND.proj_s(ICNTR)==1.AND.ISPINOR==2) CYCLE
+         IF (WDES%NRSPINORS/=1.AND.proj_s(ICNTR)==-1.AND.ISPINOR==1) CYCLE
+#endif
          NPROJ=NPROJ+1
       ENDDO
       ENDDO
@@ -643,11 +787,36 @@
       ALLOCATE(ROTYLM((LMAX+1)**2,(LMAX+1)**2),HYBRID_ORBITAL((LMAX+1)**2))
 
       NPROJ=0 
-!     CALL START_TIMING("T1")
+      ! CCX_2020-06-15: initialize A matrix
+      A_matrix=0
       ! runs over all projector sites
-      spinor: DO ISPINOR=1,WDES%NRSPINORS
       sites : DO ICNTR=1,num_bands_tot
          IF (proj_l(ICNTR)==0.AND.proj_m(ICNTR)==0.AND.proj_radial(ICNTR)==0) CYCLE sites
+        ! CCX_2019-05-06: determin spin quantization axis along z axis or not.
+        spin_z_pos=.false.
+        spin_z_neg=.false.
+        ! CCX_2019-06-10: renormalize spin quantization axis
+        xnorm=SQRT(proj_s_qaxis(1,ICNTR)*proj_s_qaxis(1,ICNTR)+proj_s_qaxis(2,ICNTR)*proj_s_qaxis(2,ICNTR)+proj_s_qaxis(3,ICNTR)*proj_s_qaxis(3,ICNTR))
+        proj_s_qaxis(1,ICNTR)=proj_s_qaxis(1,ICNTR)/xnorm
+        proj_s_qaxis(2,ICNTR)=proj_s_qaxis(2,ICNTR)/xnorm
+        proj_s_qaxis(3,ICNTR)=proj_s_qaxis(3,ICNTR)/xnorm
+
+        IF ((abs(proj_s_qaxis(1,ICNTR)-0.0d0)<eps6).and.(abs(proj_s_qaxis(2,ICNTR)-0.0d0)<eps6) &
+           .and.(abs(proj_s_qaxis(3,ICNTR)-1.0d0)<eps6)) then
+           spin_z_pos=.true.
+        ELSEIF(abs(proj_s_qaxis(1,ICNTR)-0.0d0)<eps6.and.abs(proj_s_qaxis(2,ICNTR)-0.0d0)<eps6 &
+           .and.abs(proj_s_qaxis(3,ICNTR)+1.0d0)<eps6) then
+           spin_z_neg=.true.
+        ENDIF
+        ! CCX_2019-05-06: [start] if proj_s_qaxis lies along z, normal projections are done.
+        IF (spin_z_pos .OR. spin_z_neg.or.WDES%NRSPINORS==1) THEN ! if not spinor, still use this routine.
+          spinor1: DO ISPINOR=1,WDES%NRSPINORS
+            IF (spin_z_pos.AND.WDES%NRSPINORS/=1.AND.proj_s(ICNTR)==1.AND.ISPINOR==2) CYCLE spinor1
+            IF (spin_z_pos.AND.WDES%NRSPINORS/=1.AND.proj_s(ICNTR)==-1.AND.ISPINOR==1) CYCLE spinor1
+            ! if neg then swap up and down definition
+            IF (spin_z_neg.AND.WDES%NRSPINORS/=1.AND.proj_s(ICNTR)==1.AND.ISPINOR==1) CYCLE spinor1
+            IF (spin_z_neg.AND.WDES%NRSPINORS/=1.AND.proj_s(ICNTR)==-1.AND.ISPINOR==2) CYCLE spinor1
+
          NPROJ=NPROJ+1
          ! setup the Ylm rotation matrix in accordance with proj_z and proj_x
          CALL SETROTYLM(proj_x(:,ICNTR),proj_z(:,ICNTR),LMAX,ROTYLM)
@@ -673,9 +842,9 @@
          ENDDO
 
 
-!        CALL START_TIMING("T2")
+      !        CALL START_TIMING("T2")
          ! runs over all k-points
-         kpoints : DO NKI=1,num_kpts
+            kpoints1 : DO NKI=1,num_kpts
             CALL CALC_OVERLAP_GN( &
            &   LMAX,FG,proj_site(:,ICNTR),W,kpt_latt(:,NKI),ISP,ISPINOR,P,CQIJ,LATT_CUR,T_INFO,A)
             ! and rotate them in accordance with proj_z and proj_x
@@ -712,15 +881,109 @@
                A_matrix(MI,NPROJ,NKI,ISP)=CPROJ
             ENDDO
 
-         ENDDO kpoints
+            ENDDO kpoints1
 
          DEALLOCATE(FTMP,FR,FGTMP,FG)
 
          IF (IO%IU0>=0) WRITE(IO%IU0,'(X,A,I3,A)') 'Projection ',NPROJ,' done.'
-!        CALL STOP_TIMING("T2",IO%IU6,'  OVL')
-!        CALL STOP_TIMING("T1",IO%IU6,'ICNTR')
+      !        CALL STOP_TIMING("T2",IO%IU6,'  OVL')
+      !        CALL STOP_TIMING("T1",IO%IU6,'ICNTR')
+          ENDDO spinor1
+        ! CCX_2019-05-06: [end] end normal routine.
+        ELSE ! CCX_2019-05-06: quantization axis does not lies along z axis, do special projection routine.
+        ! CCX_2019-05-06: generate spinor eigenvectors.
+          ! CCX_2019-06-10: renormalize spin quantization axis
+          xnorm=SQRT(proj_s_qaxis(1,ICNTR)*proj_s_qaxis(1,ICNTR)+proj_s_qaxis(2,ICNTR)*proj_s_qaxis(2,ICNTR)+proj_s_qaxis(3,ICNTR)*proj_s_qaxis(3,ICNTR))
+          proj_s_qaxis(1,ICNTR)=proj_s_qaxis(1,ICNTR)/xnorm
+          proj_s_qaxis(2,ICNTR)=proj_s_qaxis(2,ICNTR)/xnorm
+          proj_s_qaxis(3,ICNTR)=proj_s_qaxis(3,ICNTR)/xnorm
+
+          IF (proj_s(ICNTR)==1) THEN ! up channel
+              FAC(1)=(1.0d0/SQRT(1+proj_s_qaxis(3,ICNTR)))*(proj_s_qaxis(3,ICNTR)+1)*CMPLX(1.0d0,0.0d0,q)
+              FAC(2)=(1.0d0/SQRT(1+proj_s_qaxis(3,ICNTR)))*CMPLX(proj_s_qaxis(1,ICNTR),proj_s_qaxis(2,ICNTR),q)
+              NPROJ=NPROJ+1
+          ELSE ! down channel
+              FAC(1)=(1.0d0/SQRT(1-proj_s_qaxis(3,ICNTR)))*(proj_s_qaxis(3,ICNTR)-1)*CMPLX(1.0d0,0.0d0,q)
+              FAC(2)=(1.0d0/SQRT(1-proj_s_qaxis(3,ICNTR)))*CMPLX(proj_s_qaxis(1,ICNTR),proj_s_qaxis(2,ICNTR),q)
+              NPROJ=NPROJ+1
+          ENDIF
+
+          ! 2020-06-15 CCX: we no longer need ISPINOR loop since we are using full spinor guiding functions.
+          !spinor: DO ISPINOR=1,WDES%NRSPINORS
+           ! setup the Ylm rotation matrix in accordance with proj_z and proj_x
+            CALL SETROTYLM(proj_x(:,ICNTR),proj_z(:,ICNTR),LMAX,ROTYLM)
+#ifdef debug
+            IF (IO%IU6>=0) THEN
+               WRITE(*,'(I4,3F14.7)') ICNTR,proj_site(1:3,ICNTR)
+               DO N=10,MIN((LMAX+1)**2,16)
+                  WRITE(*,'(9F10.5)') (ROTYLM(N,M),M=10,MIN((LMAX+1)**2,16))
+               ENDDO
+            ENDIF
+#endif
+            ! translate between VASP and the orbital definition of wannier90
+            CALL WANNIER90_ORBITAL_DEFINITIONS(proj_l(ICNTR),proj_m(ICNTR),HYBRID_ORBITAL)
+            ! setup the radial functions (real space)
+            CALL SETRGRID(RSTART/proj_zona(ICNTR),REND,H,R)
+            ALLOCATE(FTMP(R%NMAX),FR(R%NMAX,LMAX+1))
+            ALLOCATE(FGTMP(NMAX,5),FG(NMAX,5,LMAX+1))
+            ! For now we use the same radial function for all L
+            DO L=0,LMAX
+               CALL RADIAL_FUNCTION(proj_radial(ICNTR),R,proj_zona(ICNTR),FTMP)
+               CALL BESSEL_TRANSFORM_RADIAL_FUNCTION(L,R,FTMP,REAL(SQRT(2._q*INFO%ENMAX/HSQDTM)/NMAX,KIND=q),FGTMP)
+               FR(:,L+1)=FTMP; FG(:,:,L+1)=FGTMP
+            ENDDO
+
+
+         !        CALL START_TIMING("T2")
+            ! runs over all k-points
+            kpoints : DO NKI=1,num_kpts
+               CALL CALC_OVERLAP_GN_ALL( &
+              &   LMAX,FG,proj_site(:,ICNTR),W,kpt_latt(:,NKI),ISP,FAC,P,CQIJ,LATT_CUR,T_INFO,A)
+               ! and rotate them in accordance with proj_z and proj_x
+               AP=0
+               DO M=1,WDES%NB_TOT
+               DO N=1,(LMAX+1)**2
+                  DO NP=1,(LMAX+1)**2
+                     AP(M,N)=AP(M,N)+A(M,NP)*ROTYLM(N,NP)
+                  ENDDO
+               ENDDO
+               ENDDO
+#ifdef debug
+               IF (IO%IU6>=0) THEN
+                  WRITE(*,'(I4,3F14.7)') NKI,kpt_latt(1:3,NKI)
+                  DO M=1,WDES%NB_TOT
+                     WRITE(*,'(4(2F14.7,2X))') (A(M,N),N=1,4)
+                  ENDDO
+                  WRITE(*,*)
+                  DO M=1,WDES%NB_TOT
+                     WRITE(*,'(4(2F14.7,2X))') (AP(M,N),N=1,4)
+                  ENDDO
+                  WRITE(*,*)
+               ENDIF
+#endif
+               ! Make the desired linear combinations
+               MI=0
+               DO M=1,WDES%NB_TOT
+                  IF (EXCLUDE_BAND(M)) CYCLE
+                  CPROJ=0
+                  DO N=1,(LMAX+1)**2
+                     CPROJ=CPROJ+AP(M,N)*HYBRID_ORBITAL(N)
+                  ENDDO
+                  MI=MI+1
+                  A_matrix(MI,NPROJ,NKI,ISP)=CPROJ
+               ENDDO
+
+            ENDDO kpoints
+
+            DEALLOCATE(FTMP,FR,FGTMP,FG)
+
+         !  IF (IO%IU0>=0) WRITE(IO%IU0,'(X,A,I3,A,I3,A)') 'Spin channel',ISPINOR,' done.'
+         !        CALL STOP_TIMING("T2",IO%IU6,'  OVL')
+         !        CALL STOP_TIMING("T1",IO%IU6,'ICNTR')
+      !ENDDO spinor
+          IF (IO%IU0>=0) WRITE(IO%IU0,'(X,A,I3,A)') 'Projection ',NPROJ,' done. [q_axis changed]'
+        ENDIF ! quantization IF
       ENDDO sites
-      ENDDO spinor
 
       DEALLOCATE(A,AP,ROTYLM,HYBRID_ORBITAL)
 
@@ -811,14 +1074,24 @@
       ! to make matters worse, WANNIER90 works with the full k-mesh
       ! whereas VASP uses the symmetry reduced one.
  100  FORMAT('UNK',I5.5,'.',I1)
+ 101  FORMAT('UNK',I5.5,'.NC')
       IF (WRITE_UNK) THEN
          DO NKI=1,num_kpts
             IF (IO%IU6>=0) THEN
+               IF (W%WDES%NRSPINORS/=1) THEN
+                 WRITE(UNKFILE,101) NKI
+               ELSE
                WRITE(UNKFILE,100) NKI,ISP
+               ENDIF
+               IF (UNK_FMTED) THEN
+                 OPEN(UNIT=99,FILE=UNKFILE,FORM='FORMATTED',STATUS='REPLACE')
+                 WRITE(99,*) W%WDES%GRID%NGX,W%WDES%GRID%NGY,W%WDES%GRID%NGZ,NKI,num_bands
+               ELSE
                OPEN(UNIT=99,FILE=UNKFILE,FORM='UNFORMATTED',STATUS='REPLACE')
                WRITE(99) W%WDES%GRID%NGX,W%WDES%GRID%NGY,W%WDES%GRID%NGZ,NKI,num_bands
             ENDIF
-            CALL WRITE_WAVE_FUNCTIONS(W,kpt_latt(:,NKI),ISP,EXCLUDE_BAND,P,LATT_CUR,99)   
+            ENDIF
+            CALL WRITE_WAVE_FUNCTIONS(W,kpt_latt(:,NKI),ISP,EXCLUDE_BAND,P,LATT_CUR,UNK_FMTED,99)
             IF (IO%IU6>=0) CLOSE(99)
          ENDDO
       ENDIF
@@ -1880,6 +2153,183 @@
       RETURN
       END SUBROUTINE CALC_OVERLAP_GN
 
+!******************** SUBROUTINE CALC_OVERLAP_GN_ALL *******************
+! 2020-06-15 CCX: added to use CONSTRUCT_FUNCTION_RYlm_ALL
+!                 for spin_quantization calculations
+!***********************************************************************
+      SUBROUTINE CALC_OVERLAP_GN_ALL( &
+     &   L,FG,POS,W,K,ISP,SPIN_FAC,P,CQIJ,LATT_CUR,T_INFO,S &
+     &)
+      USE pead
+      USE poscar
+      USE pseudo
+      USE lattice
+      USE full_kpoints
+      USE wave_high
+      USE nonl_high
+      IMPLICIT NONE
+      TYPE(wavespin) W
+      TYPE(potcar) P(:)
+      TYPE(latt) LATT_CUR
+      TYPE(type_info) T_INFO
+      INTEGER L
+      INTEGER ISP
+      ! 2020-06-15 CCX: read in SPIN_FAC
+      COMPLEX(q) SPIN_FAC(2)
+      REAL(q) K(3)
+      REAL(q) FG(:,:,:)
+      REAL(q) POS(3)
+      OVERLAP CQIJ(:,:,:,:)
+      GDEF S(W%WDES%NB_TOT,(L+1)**2)
+      ! local variables
+      TYPE(wavespin) WP
+      TYPE(wavefuna) WK,WRYlm
+      TYPE(wavedes1), TARGET :: WDESK
+      TYPE(nonl_struct) NONL_S
+
+      TYPE(rotation_handle), POINTER :: ROT_HANDLE
+
+      GDEF C
+      REAL(q) WSCAL
+      INTEGER NK,NB,N,NYLM
+
+      WP=W
+      WP%WDES=>WDES_FULL_PEAD
+
+      CALL CHECK_FULL_KPOINTS
+
+      NULLIFY(ROT_HANDLE)
+
+      NYLM=(L+1)**2
+
+      ! search for kpoint k in BZ
+      NK=KPOINT_IN_FULL_GRID(K,KPOINTS_FULL)
+      CALL SETWDES(WP%WDES,WDESK,NK)
+      IF (NK==KPOINTS_FULL%NEQUIV(NK)) THEN
+         ! k is a kpoint in the IBZ
+         WK=ELEMENTS(WP,WDESK,ISP)
+      ELSE
+         ! k is not a kpoint in the IBZ
+         CALL NEWWAVA(WK,WDESK,WDESK%NBANDS)
+         CALL PEAD_WA_ROTATE(WP,P,LATT_CUR,ISP,WK)
+      ENDIF
+
+      CALL NONL_ALLOC(NONL_S,T_INFO,P,WP%WDES,.FALSE.)
+      CALL SPHER(WP%WDES%GRID,NONL_S,P,WP%WDES,LATT_CUR,1,NK)
+      CALL PHASE(WP%WDES,NONL_S,NK)
+
+      CALL NEWWAVA(WRYlm,WDESK,NYLM)
+      WRYlm%CW=0
+      !WRITE(*,*) WRYlm%WDES1%LOVERL,   WRYlm%WDES1%NPROD
+      ! 2020-06-15 CCX: use CONSTRUCT_FUNCTION_RYlm_ALL.
+      CALL CONSTRUCT_FUNCTION_RYlm_ALL(L,FG,LATT_CUR,POS,NONL_S,SPIN_FAC,WRYlm)
+      ! and normalize the functions WRYlm
+      DO N=1,NYLM
+         CALL CNORMN(ELEMENT(WRYlm,N),CQIJ,1,WSCAL)
+      ENDDO
+
+      ! calculate overlap between Wk and WRYlm: < w_{m,k1} | S | RYlm >
+      S=0
+      DO NB=1,WP%WDES%NBANDS
+         DO N=1,NYLM
+            C=W1_DOT(ELEMENT(WK,NB),ELEMENT(WRYlm,N),CQIJ)
+            S(WDESK%NB_LOW+WDESK%NB_PAR*(NB-1),N)=C
+!           WRITE(*,*) WDESK%NB_LOW+WDESK%NB_PAR*(NB-1),N,C
+         ENDDO
+      ENDDO
+
+      CALLMPI( M_sum_g(WDESK%COMM_INTER,S(1,1),WDESK%NB_TOT*NYLM) )
+
+      ! some deallocation to be done
+      CALL DEALLOCATE_ROT_HANDLE(ROT_HANDLE)
+
+      CALL DELWAVA(WRYlm)
+      IF (NK/=KPOINTS_FULL%NEQUIV(NK)) CALL DELWAVA(WK)
+
+      CALL NONL_DEALLOC(NONL_S)
+
+      RETURN
+    END SUBROUTINE CALC_OVERLAP_GN_ALL
+
+!******************** SUBROUTINE CALC_SPN_EXP ***********************
+!
+!***********************************************************************
+      SUBROUTINE CALC_SPN_EXP( &
+     &   W,K,P,CQIJ,LATT_CUR,T_INFO,S &
+     &)
+      USE pead
+      USE poscar
+      USE pseudo
+      USE lattice
+      USE full_kpoints
+      USE wave_high
+      USE nonl_high
+      IMPLICIT NONE
+      TYPE(wavespin) W
+      TYPE(potcar) P(:)
+      TYPE(latt) LATT_CUR
+      TYPE(type_info) T_INFO
+      ! INTEGER L
+      ! INTEGER ISP
+      ! INTEGER ISPINOR
+      REAL(q) K(3)
+      ! REAL(q) FG(:,:,:)
+      ! REAL(q) POS(3)
+      OVERLAP CQIJ(:,:,:,:)
+      GDEF S(W%WDES%NB_TOT,W%WDES%NB_TOT,3)
+      ! local variables
+      TYPE(wavespin) WP
+      TYPE(wavefuna) WK
+      TYPE(wavedes1), TARGET :: WDESK
+
+      TYPE(rotation_handle), POINTER :: ROT_HANDLE
+
+      GDEF C(3)
+      REAL(q) WSCAL
+      INTEGER NK,NB,N,NYLM
+
+      WP=W
+      WP%WDES=>WDES_FULL_PEAD
+
+      CALL CHECK_FULL_KPOINTS
+
+      NULLIFY(ROT_HANDLE)
+
+      ! search for kpoint k in BZ
+      NK=KPOINT_IN_FULL_GRID(K,KPOINTS_FULL)
+      CALL SETWDES(WP%WDES,WDESK,NK)
+      IF (NK==KPOINTS_FULL%NEQUIV(NK)) THEN
+         ! k is a kpoint in the IBZ
+         WK=ELEMENTS(WP,WDESK,1)
+      ELSE
+         ! k is not a kpoint in the IBZ
+         CALL NEWWAVA(WK,WDESK,WDESK%NBANDS)
+         CALL PEAD_WA_ROTATE(WP,P,LATT_CUR,1,WK)
+      ENDIF
+      ! calculate overlap between W1 and W2: < w_{m,k1} | sigma | w_{n,k1} >
+      ! everything is in W1_SPNDOT
+      S=0
+      DO NB=1,WP%WDES%NBANDS
+         DO N=1,WP%WDES%NBANDS
+            C=W1_SPN_DOT(ELEMENT(WK,NB),ELEMENT(WK,N),CQIJ)
+!            WRITE(*,*) N,NB
+            S(WDESK%NB_LOW+WDESK%NB_PAR*(NB-1),WDESK%NB_LOW+WDESK%NB_PAR*(N-1),1)=C(1)
+            S(WDESK%NB_LOW+WDESK%NB_PAR*(NB-1),WDESK%NB_LOW+WDESK%NB_PAR*(N-1),2)=C(2)
+            S(WDESK%NB_LOW+WDESK%NB_PAR*(NB-1),WDESK%NB_LOW+WDESK%NB_PAR*(N-1),3)=C(3)
+
+!           WRITE(*,*) WDESK%NB_LOW+WDESK%NB_PAR*(NB-1),WDESK%NB_LOW+WDESK%NB_PAR*(N-1)
+         ENDDO
+      ENDDO
+      !CALLMPI( M_sum_g(WDESK%COMM_INTER,S(1,1,1),WDESK%NB_TOT*WDESK%NB_TOT*3) )
+      ! some deallocation to be done
+      CALL DEALLOCATE_ROT_HANDLE(ROT_HANDLE)
+      ! CALL DELWAVA(WRYlm)
+      IF (NK/=KPOINTS_FULL%NEQUIV(NK)) CALL DELWAVA(WK)
+      ! CALL NONL_DEALLOC(NONL_S)
+
+      RETURN
+      END SUBROUTINE CALC_SPN_EXP
+
 
 !******************** SUBROUTINE CONSTRUCT_FUNCTION_RYlm ***************
 !      
@@ -1989,11 +2439,129 @@
       RETURN
       END SUBROUTINE CONSTRUCT_FUNCTION_RYlm
 
+!******************** SUBROUTINE CONSTRUCT_FUNCTION_RYlm_ALL ***********
+! 2020-06-15 CCX: added to construct full RYlm with 2 spinors.
+!                 the PAW projector are constructed with the new
+!                 spinor wavefunctions.
+!                 Also, see W1_DOT in wave_high.F
+!***********************************************************************
+      SUBROUTINE CONSTRUCT_FUNCTION_RYlm_ALL( &
+     &   LMAX,F,LATT_CUR,POS,NONL_S,SPIN_FAC,WRYLM &
+     &)
+      USE ini
+      USE asa
+      USE pead
+      USE lattice
+      USE constant
+      USE wave_high
+      USE nonl_high
+      IMPLICIT NONE
+      TYPE(latt) LATT_CUR
+      TYPE(wavefuna) WRYLM
+      TYPE (nonl_struct) NONL_S
+      REAL(q) F(:,:,:)
+      REAL(q) POS(3)
+      INTEGER LMAX
+      ! 2020-06-15 CCX: read in SPIN_FAC
+      COMPLEX(q) SPIN_FAC(2)
+      ! local variables
+      ! 2020-06-15 CCX: ISPINOR is now local variable
+      INTEGER ISPINOR
+      TYPE(wavefun1) W1
+      INTEGER N1,N2,N3,IND,NPL,LMMAX,L,M,LM,IG
+      REAL(q) G1,G2,G3,GKX,GKY,GKZ,FACTM,FAKT,FDER
+      REAL(q), ALLOCATABLE :: XS(:),YS(:),ZS(:),YLM(:,:)
+      REAL(q), ALLOCATABLE :: G(:),FG(:)
+      COMPLEX(q) CSET,CGDR
+      COMPLEX(q), ALLOCATABLE :: CFAKTX(:)
+
+      LMMAX=(LMAX+1)**2
+
+      NPL=WRYLM%WDES1%NGVECTOR
+
+      ! 2020-06-15 CCX: deleted this part, usually not usefull.
+      !IF (ISPINOR/=1.AND.(.NOT.WRYLM%WDES1%LNONCOLLINEAR)) THEN
+      !   WRITE(*,*) 'CONSTRUCT_FUNCTION_RYlm: ERROR: ISPINOR=',ISPINOR,' but LNONCOLLINEAR=.FALSE.'
+      !   STOP
+      !ENDIF
+
+      ALLOCATE(G(NPL),FG(NPL))
+      ALLOCATE(XS(NPL),YS(NPL),ZS(NPL),CFAKTX(NPL))
+
+      ! loop over all G-vectors in the basis at this k-point
+      DO IND=1,WRYLM%WDES1%NGVECTOR
+         N1=MOD(WRYLM%WDES1%IGX(IND)+WRYLM%WDES1%GRID%NGX,WRYLM%WDES1%GRID%NGX)+1
+         N2=MOD(WRYLM%WDES1%IGY(IND)+WRYLM%WDES1%GRID%NGY,WRYLM%WDES1%GRID%NGY)+1
+         N3=MOD(WRYLM%WDES1%IGZ(IND)+WRYLM%WDES1%GRID%NGZ,WRYLM%WDES1%GRID%NGZ)+1
+
+         G1=(WRYLM%WDES1%GRID%LPCTX(N1)+WRYLM%WDES1%VKPT(1))
+         G2=(WRYLM%WDES1%GRID%LPCTY(N2)+WRYLM%WDES1%VKPT(2))
+         G3=(WRYLM%WDES1%GRID%LPCTZ(N3)+WRYLM%WDES1%VKPT(3))
+
+         FACTM=1._q
+         IF (WRYLM%WDES1%LGAMMA .AND. (N1/=1 .OR. N2/=1 .OR. N3/=1)) FACTM=SQRT(2._q)
+
+         GKX=(G1*LATT_CUR%B(1,1)+G2*LATT_CUR%B(1,2)+G3*LATT_CUR%B(1,3))*TPI
+         GKY=(G1*LATT_CUR%B(2,1)+G2*LATT_CUR%B(2,2)+G3*LATT_CUR%B(2,3))*TPI
+         GKZ=(G1*LATT_CUR%B(3,1)+G2*LATT_CUR%B(3,2)+G3*LATT_CUR%B(3,3))*TPI
+
+         G(IND)=MAX(SQRT(GKX*GKX+GKY*GKY+GKZ*GKZ),1E-10_q)
+
+         ! phase factor e^{-i(k+G)R} where R is the origin
+         ! of the localized function
+         CGDR=CITPI*(G1*POS(1)+G2*POS(2)+G3*POS(3))
+!        CGDR=0
+         CFAKTX(IND)=FACTM*EXP(-CGDR)
+
+         XS(IND)  =GKX/G(IND)
+         YS(IND)  =GKY/G(IND)
+         ZS(IND)  =GKZ/G(IND)
+      ENDDO
+
+      ALLOCATE(YLM(NPL,LMMAX))
+      ! get me all the Y_lm up to and including l=LMAX
+      CALL SETYLM(LMAX,NPL,YLM,XS,YS,ZS)
+
+      ! Setup the plane wave part of the desired function
+      FAKT= 1/SQRT(LATT_CUR%OMEGA)
+      CSET=CMPLX(0._q,-1._q,q)
+
+!     WRYLM%CW=0
+      LM=1
+      DO L=0,LMAX
+         ! get me the Bessel transform of the radial function
+         DO IG=1,SIZE(G)
+            CALL SPLVAL(G(IG),FG(IG),FDER,F(:,:,L+1),SIZE(F,1),SIZE(F,1))
+         ENDDO
+         DO IND=1,NPL
+            DO M=1,2*L+1
+               ! 2020-06-15 CCX: added ISPINOR loop to construct full spinor WF
+               !                 each part dotted with SPIN_FAC for quant_axis.
+               DO ISPINOR=1,2
+                 WRYLM%CW(IND+(ISPINOR-1)*NPL,LM+M-1)= &
+                &   SPIN_FAC(ISPINOR)*FAKT*(CSET**L)*CFAKTX(IND)*FG(IND)*YLM(IND,LM+M-1)
+               ENDDO
+            ENDDO
+         ENDDO
+         LM=LM+2*L+1
+      ENDDO
+
+      ! and get the projections of RYlm onto the PAW projectors
+      WRYLM%CPROJ=0
+      DO LM=1,LMMAX
+         W1=ELEMENT(WRYLM,LM)
+         CALL PROJ1(NONL_S,WRYLM%WDES1,W1)
+      ENDDO
+
+      DEALLOCATE(G,FG,XS,YS,ZS,CFAKTX,YLM)
+
+      RETURN
+    END SUBROUTINE CONSTRUCT_FUNCTION_RYlm_ALL
 
 !******************** SUBROUTINE WRITE_WAVE_FUNCTIONS ******************
 !      
 !***********************************************************************
-      SUBROUTINE WRITE_WAVE_FUNCTIONS(W,K,ISP,EXCLUDE_BAND,P,LATT_CUR,IU)
+      SUBROUTINE WRITE_WAVE_FUNCTIONS(W,K,ISP,EXCLUDE_BAND,P,LATT_CUR,UNK_FMTED,IU)
       USE pead
       USE pseudo
       USE lattice
@@ -2006,6 +2574,7 @@
       INTEGER ISP,IU
       REAL(q) K(3)
       LOGICAL EXCLUDE_BAND(W%WDES%NB_TOT) 
+      LOGICAL UNK_FMTED
      ! local variables
       TYPE(wavespin) WP
       TYPE(wavefuna) WK
@@ -2014,7 +2583,7 @@
 
       TYPE(rotation_handle), POINTER :: ROT_HANDLE
 
-      INTEGER NK,NB,ISTRIP
+      INTEGER NK,NB,ISTRIP,ISPINOR
       INTEGER NX,NY,NZ,NC,NGX,NGY,NGZ,IND,I,NWRITTEN
       INTEGER, PARAMETER :: NSTRIP=1
 
@@ -2047,7 +2616,12 @@
          CALL NEWWAV(WCOLLECT(NB),WDESK,.TRUE.)
       ENDDO
 
+      ! 2020-06-22 CCX: added for non-collinear WF plot
+      IF (WP%WDES%NRSPINORS/=1) THEN
+        ALLOCATE(WVFN(NGX*NGY*NGZ*2))
+      ELSE
       ALLOCATE(WVFN(NGX*NGY*NGZ))
+      ENDIF
 
       NWRITTEN=0 
 
@@ -2073,7 +2647,14 @@
 #ifdef gammareal
                      WVFN(IND)=REAL(WCOLLECT(ISTRIP)%CR(NX+(NC-1)*WP%WDES%GRID%RL%NROW),KIND=q)
 #else
+                     ! 2020-06-22 CCX: added for non-collinear WF plot
+                     IF (WP%WDES%NRSPINORS/=1) THEN
+                       DO ISPINOR=0,WP%WDES%NRSPINORS-1
+                         WVFN(IND+ISPINOR*(NGX*NGY*NGZ))=WCOLLECT(ISTRIP)%CR(NX+(NC-1)*WP%WDES%GRID%RL%NROW+ISPINOR*(NGX*NGY*NGZ))
+                       ENDDO
+                     ELSE
                      WVFN(IND)=WCOLLECT(ISTRIP)%CR(NX+(NC-1)*WP%WDES%GRID%RL%NROW)
+                     ENDIF
 #endif
                   ENDDO
                ENDDO
@@ -2086,7 +2667,14 @@
 #ifdef gammareal
                      WVFN(IND)=REAL(WCOLLECT(ISTRIP)%CR(NZ+(NC-1)*WP%WDES%GRID%RL%NROW),KIND=q)
 #else
+                     ! 2020-06-22 CCX: added for non-collinear WF plot
+                     IF (WP%WDES%NRSPINORS/=1) THEN
+                       DO ISPINOR=0,W%WDES%NRSPINORS-1
+                         WVFN(IND+ISPINOR*(NGX*NGY*NGZ))=WCOLLECT(ISTRIP)%CR(NZ+(NC-1)*WP%WDES%GRID%RL%NROW+ISPINOR*(NGX*NGY*NGZ))
+                       ENDDO
+                     ELSE
                      WVFN(IND)=WCOLLECT(ISTRIP)%CR(NZ+(NC-1)*WP%WDES%GRID%RL%NROW)
+                     ENDIF
 #endif
                   ENDDO
                ENDDO
@@ -2094,13 +2682,36 @@
                WRITE(*,'(A)') 'WRITE_WAVE_FUNCTIONS: ERROR: W1 grid not set'
                STOP
             ENDIF
+
+            ! 2020-06-22 CCX: added for non-collinear WF plot
+            IF (WP%WDES%NRSPINORS/=1) THEN
+              CALLMPI(M_sum_g(WP%WDES%COMM_INB,WVFN(1),NGX*NGY*NGZ*2))
+            ELSE
             CALLMPI(M_sum_g(WP%WDES%COMM_INB,WVFN(1),NGX*NGY*NGZ))
+            ENDIF
 
             ! write WVFN to file
 #ifdef MPI
             IF (WP%WDES%COMM%NODE_ME==WP%WDES%COMM%IONODE) THEN 
 #endif
+               ! 2020-06-22 CCX: added for non-collinear WF plot
+               IF (WP%WDES%NRSPINORS/=1) THEN
+                 IF (UNK_FMTED) THEN
+                   DO ISPINOR=0,1
+                     WRITE(IU,'(2ES20.10)') (WVFN(I),I=1+NGX*NGY*NGZ*ISPINOR,NGX*NGY*NGZ+NGX*NGY*NGZ*ISPINOR)
+                   ENDDO
+                 ELSEIF (.NOT. UNK_FMTED) THEN
+                   DO ISPINOR=0,1
+                     WRITE(IU) (WVFN(I),I=1+NGX*NGY*NGZ*ISPINOR,NGX*NGY*NGZ+NGX*NGY*NGZ*ISPINOR)
+                   ENDDO
+                 ENDIF
+               ELSEIF (WP%WDES%NRSPINORS==1) THEN
+                 IF (UNK_FMTED) THEN
+                   WRITE(IU,'(2ES20.10)') (WVFN(I),I=1,NGX*NGY*NGZ)
+                 ELSEIF (.NOT. UNK_FMTED) THEN
                WRITE(IU) (WVFN(I),I=1,NGX*NGY*NGZ)
+                 ENDIF
+               ENDIF
 #ifdef MPI
             ENDIF
 #endif
@@ -2120,7 +2731,6 @@
       RETURN
       END SUBROUTINE WRITE_WAVE_FUNCTIONS
 
-
 !******************** SUBROUTINE OCCURS_IN_FILE ************************
 !      
 !***********************************************************************
diff -bruN src/wave_high.F ../vasp.5.4.4_mod/src/wave_high.F
--- src/wave_high.F	2017-04-20 10:04:00.000000000 +0100
+++ ../vasp.5.4.4_mod/src/wave_high.F	2020-06-25 17:50:31.854092339 +0100
@@ -54,6 +54,17 @@
   END INTERFACE
 
   INTERFACE
+     SUBROUTINE ECCP_NL_SPN(LMDIM,LMMAXC,PAULI,CDIJ,CPROJ1,CPROJ2,CNL)
+       USE prec
+       COMPLEX(q):: PAULI
+       GDEF      CNL
+       INTEGER LMDIM, LMMAXC
+       OVERLAP CDIJ
+       GDEF CPROJ1,CPROJ2
+     END SUBROUTINE ECCP_NL_SPN
+  END INTERFACE
+
+  INTERFACE
      SUBROUTINE OVERL(WDES1, LOVERL, LMDIM, CQIJ, CPROF, CRESUL)
        USE wave
        TYPE (wavedes1) WDES1
@@ -634,6 +645,120 @@
       
   END FUNCTION W1_DOT
 
+!***********************************************************************
+!
+! calculate the dot product between two wavefunctions
+!  C=   W1^* x W2
+! this is a substitue for the routine CINDPROD but mind
+! the W1 and W2 are interchanged
+!
+!
+!***********************************************************************
+
+FUNCTION W1_SPN_DOT(W1, W2, CQIJ) RESULT (C)
+  IMPLICIT NONE
+  TYPE (wavefun1)    W1, W2
+  GDEF :: cdum1,cdum2
+!  GDEF :: cdum1_aug,cdum2_aug,sigma_x_aug,sigma_y_aug,sigma_z_aug
+  ! INTEGER NC                      ! stride of C
+  OVERLAP :: CQIJ(:,:,:,:) ! optional overlap operator
+!  OVERLAP, ALLOCATABLE :: SCQIJ_x(:,:,:,:),SCQIJ_y(:,:,:,:),SCQIJ_z(:,:,:,:) ! optional overlap operator * pauli matrix
+  COMPLEX(q), EXTERNAL :: ZDOTC
+  REAL(q), EXTERNAL ::  DDOT
+! local
+  COMPLEX(q) :: PAULI
+  GDEF :: CNLx,CNLy,CNLz,C(3)
+  INTEGER :: LMDIM, NPRO, NPRO_, ISPINOR, ISPINOR_, LMMAXC, NT, NI, NIS
+
+!  ALLOCATE(SCQIJ_x(1,1,W1%WDES1%NTYP,4),SCQIJ_y(1,1,W1%WDES1%NTYP,4),SCQIJ_z(1,1,W1%WDES1%NTYP,4))
+
+
+  ! DO ISPINOR=0,W1%WDES1%NRSPINORS-1
+  !   DO ISPINOR_=0,W1%WDES1%NRSPINORS-1
+  cdum1=ZDOTC( W1%WDES1%NPL/2,W1%CW(1),1,W2%CW(1+W1%WDES1%NPL/2*(W1%WDES1%NRSPINORS-1)),1)
+  cdum2=ZDOTC( W1%WDES1%NPL/2,W1%CW(1+W1%WDES1%NPL/2*(W1%WDES1%NRSPINORS-1)),1,W2%CW(1),1)
+  C(1)=cdum1+cdum2
+  C(2)=cmplx(0._q,1._q,q)*(cdum2-cdum1)
+  C(3)=zdotc(W1%WDES1%NPL/2,W1%CW(1),1,W2%CW(1),1)&
+         -zdotc(W1%WDES1%NPL/2,W1%CW(1+W1%WDES1%NPL/2*(W1%WDES1%NRSPINORS-1)),1,W2%CW(1+W1%WDES1%NPL/2*(W1%WDES1%NRSPINORS-1)),1)
+  
+  ! getme SCQIJ
+!  WRITE(*,*) "number of type", W1%WDES1%NTYP
+!  WRITE(*,*) "CQIJ: ",CQIJ(1,1,1,:)
+!  DO NT=1,W1%WDES1%NTYP
+!    SCQIJ_x(1,1,NI,1+0+2*0)=CQIJ(1,1,NI,1+1+2*0)
+!    SCQIJ_x(1,1,NI,1+0+2*1)=CQIJ(1,1,NI,1+1+2*1)
+!    SCQIJ_x(1,1,NI,1+1+2*0)=CQIJ(1,1,NI,1+0+2*0)
+!    SCQIJ_x(1,1,NI,1+1+2*1)=CQIJ(1,1,NI,1+0+2*1)
+!
+!    SCQIJ_y(1,1,NI,1+0+2*0)=cmplx(0._q,-1._q,q)*CQIJ(1,1,NI,1+1+2*0)
+!    SCQIJ_y(1,1,NI,1+0+2*1)=cmplx(0._q,-1._q,q)*CQIJ(1,1,NI,1+1+2*1)
+!    SCQIJ_y(1,1,NI,1+1+2*0)=cmplx(0._q,1._q,q)*CQIJ(1,1,NI,1+0+2*0)
+!    SCQIJ_y(1,1,NI,1+1+2*1)=cmplx(0._q,1._q,q)*CQIJ(1,1,NI,1+0+2*1)
+!
+!    SCQIJ_z(1,1,NI,1+0+2*0)=CQIJ(1,1,NI,1+0+2*0)
+!    SCQIJ_z(1,1,NI,1+0+2*1)=CQIJ(1,1,NI,1+0+2*1)
+!    SCQIJ_z(1,1,NI,1+1+2*0)=-1._q*CQIJ(1,1,NI,1+1+2*0)
+!    SCQIJ_z(1,1,NI,1+1+2*1)=-1._q*CQIJ(1,1,NI,1+1+2*1)
+!  ENDDO
+  
+!  WRITE(*,*) "SCQIJ_x: ",SCQIJ_x(1,1,1,:)
+!  WRITE(*,*) "SCQIJ_y: ",SCQIJ_y(1,1,1,:)
+!  WRITE(*,*) "SCQIJ_z: ",SCQIJ_z(1,1,1,:)
+
+  IF ( W1%WDES1%LOVERL .AND.  W1%WDES1%NPROD>0 ) THEN
+     CNLx=0
+     CNLy=0
+     CNLz=0
+
+     LMDIM = SIZE(CQIJ,1)
+
+     spinor: DO ISPINOR=0,W1%WDES1%NRSPINORS-1
+     DO ISPINOR_=0,W1%WDES1%NRSPINORS-1
+
+        NPRO =ISPINOR *(W1%WDES1%NPRO/2)
+        NPRO_=ISPINOR_*(W1%WDES1%NPRO/2)
+        NIS =1
+        DO NT=1,W1%WDES1%NTYP
+           LMMAXC=W1%WDES1%LMMAX(NT)
+           IF (LMMAXC/=0) THEN
+              DO NI=NIS,W1%WDES1%NITYP(NT)+NIS-1
+                IF (ISPINOR==0 .AND. ISPINOR_==0 ) THEN
+                  CALL ECCP_NL_SPN(LMDIM,LMMAXC,CMPLX(1._q,0._q,q),CQIJ(1,1,NI,1+0+2*1),W2%CPROJ(NPRO_+1),W1%CPROJ(NPRO+1),CNLx)
+                  CALL ECCP_NL_SPN(LMDIM,LMMAXC,CMPLX(0._q,-1._q,q),CQIJ(1,1,NI,1+0+2*1),W2%CPROJ(NPRO_+1),W1%CPROJ(NPRO+1),CNLy)
+                  CALL ECCP_NL_SPN(LMDIM,LMMAXC,CMPLX(1._q,0._q,q),CQIJ(1,1,NI,1+0+2*0),W2%CPROJ(NPRO_+1),W1%CPROJ(NPRO+1),CNLz)
+	        ELSEIF (ISPINOR==0 .AND. ISPINOR_==1 ) THEN
+                  CALL ECCP_NL_SPN(LMDIM,LMMAXC,CMPLX(1._q,0._q,q),CQIJ(1,1,NI,1+1+2*1),W2%CPROJ(NPRO_+1),W1%CPROJ(NPRO+1),CNLx)
+                  CALL ECCP_NL_SPN(LMDIM,LMMAXC,CMPLX(0._q,-1._q,q),CQIJ(1,1,NI,1+1+2*1),W2%CPROJ(NPRO_+1),W1%CPROJ(NPRO+1),CNLy)
+                  CALL ECCP_NL_SPN(LMDIM,LMMAXC,CMPLX(1._q,0._q,q),CQIJ(1,1,NI,1+1+2*0),W2%CPROJ(NPRO_+1),W1%CPROJ(NPRO+1),CNLz)
+	        ELSEIF (ISPINOR==1 .AND. ISPINOR_==0 ) THEN
+                  CALL ECCP_NL_SPN(LMDIM,LMMAXC,CMPLX(1._q,0._q,q),CQIJ(1,1,NI,1+0+2*0),W2%CPROJ(NPRO_+1),W1%CPROJ(NPRO+1),CNLx)
+                  CALL ECCP_NL_SPN(LMDIM,LMMAXC,CMPLX(0._q,1._q,q),CQIJ(1,1,NI,1+0+2*0),W2%CPROJ(NPRO_+1),W1%CPROJ(NPRO+1),CNLy)
+                  CALL ECCP_NL_SPN(LMDIM,LMMAXC,CMPLX(1._q,0._q,q),CQIJ(1,1,NI,1+0+2*1),W2%CPROJ(NPRO_+1),W1%CPROJ(NPRO+1),CNLz)
+	        ELSEIF (ISPINOR==1 .AND. ISPINOR_==1 ) THEN
+                  CALL ECCP_NL_SPN(LMDIM,LMMAXC,CMPLX(1._q,0._q,q),CQIJ(1,1,NI,1+1+2*0),W2%CPROJ(NPRO_+1),W1%CPROJ(NPRO+1),CNLx)
+                  CALL ECCP_NL_SPN(LMDIM,LMMAXC,CMPLX(0._q,1._q,q),CQIJ(1,1,NI,1+1+2*1),W2%CPROJ(NPRO_+1),W1%CPROJ(NPRO+1),CNLy)
+                  CALL ECCP_NL_SPN(LMDIM,LMMAXC,CMPLX(1._q,0._q,q),CQIJ(1,1,NI,1+1+2*1),W2%CPROJ(NPRO_+1),W1%CPROJ(NPRO+1),CNLz)
+		ENDIF
+                 NPRO = LMMAXC+NPRO
+                 NPRO_= LMMAXC+NPRO_
+              ENDDO
+           ENDIF
+           NIS = NIS+W1%WDES1%NITYP(NT)
+        ENDDO
+     ENDDO
+     ENDDO spinor
+     C(1)=C(1)+CNLx
+     C(2)=C(2)+CNLy
+     C(3)=C(3)+CNLz
+  ENDIF
+  !WRITE(*,*) C
+  CALLMPI( M_sum_g(W1%WDES1%COMM_INB, C(1), 3))
+  !WRITE(*,*) "Am I fucked?"
+  !DEALLOCATE(SCQIJ_x,SCQIJ_y,SCQIJ_z)
+  !WRITE(*,*) "fuck this shit?"
+
+END FUNCTION W1_SPN_DOT
 
 !***********************************************************************
 !
@@ -3158,6 +3283,42 @@
 
   END SUBROUTINE ECCP_NL
 
+!************************* SUBROUTINE ECCP_NL_SPN   ************************
+!
+! this subroutine calculates the expectation value of <c|SPN*H|cp>
+! where c and cp are two wavefunctions; non local part only
+! for one ion only
+! I have put this in a separate routine because optimization
+! is than easier
+!
+!***********************************************************************
+
+  SUBROUTINE ECCP_NL_SPN(LMDIM,LMMAXC,PAULI,CDIJ,CPROJ1,CPROJ2,CNL)
+    USE prec
+    IMPLICIT NONE
+    COMPLEX(q) :: PAULI
+    GDEF      CNL
+    INTEGER LMDIM, LMMAXC
+    OVERLAP CDIJ(LMDIM,LMDIM)
+    GDEF CPROJ1(LMMAXC),CPROJ2(LMMAXC)
+ ! local
+    INTEGER L, LP
+
+!   PROFILING_START('eccp_nl')
+
+!DIR$ IVDEP
+!OCL NOVREL
+    DO L=1,LMMAXC
+       DO LP=1,LMMAXC
+          CNL=CNL+PAULI*CDIJ(LP,L)*CPROJ1(LP)*GCONJG(CPROJ2(L))
+       ENDDO
+    ENDDO
+
+!   PROFILING_STOP('eccp_nl')
+
+END SUBROUTINE ECCP_NL_SPN
+
+
 
 !************************* SUBROUTINE OVERL ***************************
 !
@@ -3434,3 +3595,5 @@
     ENDDO spinor
 
   END SUBROUTINE OVERL1_CCDIJ
+
+
