diff -bruN src/mlwf.F ../vasp.5.4.4_mod/src/mlwf.F
--- src/mlwf.F	2017-04-20 10:03:58.000000000 +0100
+++ ../vasp.5.4.4_mod/src/mlwf.F	2020-07-05 21:52:18.430979695 +0100
@@ -6,12 +6,26 @@
  
       ! write the wave functions to UNK files
       LOGICAL, PRIVATE, SAVE :: WRITE_UNK
+      LOGICAL, PRIVATE, SAVE :: UNK_FMTED
+      LOGICAL, PRIVATE, SAVE :: REDUCE_UNK
+
+      ! write the wave functions to UNK files
+      LOGICAL, PRIVATE, SAVE :: WRITE_SPN
+      LOGICAL, PRIVATE, SAVE :: SPN_FMTED
+
       ! write the mmn and amn files when WANNIER90 runs in lib mode
-      LOGICAL, PRIVATE, SAVE :: WRITE_MMN_AMN
+      LOGICAL, PRIVATE, SAVE :: CALC_MMN
+      LOGICAL, PRIVATE, SAVE :: CALC_AMN
+      LOGICAL, PRIVATE, SAVE :: WRITE_MMN
+      LOGICAL, PRIVATE, SAVE :: WRITE_AMN
+      LOGICAL, PRIVATE, SAVE :: WRITE_EIG
 
       ! read amn file instead of computing it
       LOGICAL, PRIVATE, SAVE :: READ_AMN
 
+      ! which collinear spin channel do we want?
+      INTEGER, PRIVATE, SAVE :: W90_SPIN
+
       ! wannier90_run variables: output
       COMPLEX(q), ALLOCATABLE, SAVE :: U_matrix(:,:,:,:)
       COMPLEX(q), ALLOCATABLE, SAVE :: U_matrix_opt(:,:,:,:)
@@ -185,6 +199,20 @@
          ! Switch on the PEAD routines
          CALL PEAD_REQUEST
 
+         ! spin channel
+         W90_SPIN=0
+         CALL RDATAB(.FALSE.,INCAR,IU5,'W90_SPIN','=','#',';','I', &
+        &            W90_SPIN,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+         IF (((IERR/=0).AND.(IERR/=3)).OR. &
+        &                    ((IERR==0).AND.(N<1))) THEN
+            IF (IU0>=0) &
+               WRITE(IU0,*)'Error reading item ''LWRITE_UNK'' from file INCAR.'
+            W90_SPIN=0
+            IF (W90_SPIN/=0 .AND. W90_SPIN/=1 .AND. W90_SPIN/=2) &
+               WRITE(IU0,*)'Error reading item ''LWRITE_UNK'' from file INCAR.'
+            W90_SPIN=0
+         ENDIF
+
          ! Do we want to write UNK files?
          WRITE_UNK=.FALSE.
          CALL RDATAB(.FALSE.,INCAR,IU5,'LWRITE_UNK','=','#',';','L', &
@@ -195,17 +223,119 @@
                WRITE(IU0,*)'Error reading item ''LWRITE_UNK'' from file INCAR.'
             WRITE_UNK=.FALSE.
          ENDIF
+
+         ! 2020-06-22 CCX: added to determine UNK is formatted or not
+         UNK_FMTED=.FALSE.
+         CALL RDATAB(.FALSE.,INCAR,IU5,'LUNK_FMTED','=','#',';','L', &
+        &            IDUM,RDUM,CDUM,UNK_FMTED,CHARAC,N,1,IERR)
+         IF (((IERR/=0).AND.(IERR/=3)).OR. &
+        &                    ((IERR==0).AND.(N<1))) THEN
+            IF (IU0>=0) &
+               WRITE(IU0,*)'Error reading item ''LUNK_FMTED'' from file INCAR.'
+            UNK_FMTED=.FALSE.
+         ENDIF
+         
+         ! 2020-07-04 CCX: added to determine UNK is formatted or not
+         REDUCE_UNK=.FALSE.
+         CALL RDATAB(.FALSE.,INCAR,IU5,'LREDUCE_UNK','=','#',';','L', &
+        &            IDUM,RDUM,CDUM,REDUCE_UNK,CHARAC,N,1,IERR)
+         IF (((IERR/=0).AND.(IERR/=3)).OR. &
+        &                    ((IERR==0).AND.(N<1))) THEN
+            IF (IU0>=0) &
+               WRITE(IU0,*)'Error reading item ''LREDUCE_UNK'' from file INCAR.'
+            REDUCE_UNK=.FALSE.
+         ENDIF
+
+         ! 2020-06-25 CCX: Do we want to write the spn file?
+         WRITE_SPN=.FALSE.
+         CALL RDATAB(.FALSE.,INCAR,IU5,'LWRITE_SPN','=','#',';','L', &
+        &            IDUM,RDUM,CDUM,WRITE_SPN,CHARAC,N,1,IERR)
+         IF (((IERR/=0).AND.(IERR/=3)).OR. &
+        &                    ((IERR==0).AND.(N<1))) THEN
+            IF (IU0>=0) &
+               WRITE(IU0,*)'Error reading item ''LWRITE_SPN'' from file INCAR.'
+            WRITE_SPN=.FALSE.
+         ENDIF
+
+         ! 2020-06-25 CCX: Do we want to write the spn file?
+         SPN_FMTED=.FALSE.
+         CALL RDATAB(.FALSE.,INCAR,IU5,'LSPN_FMTED','=','#',';','L', &
+        &            IDUM,RDUM,CDUM,SPN_FMTED,CHARAC,N,1,IERR)
+         IF (((IERR/=0).AND.(IERR/=3)).OR. &
+        &                    ((IERR==0).AND.(N<1))) THEN
+            IF (IU0>=0) &
+               WRITE(IU0,*)'Error reading item ''LSPN_FMTED'' from file INCAR.'
+            SPN_FMTED=.FALSE.
+         ENDIF
+
+
          ! Do we want to write the mmn and amn files
          ! even though WANNIER90 runs in library mode?
-         WRITE_MMN_AMN=.NOT.LWANNIER90_RUN
-         CALL RDATAB(.FALSE.,INCAR,IU5,'LWRITE_MMN_AMN','=','#',';','L', &
-        &            IDUM,RDUM,CDUM,WRITE_MMN_AMN,CHARAC,N,1,IERR)
+         ! 2020-07-04 CCX: do we really need to calculate MMN AMN and write EIG?
+         CALC_MMN=.TRUE.
+         CALL RDATAB(.FALSE.,INCAR,IU5,'LCALC_MMN','=','#',';','L', &
+        &            IDUM,RDUM,CDUM,CALC_MMN,CHARAC,N,1,IERR)
+         IF (((IERR/=0).AND.(IERR/=3)).OR. &
+        &                    ((IERR==0).AND.(N<1))) THEN
+            IF (IU0>=0) &
+               WRITE(IU0,*)'Error reading item ''LCALC_MMN'' from file INCAR.'
+            ! this is counterintuitive, we want to calculate MMN by default
+            CALC_MMN=.TRUE.
+         ENDIF
+         ! if wannier90_run, we need mmn calculation
+         IF ((LWANNIER90_RUN) .AND. (.NOT.CALC_MMN)) CALC_MMN=.TRUE.
+
+
+         WRITE_MMN=.NOT.LWANNIER90_RUN
+         CALL RDATAB(.FALSE.,INCAR,IU5,'LWRITE_MMN','=','#',';','L', &
+        &            IDUM,RDUM,CDUM,WRITE_MMN,CHARAC,N,1,IERR)
+         IF (((IERR/=0).AND.(IERR/=3)).OR. &
+        &                    ((IERR==0).AND.(N<1))) THEN
+            IF (IU0>=0) &
+               WRITE(IU0,*)'Error reading item ''LWRITE_MMN'' from file INCAR.'
+            WRITE_MMN=.NOT.LWANNIER90_RUN
+         ENDIF
+         ! if we dont calculate mmn, we cannot write amn...
+         IF (.NOT.CALC_MMN) WRITE_MMN=.FALSE.
+
+
+         CALC_AMN=.TRUE.
+         CALL RDATAB(.FALSE.,INCAR,IU5,'LCALC_AMN','=','#',';','L', &
+        &            IDUM,RDUM,CDUM,CALC_AMN,CHARAC,N,1,IERR)
+         IF (((IERR/=0).AND.(IERR/=3)).OR. &
+        &                    ((IERR==0).AND.(N<1))) THEN
+            IF (IU0>=0) &
+               WRITE(IU0,*)'Error reading item ''LCALC_AMN'' from file INCAR.'
+            ! this is counterintuitive, we want to calculate MMN by default
+            CALC_AMN=.TRUE.
+         ENDIF
+         ! if wannier90_run, we need amn calculation
+         IF ((LWANNIER90_RUN) .AND. (.NOT.CALC_AMN)) CALC_AMN=.TRUE.
+
+         WRITE_AMN=.NOT.LWANNIER90_RUN
+         CALL RDATAB(.FALSE.,INCAR,IU5,'LWRITE_AMN','=','#',';','L', &
+        &            IDUM,RDUM,CDUM,WRITE_AMN,CHARAC,N,1,IERR)
          IF (((IERR/=0).AND.(IERR/=3)).OR. &
         &                    ((IERR==0).AND.(N<1))) THEN
             IF (IU0>=0) &
-               WRITE(IU0,*)'Error reading item ''LWRITE_MMN_AMN'' from file INCAR.'
-            WRITE_MMN_AMN=.NOT.LWANNIER90_RUN
+               WRITE(IU0,*)'Error reading item ''LWRITE_AMN'' from file INCAR.'
+            WRITE_AMN=.NOT.LWANNIER90_RUN
          ENDIF
+         ! if we dont calculate amn, we cannot write amn...
+         IF (.NOT.CALC_AMN) WRITE_AMN=.FALSE.
+
+
+         WRITE_EIG=.NOT.LWANNIER90_RUN
+         CALL RDATAB(.FALSE.,INCAR,IU5,'LWRITE_EIG','=','#',';','L', &
+        &            IDUM,RDUM,CDUM,WRITE_EIG,CHARAC,N,1,IERR)
+         IF (((IERR/=0).AND.(IERR/=3)).OR. &
+        &                    ((IERR==0).AND.(N<1))) THEN
+            IF (IU0>=0) &
+               WRITE(IU0,*)'Error reading item ''LWRITE_EIG'' from file INCAR.'
+            WRITE_EIG=.NOT.LWANNIER90_RUN
+         ENDIF
+
+
          ! Do we want to read the amn file instead of
          ! computing it anew?
          READ_AMN=.FALSE.
@@ -320,6 +450,9 @@
       REAL(q), ALLOCATABLE :: proj_x(:,:)
       REAL(q), ALLOCATABLE :: proj_zona(:)
       INTEGER, ALLOCATABLE :: exclude_bands(:)
+      ! CCX_2019-05-05: define proj_s and proj_s_qaxis
+      INTEGER, ALLOCATABLE :: proj_s(:)
+      REAL(q), ALLOCATABLE :: proj_s_qaxis(:,:)
       ! wannier90_run variables: input
       COMPLEX(q), ALLOCATABLE :: M_matrix(:,:,:,:,:)
       COMPLEX(q), ALLOCATABLE :: A_matrix(:,:,:,:)
@@ -329,6 +462,12 @@
       INTEGER NI,MI,NK,NKP,ICNTR
       INTEGER NKI,NKJ,ISP,ISPINOR,L,M,N,NP
       INTEGER NEXCLB,NPROJ
+      ! CCX_2019-05-06: spin quantization local variables
+      LOGICAL spin_z_pos,spin_z_neg
+      COMPLEX(q) FAC(2)
+      REAL(q) :: eps6=0.000001_q
+      REAL(q) xnorm
+      ! CCX_2019-05-06: end definition
       REAL(q) POS(3)
       REAL(q) KI(3),KJ(3)
       INTEGER IDUM,IERR
@@ -347,6 +486,13 @@
       REAL(q), ALLOCATABLE :: ROTYLM(:,:)
       REAL(q), ALLOCATABLE :: HYBRID_ORBITAL(:)
 
+      ! 2020-06-25 CCX added for spn matrix calc
+      GDEF, ALLOCATABLE :: SPN(:,:,:)
+      GDEF, ALLOCATABLE :: spin_mat(:,:)
+      INTEGER :: spn_counter
+      CHARACTER (len=60)       :: SPN_header
+      ! CCX_2019-05-06: end definition
+
       LOGICAL, ALLOCATABLE :: EXCLUDE_BAND(:)
       LOGICAL LUSE_BLOCH_PHASES
       
@@ -357,20 +503,38 @@
       INTEGER num_bands_on_file,num_kpts_on_file,NPROJ_on_file
 
       IF (.NOT.WANNIER90()) RETURN
+      IF (IO%IU0>=0) WRITE(IO%IU0,*) "*---------------------------------------*"
+      IF (IO%IU0>=0) WRITE(IO%IU0,*) "*             VASP2WANNIER90            *"
+      IF (IO%IU0>=0) WRITE(IO%IU0,*) "*---------------------------------------*"
 
-#ifdef MPI
+      ! 2020-06-28 CCX: I moved this to here so we can have control over collinear spin channels.
+      ! loop over spin
+      spin: DO ISP=1,WDES%ISPIN
+
+      IF ((.not. WDES%LNONCOLLINEAR) .AND. (W90_SPIN==2) .AND. (ISP==1)) CYCLE spin
+      IF ((.not. WDES%LNONCOLLINEAR) .AND. (W90_SPIN==1) .AND. (ISP==2)) CYCLE spin
+      IF ((.not. WDES%LNONCOLLINEAR) .AND. (WDES%ISPIN==2) .AND. (IO%IU0>=0)) &
+         WRITE(IO%IU0,*)'*          Collinear spin -> '//SP(ISP)//'         *'
+      IF ((WDES%LNONCOLLINEAR) .AND. (IO%IU0>=0)) &
+         WRITE(IO%IU0,*)'*          Non-collinear spin           *'
+      IF ((.not. WDES%LNONCOLLINEAR) .AND. (WDES%ISPIN==1) .AND. (IO%IU0>=0)) &
+         WRITE(IO%IU0,*)'*         No spin polarization          *'
+
+!#ifdef MPI
 !     IF (WDES%COMM_KINTER%NCPU.NE.1) THEN
 !        CALLMPI( M_stop('MLWF_WANNIER90: KPAR>1 not implemented, sorry.') )
 !        STOP
 !     END IF
-#endif
+!#endif
+
+! 2020-06-22 CCX: wannier90 CAN plot spinors.
       ! WANNIER90 cannot plot spinors
-      IF (WRITE_UNK.AND.WDES%LNONCOLLINEAR) THEN
-         IF (IO%IU0>=0) WRITE(IO%IU0,*) &
-        & 'MLWF_WANNIER90: ERROR: will not write spinors to UNK files, sorry ...'
-         WRITE_UNK=.FALSE.
-      ENDIF
-!
+!      IF (WRITE_UNK.AND.WDES%LNONCOLLINEAR) THEN
+!         IF (IO%IU0>=0) WRITE(IO%IU0,*) &
+!        & 'MLWF_WANNIER90: ERROR: will not write spinors to UNK files, sorry ...'
+!         WRITE_UNK=.FALSE.
+!      ENDIF
+
 ! allocation
       ALLOCATE(S(WDES%NB_TOT,WDES%NB_TOT))
 
@@ -422,8 +586,25 @@
       ! A minimal wannier90.win file must exist; it must at least
       ! contain the keyword "num_wann"
       IF (IO%IU6>=0) THEN
+         IF ((.not. spinors) .AND. (WDES%ISPIN==2)) THEN
+            INQUIRE(FILE=seed_name//'.'//SP(ISP)//'.win',EXIST=LWIN_FOUND)
+         ELSE
          INQUIRE(FILE=seed_name//'.win',EXIST=LWIN_FOUND)         
+         ENDIF
+
          IF (LWIN_FOUND) THEN
+            IF ((.not. spinors) .AND. (WDES%ISPIN==2)) THEN
+               OPEN(UNIT=99,FILE=seed_name//'.'//SP(ISP)//'.win',STATUS='OLD')
+               CALL RDATAB(.FALSE.,seed_name//'.'//SP(ISP)//'.win',99,'num_wann','=','#',';','I', &
+              &            IDUM,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+               IF (((IERR/=0).AND.(IERR/=3)).OR. &
+              &                    ((IERR==0).AND.(N<1))) THEN
+                  IF (IO%IU0>=0) &
+                     WRITE(IO%IU0,*)'Error reading item ''num_wann'' from file '//seed_name//'.win'
+                  STOP
+               ENDIF
+               IF (IERR==3) WRITE(99,'(A,I6,2X,A)') ' num_wann =',WDES%NB_TOT,'! set to NBANDS by VASP'
+            ELSE
             OPEN(UNIT=99,FILE=seed_name//'.win',STATUS='OLD')
             CALL RDATAB(.FALSE.,seed_name//'.win',99,'num_wann','=','#',';','I', &
            &            IDUM,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
@@ -434,10 +615,16 @@
                STOP
             ENDIF
             IF (IERR==3) WRITE(99,'(A,I6,2X,A)') ' num_wann =',WDES%NB_TOT,'! set to NBANDS by VASP'
+            ENDIF
+         ELSE
+            IF ((.not. spinors) .AND. (WDES%ISPIN==2)) THEN
+               OPEN(UNIT=99,FILE=seed_name//'.'//SP(ISP)//'.win',STATUS='REPLACE')
+               WRITE(99,'(A,I6,2X,A)') ' num_wann =',WDES%NB_TOT,'! set to NBANDS by VASP'
          ELSE
             OPEN(UNIT=99,FILE=seed_name//'.win',STATUS='REPLACE')
             WRITE(99,'(A,I6,2X,A)') ' num_wann =',WDES%NB_TOT,'! set to NBANDS by VASP'
          ENDIF
+         ENDIF
          CLOSE(99) 
       ENDIF
 
@@ -449,18 +636,47 @@
 
       ALLOCATE(proj_site(3,num_bands_tot),proj_l(num_bands_tot),proj_m(num_bands_tot), &
      &   proj_radial(num_bands_tot),proj_z(3,num_bands_tot),proj_x(3,num_bands_tot), &
-     &   proj_zona(num_bands_tot),exclude_bands(num_bands_tot))
+     &   proj_zona(num_bands_tot),exclude_bands(num_bands_tot), &
+#ifdef VASP2WANNIER90v2
+! CCX_2019-05-05: allocate proj_s and proj_s_qaxis.
+     &   proj_s(num_bands_tot),proj_s_qaxis(3,num_bands_tot) &
+#endif
+     &   )
       proj_site=0; proj_l=0; proj_m=0; proj_radial=0; proj_z=0; proj_x=0; proj_zona=0; exclude_bands=0
 
+! CCX_2019-05-05: initialize proj_s and proj_s_qaxis.
+#ifdef VASP2WANNIER90v2
+      proj_s=0; proj_s_qaxis=0
+#endif
+
       ! Only one node will do the actual work,
       ! otherwise all will write to wannier90.wout
 #ifdef VASP2WANNIER90
-      IF (IO%IU6>=0) &
+      IF (IO%IU6>=0) THEN
+         IF ((.not.spinors) .AND. (WDES%ISPIN==2)) THEN
+      CALL wannier_setup(seed_name//'.'//SP(ISP),mp_grid,num_kpts,real_lattice,recip_lattice, &
+     &                   kpt_latt,num_bands_tot,num_atoms,atom_symbols,atoms_cart, &
+     &                   gamma_only,spinors,nntot,nnlist,nncell,num_bands,num_wann, &
+     &                   proj_site,proj_l,proj_m,proj_radial,proj_z,proj_x,proj_zona, &
+     &                   exclude_bands, &
+#ifdef VASP2WANNIER90v2
+! CCX_2019-05-05: call wannier_setup to calculate proj_s and proj_s_qaxis
+     &                   proj_s,proj_s_qaxis &
+#endif
+     &                   )
+         ELSE
       CALL wannier_setup(seed_name,mp_grid,num_kpts,real_lattice,recip_lattice, &
      &                   kpt_latt,num_bands_tot,num_atoms,atom_symbols,atoms_cart, &
      &                   gamma_only,spinors,nntot,nnlist,nncell,num_bands,num_wann, &
      &                   proj_site,proj_l,proj_m,proj_radial,proj_z,proj_x,proj_zona, &
-     &                   exclude_bands)
+     &                   exclude_bands, &
+#ifdef VASP2WANNIER90v2
+! CCX_2019-05-05: call wannier_setup to calculate proj_s and proj_s_qaxis
+     &                   proj_s,proj_s_qaxis &
+#endif
+     &                   )
+         ENDIF
+      ENDIF
 #endif
       ! Now communicate the output to the other nodes
       CALLMPI( M_sum_i(WDES%COMM,nntot,1) ) 
@@ -476,6 +692,11 @@
       CALLMPI( M_sum_d(WDES%COMM,proj_x,3*num_bands_tot) )
       CALLMPI( M_sum_d(WDES%COMM,proj_zona,num_bands_tot) )
       CALLMPI( M_sum_i(WDES%COMM,exclude_bands,num_bands_tot) )
+! CCX_2019-05-05: bcast proj_s and proj_s_qaxis
+#ifdef VASP2WANNIER90v2
+      CALLMPI( M_sum_i(WDES%COMM,proj_s,num_bands_tot) )
+      CALLMPI( M_sum_d(WDES%COMM,proj_s_qaxis,3*num_bands_tot) )
+#endif
 
       ALLOCATE(EXCLUDE_BAND(num_bands_tot))
       EXCLUDE_BAND=.FALSE. ; NEXCLB=0
@@ -530,10 +751,7 @@
       ! nullify pointers by default
       R%R=>NULL(); R%SI=>NULL()
 
-      ! loop over spin
-      spin: DO ISP=1,WDES%ISPIN
-
-      IF (IO%IU6>=0.AND.WRITE_MMN_AMN) THEN
+      IF (IO%IU6>=0.AND.WRITE_MMN) THEN
          IF (WDES%ISPIN==1) THEN
             OPEN(UNIT=99,FILE=seed_name//'.mmn',STATUS='REPLACE')
          ELSE
@@ -542,6 +760,9 @@
          WRITE(99,'(A)') 'File generated by VASP: '//INFO%SZNAM1
          WRITE(99,'(3I12)') num_bands,num_kpts,nntot
       ENDIF
+
+      ! 2020-07-04 CCX: do we want to calculate mmn matrix
+      IF (CALC_MMN) THEN
       ! runs over all k-points
       ki_loop: DO NKI=1,num_kpts
          KI(:)=kpt_latt(:,NKI)
@@ -553,7 +774,7 @@
 #endif
             CALL PEAD_CALC_OVERLAP(W,KI,KJ,ISP,P,CQIJ,LATT_CUR,T_INFO,S,LQIJB=.TRUE.)
 
-            IF (IO%IU6>=0.AND.WRITE_MMN_AMN) WRITE(99,'(5I5)') NKI,nnlist(NKI,NKJ),nncell(:,NKI,NKJ)
+            IF (IO%IU6>=0.AND.WRITE_MMN) WRITE(99,'(5I5)') NKI,nnlist(NKI,NKJ),nncell(:,NKI,NKJ)
 
             NI=0
             n_loop: DO N=1,WDES%NB_TOT
@@ -563,7 +784,7 @@
                   IF (EXCLUDE_BAND(M)) CYCLE m_loop
                   MI=MI+1
                   M_matrix(MI,NI,NKJ,NKI,ISP)=S(M,N)
-                  IF (IO%IU6>=0.AND.WRITE_MMN_AMN) WRITE(99,'(2F18.12)') S(M,N)
+                  IF (IO%IU6>=0.AND.WRITE_MMN) WRITE(99,'(2F18.12)') S(M,N)
                ENDDO m_loop
             ENDDO n_loop
             ! check consistency
@@ -575,7 +796,82 @@
          ENDDO kj_loop
       ENDDO ki_loop
 
-      IF (IO%IU6>=0.AND.WRITE_MMN_AMN) CLOSE(99)
+      IF (IO%IU6>=0.AND.WRITE_MMN) CLOSE(99)
+      IF (IO%IU0>=0) WRITE(IO%IU0,*) "*            MMN calculated.            *"
+      !2020-07-04
+      ENDIF
+
+
+      ! 2020-06-25 CCX: write SPN matrix
+      IF (WRITE_SPN .AND. (.NOT. spinors)) THEN
+         IF (IO%IU0>=0) WRITE(*,*) 'MLWF_WANNIER90: WRITE_SPN only works in non-collinear, skipping.'
+         WRITE_SPN=.FALSE.
+      ENDIF
+
+      IF (WRITE_SPN .AND. WDES%COMM%NCPU.NE.1) THEN
+         IF (IO%IU0>=0) WRITE(*,*) 'MLWF_WANNIER90: WRITE_SPN only works in serial, skipping.'
+         WRITE_SPN=.FALSE.
+      ENDIF
+
+      IF (IO%IU6>=0.AND.WRITE_SPN) THEN
+         IF (WDES%NRSPINORS==1) THEN
+            IF (IO%IU0>=0) WRITE(*,*) 'MLWF_WANNIER90: ERROR: WRITE_SPN specified, but collinear calculation.'
+            STOP
+         ELSE
+            IF (SPN_FMTED) THEN
+               OPEN(UNIT=99,FILE=seed_name//'.spn',FORM="FORMATTED",STATUS='REPLACE')
+               SPN_header = 'File generated by VASP: '//INFO%SZNAM1
+               WRITE(99,'(A)') SPN_header
+               WRITE(99,'(3I12)') num_bands,num_kpts
+            ELSE
+               OPEN(UNIT=99,FILE=seed_name//'.spn',FORM="UNFORMATTED",STATUS='REPLACE')
+               SPN_header = 'File generated by VASP: '//INFO%SZNAM1
+               WRITE(99) SPN_header
+               WRITE(99) num_bands,num_kpts
+            ENDIF
+         ENDIF
+      ENDIF
+
+      IF (WDES%NRSPINORS/=1.AND.WRITE_SPN) THEN
+      ALLOCATE(spin_mat((num_bands+1)*num_bands/2,3))
+      ALLOCATE(SPN(WDES%NB_TOT,WDES%NB_TOT,3))
+      ! runs over all k-points
+      spn_ki_loop: DO NKI=1,num_kpts
+         KI(:)=kpt_latt(:,NKI)
+
+         CALL CALC_SPN_EXP(W,KI,P,CQIJ,LATT_CUR,T_INFO,SPN)
+
+         !now, we nned to exclude some bands.
+         NI=0
+         spn_n_loop: DO N=1,WDES%NB_TOT
+            IF (EXCLUDE_BAND(N)) CYCLE spn_n_loop
+               spn_m_loop: DO M=1,N
+                  IF (EXCLUDE_BAND(M)) CYCLE spn_m_loop
+                  NI=NI+1
+                  DO spn_counter=1,3
+                     spin_mat(NI,spn_counter)=SPN(M,N,spn_counter)
+                  ENDDO
+               ENDDO spn_m_loop
+         ENDDO spn_n_loop
+
+         ! writing spn matrix to file
+         IF (SPN_FMTED) THEN
+            DO N=1,(num_bands+1)*num_bands/2
+               IF (IO%IU6>=0.AND.WRITE_SPN) WRITE(99,'(2ES26.16)') (spin_mat(N,spn_counter), spn_counter=1,3)
+            ENDDO
+         ELSE
+               IF (IO%IU6>=0.AND.WRITE_SPN) WRITE(99) ((spin_mat(N,spn_counter), spn_counter=1,3), N=1,(num_bands+1)*num_bands/2)
+         ENDIF
+      ENDDO spn_ki_loop
+
+      ! some deallocation for spn mat
+      DEALLOCATE(spin_mat)
+      DEALLOCATE(SPN)
+
+      IF (IO%IU6>=0.AND.WRITE_SPN) CLOSE(99)
+      IF (IO%IU0>=0) WRITE(IO%IU0,*) "*            SPN calculated.            *"
+      ENDIF
+      ! 2020-06-25 CCX: spin matrix calculated
 
       ! and we might want to read an existing amn file
       IF (READ_AMN) THEN
@@ -584,9 +880,16 @@
       DO ISPINOR=1,WDES%NRSPINORS
       DO ICNTR=1,num_bands_tot
          IF (proj_l(ICNTR)==0.AND.proj_m(ICNTR)==0.AND.proj_radial(ICNTR)==0) CYCLE
+! CCX_2019-05-05: only calculate corresponding spin channel
+#ifdef VASP2WANNIER90v2
+         IF (WDES%NRSPINORS/=1.AND.proj_s(ICNTR)==1.AND.ISPINOR==2) CYCLE
+         IF (WDES%NRSPINORS/=1.AND.proj_s(ICNTR)==-1.AND.ISPINOR==1) CYCLE
+#endif
+
          NPROJ=NPROJ+1
       ENDDO
       ENDDO
+
       ! check if amn file exists
       IF (WDES%ISPIN==1) THEN
          INQUIRE(FILE=seed_name//'.amn',EXIST=LAMN_FOUND)
@@ -627,7 +930,8 @@
       ENDIF
       ENDIF ! finished reading A_matrix
 
-      IF (.NOT.READ_AMN) THEN
+      ! 2020-07-04 CCX: added to control amn calculaiton
+      IF ( .NOT. READ_AMN .AND. CALC_AMN) THEN
       ! we need to calculate the projection of the wave functions
       ! onto a set of trial functions {g}: A(m,n,i) = < \psi_m,k_i | g_n >
       ! A(m,n,i) is then written to the file seed_name.amn
@@ -643,11 +947,36 @@
       ALLOCATE(ROTYLM((LMAX+1)**2,(LMAX+1)**2),HYBRID_ORBITAL((LMAX+1)**2))
 
       NPROJ=0 
-!     CALL START_TIMING("T1")
+      ! CCX_2020-06-15: initialize A matrix
+      A_matrix=0
       ! runs over all projector sites
-      spinor: DO ISPINOR=1,WDES%NRSPINORS
       sites : DO ICNTR=1,num_bands_tot
          IF (proj_l(ICNTR)==0.AND.proj_m(ICNTR)==0.AND.proj_radial(ICNTR)==0) CYCLE sites
+        ! CCX_2019-05-06: determin spin quantization axis along z axis or not.
+        spin_z_pos=.false.
+        spin_z_neg=.false.
+        ! CCX_2019-06-10: renormalize spin quantization axis
+        xnorm=SQRT(proj_s_qaxis(1,ICNTR)*proj_s_qaxis(1,ICNTR)+proj_s_qaxis(2,ICNTR)*proj_s_qaxis(2,ICNTR)+proj_s_qaxis(3,ICNTR)*proj_s_qaxis(3,ICNTR))
+        proj_s_qaxis(1,ICNTR)=proj_s_qaxis(1,ICNTR)/xnorm
+        proj_s_qaxis(2,ICNTR)=proj_s_qaxis(2,ICNTR)/xnorm
+        proj_s_qaxis(3,ICNTR)=proj_s_qaxis(3,ICNTR)/xnorm
+
+        IF ((abs(proj_s_qaxis(1,ICNTR)-0.0d0)<eps6).and.(abs(proj_s_qaxis(2,ICNTR)-0.0d0)<eps6) &
+           .and.(abs(proj_s_qaxis(3,ICNTR)-1.0d0)<eps6)) then
+           spin_z_pos=.true.
+        ELSEIF(abs(proj_s_qaxis(1,ICNTR)-0.0d0)<eps6.and.abs(proj_s_qaxis(2,ICNTR)-0.0d0)<eps6 &
+           .and.abs(proj_s_qaxis(3,ICNTR)+1.0d0)<eps6) then
+           spin_z_neg=.true.
+        ENDIF
+        ! CCX_2019-05-06: [start] if proj_s_qaxis lies along z, normal projections are done.
+        IF (spin_z_pos .OR. spin_z_neg .OR. WDES%NRSPINORS==1) THEN ! if not spinor, still use this routine.
+        spinor1: DO ISPINOR=1,WDES%NRSPINORS
+           IF (spin_z_pos.AND.WDES%NRSPINORS/=1.AND.proj_s(ICNTR)==1.AND.ISPINOR==2) CYCLE spinor1
+           IF (spin_z_pos.AND.WDES%NRSPINORS/=1.AND.proj_s(ICNTR)==-1.AND.ISPINOR==1) CYCLE spinor1
+           ! if neg then swap up and down definition
+           IF (spin_z_neg.AND.WDES%NRSPINORS/=1.AND.proj_s(ICNTR)==1.AND.ISPINOR==1) CYCLE spinor1
+           IF (spin_z_neg.AND.WDES%NRSPINORS/=1.AND.proj_s(ICNTR)==-1.AND.ISPINOR==2) CYCLE spinor1
+
          NPROJ=NPROJ+1
          ! setup the Ylm rotation matrix in accordance with proj_z and proj_x
          CALL SETROTYLM(proj_x(:,ICNTR),proj_z(:,ICNTR),LMAX,ROTYLM)
@@ -673,9 +1002,9 @@
          ENDDO
 
 
-!        CALL START_TIMING("T2")
+      !        CALL START_TIMING("T2")
          ! runs over all k-points
-         kpoints : DO NKI=1,num_kpts
+            kpoints1 : DO NKI=1,num_kpts
             CALL CALC_OVERLAP_GN( &
            &   LMAX,FG,proj_site(:,ICNTR),W,kpt_latt(:,NKI),ISP,ISPINOR,P,CQIJ,LATT_CUR,T_INFO,A)
             ! and rotate them in accordance with proj_z and proj_x
@@ -712,15 +1041,111 @@
                A_matrix(MI,NPROJ,NKI,ISP)=CPROJ
             ENDDO
 
+            ENDDO kpoints1
+
+         DEALLOCATE(FTMP,FR,FGTMP,FG)
+
+         IF (IO%IU0>=0) WRITE(IO%IU0,'(X,A,I3,A)') '*          Projection ',NPROJ,' done.         *'
+      !        CALL STOP_TIMING("T2",IO%IU6,'  OVL')
+      !        CALL STOP_TIMING("T1",IO%IU6,'ICNTR')
+        ENDDO spinor1
+        ! CCX_2019-05-06: [end] end normal routine.
+
+        ELSE ! CCX_2019-05-06: quantization axis does not lies along z axis, do special projection routine.
+        ! CCX_2019-05-06: generate spinor eigenvectors.
+        ! CCX_2019-06-10: renormalize spin quantization axis
+          xnorm=SQRT(proj_s_qaxis(1,ICNTR)*proj_s_qaxis(1,ICNTR)+proj_s_qaxis(2,ICNTR)*proj_s_qaxis(2,ICNTR)+proj_s_qaxis(3,ICNTR)*proj_s_qaxis(3,ICNTR))
+          proj_s_qaxis(1,ICNTR)=proj_s_qaxis(1,ICNTR)/xnorm
+          proj_s_qaxis(2,ICNTR)=proj_s_qaxis(2,ICNTR)/xnorm
+          proj_s_qaxis(3,ICNTR)=proj_s_qaxis(3,ICNTR)/xnorm
+
+          IF (proj_s(ICNTR)==1) THEN ! up channel
+              FAC(1)=(1.0d0/SQRT(1+proj_s_qaxis(3,ICNTR)))*(proj_s_qaxis(3,ICNTR)+1)*CMPLX(1.0d0,0.0d0,q)
+              FAC(2)=(1.0d0/SQRT(1+proj_s_qaxis(3,ICNTR)))*CMPLX(proj_s_qaxis(1,ICNTR),proj_s_qaxis(2,ICNTR),q)
+              NPROJ=NPROJ+1
+          ELSE ! down channel
+              FAC(1)=(1.0d0/SQRT(1-proj_s_qaxis(3,ICNTR)))*(proj_s_qaxis(3,ICNTR)-1)*CMPLX(1.0d0,0.0d0,q)
+              FAC(2)=(1.0d0/SQRT(1-proj_s_qaxis(3,ICNTR)))*CMPLX(proj_s_qaxis(1,ICNTR),proj_s_qaxis(2,ICNTR),q)
+              NPROJ=NPROJ+1
+          ENDIF
+
+          ! 2020-06-15 CCX: we no longer need ISPINOR loop since we are using full spinor guiding functions.
+          !spinor: DO ISPINOR=1,WDES%NRSPINORS
+           ! setup the Ylm rotation matrix in accordance with proj_z and proj_x
+          CALL SETROTYLM(proj_x(:,ICNTR),proj_z(:,ICNTR),LMAX,ROTYLM)
+#ifdef debug
+            IF (IO%IU6>=0) THEN
+               WRITE(*,'(I4,3F14.7)') ICNTR,proj_site(1:3,ICNTR)
+               DO N=10,MIN((LMAX+1)**2,16)
+                  WRITE(*,'(9F10.5)') (ROTYLM(N,M),M=10,MIN((LMAX+1)**2,16))
+               ENDDO
+            ENDIF
+#endif
+          ! translate between VASP and the orbital definition of wannier90
+          CALL WANNIER90_ORBITAL_DEFINITIONS(proj_l(ICNTR),proj_m(ICNTR),HYBRID_ORBITAL)
+
+          ! setup the radial functions (real space)
+          CALL SETRGRID(RSTART/proj_zona(ICNTR),REND,H,R)
+          ALLOCATE(FTMP(R%NMAX),FR(R%NMAX,LMAX+1))
+          ALLOCATE(FGTMP(NMAX,5),FG(NMAX,5,LMAX+1))
+
+          ! For now we use the same radial function for all L
+          DO L=0,LMAX
+             CALL RADIAL_FUNCTION(proj_radial(ICNTR),R,proj_zona(ICNTR),FTMP)
+             CALL BESSEL_TRANSFORM_RADIAL_FUNCTION(L,R,FTMP,REAL(SQRT(2._q*INFO%ENMAX/HSQDTM)/NMAX,KIND=q),FGTMP)
+             FR(:,L+1)=FTMP; FG(:,:,L+1)=FGTMP
+          ENDDO
+
+         !        CALL START_TIMING("T2")
+          ! runs over all k-points
+          kpoints : DO NKI=1,num_kpts
+             CALL CALC_OVERLAP_GN_ALL( &
+            &   LMAX,FG,proj_site(:,ICNTR),W,kpt_latt(:,NKI),ISP,FAC,P,CQIJ,LATT_CUR,T_INFO,A)
+             ! and rotate them in accordance with proj_z and proj_x
+             AP=0
+             DO M=1,WDES%NB_TOT
+             DO N=1,(LMAX+1)**2
+                DO NP=1,(LMAX+1)**2
+                   AP(M,N)=AP(M,N)+A(M,NP)*ROTYLM(N,NP)
+                ENDDO
+             ENDDO
+             ENDDO
+#ifdef debug
+               IF (IO%IU6>=0) THEN
+                  WRITE(*,'(I4,3F14.7)') NKI,kpt_latt(1:3,NKI)
+                  DO M=1,WDES%NB_TOT
+                     WRITE(*,'(4(2F14.7,2X))') (A(M,N),N=1,4)
+                  ENDDO
+                  WRITE(*,*)
+                  DO M=1,WDES%NB_TOT
+                     WRITE(*,'(4(2F14.7,2X))') (AP(M,N),N=1,4)
+                  ENDDO
+                  WRITE(*,*)
+               ENDIF
+#endif
+               ! Make the desired linear combinations
+               MI=0
+               DO M=1,WDES%NB_TOT
+                  IF (EXCLUDE_BAND(M)) CYCLE
+                  CPROJ=0
+                  DO N=1,(LMAX+1)**2
+                     CPROJ=CPROJ+AP(M,N)*HYBRID_ORBITAL(N)
+                  ENDDO
+                  MI=MI+1
+                  A_matrix(MI,NPROJ,NKI,ISP)=CPROJ
+               ENDDO
+
          ENDDO kpoints
 
          DEALLOCATE(FTMP,FR,FGTMP,FG)
 
-         IF (IO%IU0>=0) WRITE(IO%IU0,'(X,A,I3,A)') 'Projection ',NPROJ,' done.'
-!        CALL STOP_TIMING("T2",IO%IU6,'  OVL')
-!        CALL STOP_TIMING("T1",IO%IU6,'ICNTR')
+         !  IF (IO%IU0>=0) WRITE(IO%IU0,'(X,A,I3,A,I3,A)') 'Spin channel',ISPINOR,' done.'
+         !        CALL STOP_TIMING("T2",IO%IU6,'  OVL')
+         !        CALL STOP_TIMING("T1",IO%IU6,'ICNTR')
+      !ENDDO spinor
+          IF (IO%IU0>=0) WRITE(IO%IU0,'(X,A,I3,A)') '* Projection ',NPROJ,' done. [q_axis changed] *'
+        ENDIF ! quantization IF
       ENDDO sites
-      ENDDO spinor
 
       DEALLOCATE(A,AP,ROTYLM,HYBRID_ORBITAL)
 
@@ -733,13 +1158,14 @@
          IF (IO%IU0>=0) WRITE(*,*) 'MLWF_WANNIER90: ERROR: number of projections not equal to num_wann',NPROJ,num_wann
          STOP
       ENDIF
-
+      IF (IO%IU0>=0) WRITE(IO%IU0,*) "*            AMN calculated.            *"
       ENDIF ! finished computing A_matrix
 
+      IF (WRITE_AMN) THEN
       ! write A_matrix to file
       LUSE_BLOCH_PHASES=.FALSE.
       IF (NPROJ/=0) THEN
-         IF (IO%IU6>=0.AND.WRITE_MMN_AMN.AND..NOT.READ_AMN) THEN
+         IF (IO%IU6>=0.AND.WRITE_AMN.AND..NOT.READ_AMN) THEN
             IF (WDES%ISPIN==1) THEN
                OPEN(UNIT=99,FILE=seed_name//'.amn',STATUS='REPLACE')
             ELSE
@@ -781,10 +1207,13 @@
       IF (NPROJ==0.AND.(.NOT.LUSE_BLOCH_PHASES).AND.WANNIER90RUN()) THEN
 !
       ENDIF
+      ! 2020-07-04
+      ENDIF
+
 
       ! and ...
       ! we should write the eigenvalues onto seed_name.eig
-      IF (IO%IU6>=0.AND.WRITE_MMN_AMN) THEN
+      IF (IO%IU6>=0.AND.WRITE_EIG) THEN
          IF (WDES%ISPIN==1) THEN
             OPEN(UNIT=99,FILE=seed_name//'.eig',STATUS='REPLACE')
          ELSE
@@ -792,6 +1221,8 @@
          ENDIF
       ENDIF
 
+      ! actually write eig file
+      IF (WRITE_EIG) THEN
       DO NKI=1,num_kpts
          NK=KPOINT_IN_FULL_GRID(kpt_latt(:,NKI),KPOINTS_FULL)
          NK=KPOINTS_FULL%NEQUIV(NK)
@@ -800,10 +1231,13 @@
             IF (EXCLUDE_BAND(M)) CYCLE
             MI=MI+1
             eigenvalues(MI,NKI,ISP)=REAL(W%CELTOT(M,NK,ISP))
-            IF (IO%IU6>0.AND.WRITE_MMN_AMN) WRITE(99,'(2I12,F22.12)') MI,NKI,REAL(W%CELTOT(M,NK,ISP))
+            IF (IO%IU6>0.AND.WRITE_EIG) WRITE(99,'(2I12,F22.12)') MI,NKI,REAL(W%CELTOT(M,NK,ISP))
          ENDDO
       ENDDO
-      IF (IO%IU6>=0.AND.WRITE_MMN_AMN) CLOSE(99)
+      IF (IO%IU6>=0.AND.WRITE_EIG) CLOSE(99)
+      IF (IO%IU0>=0.AND.WRITE_EIG) WRITE(IO%IU0,*) "*            EIG written.               *"
+      !2020-07-04
+      ENDIF
 
       ! and last but not least we may need to write UNK files
       ! which is a bit tricky since the bands at a certain k-point
@@ -811,23 +1245,47 @@
       ! to make matters worse, WANNIER90 works with the full k-mesh
       ! whereas VASP uses the symmetry reduced one.
  100  FORMAT('UNK',I5.5,'.',I1)
+ 101  FORMAT('UNK',I5.5,'.NC')
       IF (WRITE_UNK) THEN
          DO NKI=1,num_kpts
             IF (IO%IU6>=0) THEN
+               IF (W%WDES%NRSPINORS/=1) THEN
+                 WRITE(UNKFILE,101) NKI
+               ELSE
                WRITE(UNKFILE,100) NKI,ISP
+               ENDIF
+               IF (UNK_FMTED) THEN
+                 OPEN(UNIT=99,FILE=UNKFILE,FORM='FORMATTED',STATUS='REPLACE')
+                 IF (REDUCE_UNK) THEN
+                   WRITE(99,*) (W%WDES%GRID%NGX+1)/2,(W%WDES%GRID%NGY+1)/2,(W%WDES%GRID%NGZ+1)/2,NKI,num_bands
+                 ELSE 
+                   WRITE(99,*) W%WDES%GRID%NGX,W%WDES%GRID%NGY,W%WDES%GRID%NGZ,NKI,num_bands
+                 ENDIF
+               ELSE
                OPEN(UNIT=99,FILE=UNKFILE,FORM='UNFORMATTED',STATUS='REPLACE')
+                 IF (REDUCE_UNK) THEN
+                   WRITE(99) (W%WDES%GRID%NGX+1)/2,(W%WDES%GRID%NGY+1)/2,(W%WDES%GRID%NGZ+1)/2,NKI,num_bands
+                 ELSE
                WRITE(99) W%WDES%GRID%NGX,W%WDES%GRID%NGY,W%WDES%GRID%NGZ,NKI,num_bands
             ENDIF
-            CALL WRITE_WAVE_FUNCTIONS(W,kpt_latt(:,NKI),ISP,EXCLUDE_BAND,P,LATT_CUR,99)   
+               ENDIF
+            ENDIF
+            CALL WRITE_WAVE_FUNCTIONS(W,kpt_latt(:,NKI),ISP,EXCLUDE_BAND,P,LATT_CUR,UNK_FMTED,REDUCE_UNK,99)
             IF (IO%IU6>=0) CLOSE(99)
          ENDDO
+      IF (IO%IU0>=0) WRITE(IO%IU0,*) "*            UNK written.               *"
       ENDIF
-
-      ENDDO spin
+      IF (IO%IU0>=0) WRITE(IO%IU0,*) "*---------------------------------------*"
    
       ! Write information on seed_name.win
       IF (IO%IU6>=0) THEN
+         IF ((.NOT. spinors) .AND. (WDES%ISPIN==2)) THEN
+            OPEN(UNIT=99,FILE=seed_name//'.'//SP(ISP)//'.win',STATUS='OLD')
+!         ELSEIF ((.NOT. spinors) .AND. (WDES%RSPIN==1)) THEN
+!            OPEN(UNIT=99,FILE=seed_name//'.win',STATUS='OLD')
+         ELSE
          OPEN(UNIT=99,FILE=seed_name//'.win',STATUS='OLD')
+         ENDIF
          
          IF (spinors) THEN
             CALL OCCURS_IN_FILE(99,'spinors',N)
@@ -919,9 +1377,9 @@
               &                 U_matrix(:,:,:,1),U_matrix_opt(:,:,:,1),lwindow(:,:,1), &
               &                 wann_centres(:,:,1),wann_spreads(:,1),spread(:,1))
            ELSE
-               DO ISP=1,WDES%ISPIN
+               !DO ISP=1,WDES%ISPIN
                ! copy wannier90.win to wannier90.(up/dn).win
-               CALL COPYFILE(seed_name//'.win',seed_name//'.'//SP(ISP)//'.win')
+               !CALL COPYFILE(seed_name//'.win',seed_name//'.'//SP(ISP)//'.win')
 
                ! run wannier90 for spin component ISP
                CALL wannier_run(seed_name//'.'//SP(ISP), &
@@ -932,7 +1390,7 @@
               &                 U_matrix(:,:,:,ISP),U_matrix_opt(:,:,:,ISP),lwindow(:,:,ISP), &
               &                 wann_centres(:,:,ISP),wann_spreads(:,ISP),spread(:,ISP))
 
-               ENDDO
+               !ENDDO
             ENDIF
          ENDIF
 #endif
@@ -955,13 +1413,21 @@
          ENDIF 
       ENDIF
 
-      DEALLOCATE(atom_symbols,atoms_cart)
       DEALLOCATE(nnlist,nncell)
       DEALLOCATE(proj_site,proj_l,proj_m,proj_radial,proj_z,proj_x,proj_zona,exclude_bands)
+#ifdef VASP2WANNIER90v2
+! CCX_2019-05-05: deall
+      DEALLOCATE(proj_s,proj_s_qaxis)
+#endif
+
+      DEALLOCATE(atom_symbols,atoms_cart)
       DEALLOCATE(EXCLUDE_BAND)
       DEALLOCATE(M_matrix,A_matrix,eigenvalues)
       DEALLOCATE(S)
 
+      ! 2020-06-27 CCX: I moved this here so we can have total control of collinear spin channels.
+      ENDDO spin
+
       IF (ASSOCIATED(R%R)) THEN
          DEALLOCATE(R%R); NULLIFY(R%R)
       ENDIF
@@ -1880,6 +2346,186 @@
       RETURN
       END SUBROUTINE CALC_OVERLAP_GN
 
+!******************** SUBROUTINE CALC_OVERLAP_GN_ALL *******************
+! 2020-06-15 CCX: added to use CONSTRUCT_FUNCTION_RYlm_ALL
+!                 for spin_quantization calculations
+!***********************************************************************
+      SUBROUTINE CALC_OVERLAP_GN_ALL( &
+     &   L,FG,POS,W,K,ISP,SPIN_FAC,P,CQIJ,LATT_CUR,T_INFO,S &
+     &)
+      USE pead
+      USE poscar
+      USE pseudo
+      USE lattice
+      USE full_kpoints
+      USE wave_high
+      USE nonl_high
+      IMPLICIT NONE
+      TYPE(wavespin) W
+      TYPE(potcar) P(:)
+      TYPE(latt) LATT_CUR
+      TYPE(type_info) T_INFO
+      INTEGER L
+      INTEGER ISP
+      ! 2020-06-15 CCX: read in SPIN_FAC
+      COMPLEX(q) SPIN_FAC(2)
+      REAL(q) K(3)
+      REAL(q) FG(:,:,:)
+      REAL(q) POS(3)
+      OVERLAP CQIJ(:,:,:,:)
+      GDEF S(W%WDES%NB_TOT,(L+1)**2)
+      ! local variables
+      TYPE(wavespin) WP
+      TYPE(wavefuna) WK,WRYlm
+      TYPE(wavedes1), TARGET :: WDESK
+      TYPE(nonl_struct) NONL_S
+
+      TYPE(rotation_handle), POINTER :: ROT_HANDLE
+
+      GDEF C
+      REAL(q) WSCAL
+      INTEGER NK,NB,N,NYLM
+
+      WP=W
+      WP%WDES=>WDES_FULL_PEAD
+
+      CALL CHECK_FULL_KPOINTS
+
+      NULLIFY(ROT_HANDLE)
+
+      NYLM=(L+1)**2
+
+      ! search for kpoint k in BZ
+      NK=KPOINT_IN_FULL_GRID(K,KPOINTS_FULL)
+      CALL SETWDES(WP%WDES,WDESK,NK)
+      IF (NK==KPOINTS_FULL%NEQUIV(NK)) THEN
+         ! k is a kpoint in the IBZ
+         WK=ELEMENTS(WP,WDESK,ISP)
+      ELSE
+         ! k is not a kpoint in the IBZ
+         CALL NEWWAVA(WK,WDESK,WDESK%NBANDS)
+         CALL PEAD_WA_ROTATE(WP,P,LATT_CUR,ISP,WK)
+      ENDIF
+
+      CALL NONL_ALLOC(NONL_S,T_INFO,P,WP%WDES,.FALSE.)
+      CALL SPHER(WP%WDES%GRID,NONL_S,P,WP%WDES,LATT_CUR,1,NK)
+      CALL PHASE(WP%WDES,NONL_S,NK)
+
+      CALL NEWWAVA(WRYlm,WDESK,NYLM)
+      WRYlm%CW=0
+      !WRITE(*,*) WRYlm%WDES1%LOVERL,   WRYlm%WDES1%NPROD
+      ! 2020-06-15 CCX: use CONSTRUCT_FUNCTION_RYlm_ALL.
+      CALL CONSTRUCT_FUNCTION_RYlm_ALL(L,FG,LATT_CUR,POS,NONL_S,SPIN_FAC,WRYlm)
+      ! and normalize the functions WRYlm
+      DO N=1,NYLM
+         CALL CNORMN(ELEMENT(WRYlm,N),CQIJ,1,WSCAL)
+      ENDDO
+
+      ! calculate overlap between Wk and WRYlm: < w_{m,k1} | S | RYlm >
+      S=0
+      DO NB=1,WP%WDES%NBANDS
+         DO N=1,NYLM
+            C=W1_DOT(ELEMENT(WK,NB),ELEMENT(WRYlm,N),CQIJ)
+            S(WDESK%NB_LOW+WDESK%NB_PAR*(NB-1),N)=C
+!           WRITE(*,*) WDESK%NB_LOW+WDESK%NB_PAR*(NB-1),N,C
+         ENDDO
+      ENDDO
+
+      CALLMPI( M_sum_g(WDESK%COMM_INTER,S(1,1),WDESK%NB_TOT*NYLM) )
+
+      ! some deallocation to be done
+      CALL DEALLOCATE_ROT_HANDLE(ROT_HANDLE)
+
+      CALL DELWAVA(WRYlm)
+      IF (NK/=KPOINTS_FULL%NEQUIV(NK)) CALL DELWAVA(WK)
+
+      CALL NONL_DEALLOC(NONL_S)
+
+      RETURN
+    END SUBROUTINE CALC_OVERLAP_GN_ALL
+
+!******************** SUBROUTINE CALC_SPN_EXP ***********************
+! 2020-06-15 CCX: a modified version of CALC_OVERLAP_GN
+!                 calculates expectation value of the
+!                 Pauli Matrix. Uses W1_SPN_DOT in wave_high.F
+! Note: This routine only works in serial.
+!***********************************************************************
+      SUBROUTINE CALC_SPN_EXP( &
+     &   W,K,P,CQIJ,LATT_CUR,T_INFO,S &
+     &)
+      USE pead
+      USE poscar
+      USE pseudo
+      USE lattice
+      USE full_kpoints
+      USE wave_high
+      USE nonl_high
+      IMPLICIT NONE
+      TYPE(wavespin) W
+      TYPE(potcar) P(:)
+      TYPE(latt) LATT_CUR
+      TYPE(type_info) T_INFO
+      ! INTEGER L
+      ! INTEGER ISP
+      ! INTEGER ISPINOR
+      REAL(q) K(3)
+      ! REAL(q) FG(:,:,:)
+      ! REAL(q) POS(3)
+      OVERLAP CQIJ(:,:,:,:)
+      GDEF S(W%WDES%NB_TOT,W%WDES%NB_TOT,3)
+      ! local variables
+      TYPE(wavespin) WP
+      TYPE(wavefuna) WK
+      TYPE(wavedes1), TARGET :: WDESK
+
+      TYPE(rotation_handle), POINTER :: ROT_HANDLE
+
+      GDEF C(3)
+      REAL(q) WSCAL
+      INTEGER NK,NB,N,NYLM
+
+      WP=W
+      WP%WDES=>WDES_FULL_PEAD
+
+      CALL CHECK_FULL_KPOINTS
+
+      NULLIFY(ROT_HANDLE)
+
+      ! search for kpoint k in BZ
+      NK=KPOINT_IN_FULL_GRID(K,KPOINTS_FULL)
+      CALL SETWDES(WP%WDES,WDESK,NK)
+      IF (NK==KPOINTS_FULL%NEQUIV(NK)) THEN
+         ! k is a kpoint in the IBZ
+         WK=ELEMENTS(WP,WDESK,1)
+      ELSE
+         ! k is not a kpoint in the IBZ
+         CALL NEWWAVA(WK,WDESK,WDESK%NBANDS)
+         CALL PEAD_WA_ROTATE(WP,P,LATT_CUR,1,WK)
+      ENDIF
+      ! calculate overlap between W1 and W2: < w_{m,k1} | sigma | w_{n,k1} >
+      ! everything is in W1_SPNDOT
+      S=0
+      DO NB=1,WP%WDES%NBANDS
+         DO N=1,WP%WDES%NBANDS
+            C=W1_SPN_DOT(ELEMENT(WK,NB),ELEMENT(WK,N),CQIJ)
+!            WRITE(*,*) N,NB
+            S(WDESK%NB_LOW+WDESK%NB_PAR*(NB-1),WDESK%NB_LOW+WDESK%NB_PAR*(N-1),1)=C(1)
+            S(WDESK%NB_LOW+WDESK%NB_PAR*(NB-1),WDESK%NB_LOW+WDESK%NB_PAR*(N-1),2)=C(2)
+            S(WDESK%NB_LOW+WDESK%NB_PAR*(NB-1),WDESK%NB_LOW+WDESK%NB_PAR*(N-1),3)=C(3)
+
+!           WRITE(*,*) WDESK%NB_LOW+WDESK%NB_PAR*(NB-1),WDESK%NB_LOW+WDESK%NB_PAR*(N-1)
+         ENDDO
+      ENDDO
+      !CALLMPI( M_sum_g(WDESK%COMM_INTER,S(1,1,1),WDESK%NB_TOT*WDESK%NB_TOT*3) )
+      ! some deallocation to be done
+      CALL DEALLOCATE_ROT_HANDLE(ROT_HANDLE)
+      ! CALL DELWAVA(WRYlm)
+      IF (NK/=KPOINTS_FULL%NEQUIV(NK)) CALL DELWAVA(WK)
+      ! CALL NONL_DEALLOC(NONL_S)
+
+      RETURN
+      END SUBROUTINE CALC_SPN_EXP
+
 
 !******************** SUBROUTINE CONSTRUCT_FUNCTION_RYlm ***************
 !      
@@ -1989,11 +2635,129 @@
       RETURN
       END SUBROUTINE CONSTRUCT_FUNCTION_RYlm
 
+!******************** SUBROUTINE CONSTRUCT_FUNCTION_RYlm_ALL ***********
+! 2020-06-15 CCX: added to construct full RYlm with 2 spinors.
+!                 the PAW projector are constructed with the new
+!                 spinor wavefunctions.
+!                 Also, see W1_DOT in wave_high.F
+!***********************************************************************
+      SUBROUTINE CONSTRUCT_FUNCTION_RYlm_ALL( &
+     &   LMAX,F,LATT_CUR,POS,NONL_S,SPIN_FAC,WRYLM &
+     &)
+      USE ini
+      USE asa
+      USE pead
+      USE lattice
+      USE constant
+      USE wave_high
+      USE nonl_high
+      IMPLICIT NONE
+      TYPE(latt) LATT_CUR
+      TYPE(wavefuna) WRYLM
+      TYPE (nonl_struct) NONL_S
+      REAL(q) F(:,:,:)
+      REAL(q) POS(3)
+      INTEGER LMAX
+      ! 2020-06-15 CCX: read in SPIN_FAC
+      COMPLEX(q) SPIN_FAC(2)
+      ! local variables
+      ! 2020-06-15 CCX: ISPINOR is now local variable
+      INTEGER ISPINOR
+      TYPE(wavefun1) W1
+      INTEGER N1,N2,N3,IND,NPL,LMMAX,L,M,LM,IG
+      REAL(q) G1,G2,G3,GKX,GKY,GKZ,FACTM,FAKT,FDER
+      REAL(q), ALLOCATABLE :: XS(:),YS(:),ZS(:),YLM(:,:)
+      REAL(q), ALLOCATABLE :: G(:),FG(:)
+      COMPLEX(q) CSET,CGDR
+      COMPLEX(q), ALLOCATABLE :: CFAKTX(:)
+
+      LMMAX=(LMAX+1)**2
+
+      NPL=WRYLM%WDES1%NGVECTOR
+
+      ! 2020-06-15 CCX: deleted this part, usually not usefull.
+      !IF (ISPINOR/=1.AND.(.NOT.WRYLM%WDES1%LNONCOLLINEAR)) THEN
+      !   WRITE(*,*) 'CONSTRUCT_FUNCTION_RYlm: ERROR: ISPINOR=',ISPINOR,' but LNONCOLLINEAR=.FALSE.'
+      !   STOP
+      !ENDIF
+
+      ALLOCATE(G(NPL),FG(NPL))
+      ALLOCATE(XS(NPL),YS(NPL),ZS(NPL),CFAKTX(NPL))
+
+      ! loop over all G-vectors in the basis at this k-point
+      DO IND=1,WRYLM%WDES1%NGVECTOR
+         N1=MOD(WRYLM%WDES1%IGX(IND)+WRYLM%WDES1%GRID%NGX,WRYLM%WDES1%GRID%NGX)+1
+         N2=MOD(WRYLM%WDES1%IGY(IND)+WRYLM%WDES1%GRID%NGY,WRYLM%WDES1%GRID%NGY)+1
+         N3=MOD(WRYLM%WDES1%IGZ(IND)+WRYLM%WDES1%GRID%NGZ,WRYLM%WDES1%GRID%NGZ)+1
+
+         G1=(WRYLM%WDES1%GRID%LPCTX(N1)+WRYLM%WDES1%VKPT(1))
+         G2=(WRYLM%WDES1%GRID%LPCTY(N2)+WRYLM%WDES1%VKPT(2))
+         G3=(WRYLM%WDES1%GRID%LPCTZ(N3)+WRYLM%WDES1%VKPT(3))
+
+         FACTM=1._q
+         IF (WRYLM%WDES1%LGAMMA .AND. (N1/=1 .OR. N2/=1 .OR. N3/=1)) FACTM=SQRT(2._q)
+
+         GKX=(G1*LATT_CUR%B(1,1)+G2*LATT_CUR%B(1,2)+G3*LATT_CUR%B(1,3))*TPI
+         GKY=(G1*LATT_CUR%B(2,1)+G2*LATT_CUR%B(2,2)+G3*LATT_CUR%B(2,3))*TPI
+         GKZ=(G1*LATT_CUR%B(3,1)+G2*LATT_CUR%B(3,2)+G3*LATT_CUR%B(3,3))*TPI
+
+         G(IND)=MAX(SQRT(GKX*GKX+GKY*GKY+GKZ*GKZ),1E-10_q)
+
+         ! phase factor e^{-i(k+G)R} where R is the origin
+         ! of the localized function
+         CGDR=CITPI*(G1*POS(1)+G2*POS(2)+G3*POS(3))
+!        CGDR=0
+         CFAKTX(IND)=FACTM*EXP(-CGDR)
+
+         XS(IND)  =GKX/G(IND)
+         YS(IND)  =GKY/G(IND)
+         ZS(IND)  =GKZ/G(IND)
+      ENDDO
+
+      ALLOCATE(YLM(NPL,LMMAX))
+      ! get me all the Y_lm up to and including l=LMAX
+      CALL SETYLM(LMAX,NPL,YLM,XS,YS,ZS)
+
+      ! Setup the plane wave part of the desired function
+      FAKT= 1/SQRT(LATT_CUR%OMEGA)
+      CSET=CMPLX(0._q,-1._q,q)
+
+!     WRYLM%CW=0
+      LM=1
+      DO L=0,LMAX
+         ! get me the Bessel transform of the radial function
+         DO IG=1,SIZE(G)
+            CALL SPLVAL(G(IG),FG(IG),FDER,F(:,:,L+1),SIZE(F,1),SIZE(F,1))
+         ENDDO
+         DO IND=1,NPL
+            DO M=1,2*L+1
+               ! 2020-06-15 CCX: added ISPINOR loop to construct full spinor WF
+               !                 each part dotted with SPIN_FAC for quant_axis.
+               DO ISPINOR=1,2
+                 WRYLM%CW(IND+(ISPINOR-1)*NPL,LM+M-1)= &
+                &   SPIN_FAC(ISPINOR)*FAKT*(CSET**L)*CFAKTX(IND)*FG(IND)*YLM(IND,LM+M-1)
+               ENDDO
+            ENDDO
+         ENDDO
+         LM=LM+2*L+1
+      ENDDO
+
+      ! and get the projections of RYlm onto the PAW projectors
+      WRYLM%CPROJ=0
+      DO LM=1,LMMAX
+         W1=ELEMENT(WRYLM,LM)
+         CALL PROJ1(NONL_S,WRYLM%WDES1,W1)
+      ENDDO
+
+      DEALLOCATE(G,FG,XS,YS,ZS,CFAKTX,YLM)
+
+      RETURN
+      END SUBROUTINE CONSTRUCT_FUNCTION_RYlm_ALL
 
 !******************** SUBROUTINE WRITE_WAVE_FUNCTIONS ******************
 !      
 !***********************************************************************
-      SUBROUTINE WRITE_WAVE_FUNCTIONS(W,K,ISP,EXCLUDE_BAND,P,LATT_CUR,IU)
+      SUBROUTINE WRITE_WAVE_FUNCTIONS(W,K,ISP,EXCLUDE_BAND,P,LATT_CUR,UNK_FMTED,REDUCE_UNK,IU)
       USE pead
       USE pseudo
       USE lattice
@@ -2006,6 +2770,8 @@
       INTEGER ISP,IU
       REAL(q) K(3)
       LOGICAL EXCLUDE_BAND(W%WDES%NB_TOT) 
+      LOGICAL UNK_FMTED
+      LOGICAL REDUCE_UNK
      ! local variables
       TYPE(wavespin) WP
       TYPE(wavefuna) WK
@@ -2014,11 +2780,14 @@
 
       TYPE(rotation_handle), POINTER :: ROT_HANDLE
 
-      INTEGER NK,NB,ISTRIP
+      INTEGER NK,NB,ISTRIP,ISPINOR
+      INTEGER IX,IY,IZ,POS_RED
       INTEGER NX,NY,NZ,NC,NGX,NGY,NGZ,IND,I,NWRITTEN
       INTEGER, PARAMETER :: NSTRIP=1
 
       GDEF, ALLOCATABLE :: WVFN(:)
+      GDEF, ALLOCATABLE :: WVFN_RED(:)
+
 
       WP=W
       WP%WDES=>WDES_FULL_PEAD
@@ -2047,7 +2816,14 @@
          CALL NEWWAV(WCOLLECT(NB),WDESK,.TRUE.)
       ENDDO
 
+      ! 2020-06-22 CCX: added for non-collinear WF plot
+      IF (WP%WDES%NRSPINORS/=1) THEN
+        ALLOCATE(WVFN(NGX*NGY*NGZ*2))
+        IF (REDUCE_UNK) ALLOCATE(WVFN_RED((NGX+1)/2*(NGY+1)/2*(NGZ+1)/2*2))
+      ELSE
       ALLOCATE(WVFN(NGX*NGY*NGZ))
+        IF (REDUCE_UNK) ALLOCATE(WVFN_RED((NGX+1)/2*(NGY+1)/2*(NGZ+1)/2))
+      ENDIF
 
       NWRITTEN=0 
 
@@ -2073,7 +2849,14 @@
 #ifdef gammareal
                      WVFN(IND)=REAL(WCOLLECT(ISTRIP)%CR(NX+(NC-1)*WP%WDES%GRID%RL%NROW),KIND=q)
 #else
+                     ! 2020-06-22 CCX: added for non-collinear WF plot
+                     IF (WP%WDES%NRSPINORS/=1) THEN
+                       DO ISPINOR=0,WP%WDES%NRSPINORS-1
+                         WVFN(IND+ISPINOR*(NGX*NGY*NGZ))=WCOLLECT(ISTRIP)%CR(NX+(NC-1)*WP%WDES%GRID%RL%NROW+ISPINOR*(NGX*NGY*NGZ))
+                       ENDDO
+                     ELSE
                      WVFN(IND)=WCOLLECT(ISTRIP)%CR(NX+(NC-1)*WP%WDES%GRID%RL%NROW)
+                     ENDIF
 #endif
                   ENDDO
                ENDDO
@@ -2086,7 +2869,14 @@
 #ifdef gammareal
                      WVFN(IND)=REAL(WCOLLECT(ISTRIP)%CR(NZ+(NC-1)*WP%WDES%GRID%RL%NROW),KIND=q)
 #else
+                     ! 2020-06-22 CCX: added for non-collinear WF plot
+                     IF (WP%WDES%NRSPINORS/=1) THEN
+                       DO ISPINOR=0,W%WDES%NRSPINORS-1
+                         WVFN(IND+ISPINOR*(NGX*NGY*NGZ))=WCOLLECT(ISTRIP)%CR(NZ+(NC-1)*WP%WDES%GRID%RL%NROW+ISPINOR*(NGX*NGY*NGZ))
+                       ENDDO
+                     ELSE
                      WVFN(IND)=WCOLLECT(ISTRIP)%CR(NZ+(NC-1)*WP%WDES%GRID%RL%NROW)
+                     ENDIF
 #endif
                   ENDDO
                ENDDO
@@ -2094,13 +2884,84 @@
                WRITE(*,'(A)') 'WRITE_WAVE_FUNCTIONS: ERROR: W1 grid not set'
                STOP
             ENDIF
+
+            ! 2020-06-22 CCX: added for non-collinear WF plot
+            IF (WP%WDES%NRSPINORS/=1) THEN
+              CALLMPI(M_sum_g(WP%WDES%COMM_INB,WVFN(1),NGX*NGY*NGZ*2))
+            ELSE
             CALLMPI(M_sum_g(WP%WDES%COMM_INB,WVFN(1),NGX*NGY*NGZ))
+            ENDIF
 
             ! write WVFN to file
 #ifdef MPI
             IF (WP%WDES%COMM%NODE_ME==WP%WDES%COMM%IONODE) THEN 
 #endif
+
+            ! 2020-07-04 CCX: reduce UNK matrix, cannot just write it because Do loop will change binary format
+            IF (REDUCE_UNK) THEN
+            IF (WP%WDES%NRSPINORS/=1) THEN
+              DO ISPINOR=0,1
+                POS_RED=0
+              DO IZ=1,NGZ,2
+              DO IY=1,NGY,2
+              DO IX=1,NGX,2
+                POS_RED = POS_RED+1
+                WVFN_RED(POS_RED+((NGX+1)/2)*((NGY+1)/2)*((NGZ+1)/2)*ISPINOR) = (WVFN(IX+(IY-1)*NGX+(IZ-1)*NGX*NGY+NGX*NGY*NGZ*ISPINOR))
+              ENDDO
+              ENDDO
+              ENDDO
+              ENDDO
+            ELSE
+              POS_RED=0
+              DO IZ=1,NGZ,2
+              DO IY=1,NGY,2
+              DO IX=1,NGX,2
+                POS_RED = POS_RED+1
+                WVFN_RED(POS_RED) = (WVFN(IX+(IY-1)*NGX+(IZ-1)*NGX*NGY))
+              ENDDO
+              ENDDO
+              ENDDO
+            ENDIF
+            ENDIF
+
+               ! 2020-06-22 CCX: added for non-collinear WF plot
+               IF (WP%WDES%NRSPINORS/=1) THEN
+                 IF (UNK_FMTED) THEN
+                   DO ISPINOR=0,1
+                     ! 2020-07-04 CCX: reduce wfc
+                     IF (REDUCE_UNK) THEN
+                         WRITE(IU,'(2ES20.10)') (WVFN_RED(I),I=1+((NGX+1)/2)*((NGY+1)/2)*((NGZ+1)/2)*ISPINOR,((NGX+1)/2)*((NGY+1)/2)*((NGZ+1)/2)+((NGX+1)/2)*((NGY+1)/2)*((NGZ+1)/2)*ISPINOR)
+                     ELSE
+                       WRITE(IU,'(2ES20.10)') (WVFN(I),I=1+NGX*NGY*NGZ*ISPINOR,NGX*NGY*NGZ+NGX*NGY*NGZ*ISPINOR)
+                     ENDIF
+                   ENDDO
+                 ELSEIF (.NOT. UNK_FMTED) THEN
+                   DO ISPINOR=0,1
+                     ! 2020-07-04 CCX: reduce wfc
+                     IF (REDUCE_UNK) THEN
+                       WRITE(IU) (WVFN_RED(I),I=1+((NGX+1)/2)*((NGY+1)/2)*((NGZ+1)/2)*ISPINOR,((NGX+1)/2)*((NGY+1)/2)*((NGZ+1)/2)+((NGX+1)/2)*((NGY+1)/2)*((NGZ+1)/2)*ISPINOR)
+                     ELSE
+                       WRITE(IU) (WVFN(I),I=1+NGX*NGY*NGZ*ISPINOR,NGX*NGY*NGZ+NGX*NGY*NGZ*ISPINOR)
+                     ENDIF
+                   ENDDO
+                 ENDIF
+               ELSEIF (WP%WDES%NRSPINORS==1) THEN
+                 IF (UNK_FMTED) THEN
+                   ! 2020-07-04 CCX: reduce wfc
+                   IF (REDUCE_UNK) THEN
+                     WRITE(IU,'(2ES20.10)') (WVFN_RED(I),I=1,((NGX+1)/2)*((NGY+1)/2)*((NGZ+1)/2))
+                   ELSE
+                     WRITE(IU,'(2ES20.10)') (WVFN(I),I=1,NGX*NGY*NGZ)
+                   ENDIF
+                 ELSEIF (.NOT. UNK_FMTED) THEN
+                   ! 2020-07-04 CCX: reduce wfc
+                   IF (REDUCE_UNK) THEN
+                     WRITE(IU) (WVFN_RED(I),I=1,((NGX+1)/2)*((NGY+1)/2)*((NGZ+1)/2))
+                   ELSE
                WRITE(IU) (WVFN(I),I=1,NGX*NGY*NGZ)
+                   ENDIF
+                 ENDIF
+               ENDIF
 #ifdef MPI
             ENDIF
 #endif
@@ -2116,11 +2977,12 @@
       ENDDO
       DEALLOCATE(WSTRIP,WCOLLECT)
       DEALLOCATE(WVFN)
+      ! 2020-07-04 deallocate reduced wavefunctions
+      IF (REDUCE_UNK) DEALLOCATE(WVFN_RED)
 
       RETURN
       END SUBROUTINE WRITE_WAVE_FUNCTIONS
 
-
 !******************** SUBROUTINE OCCURS_IN_FILE ************************
 !      
 !***********************************************************************
@@ -2632,4 +3494,3 @@
 1001     FORMAT(2I6,2F26.16)
       ENDSUBROUTINE WRITE_WANPROJ_FILE
       END MODULE mlwf
-
diff -bruN src/wave_high.F ../vasp.5.4.4_mod/src/wave_high.F
--- src/wave_high.F	2017-04-20 10:04:00.000000000 +0100
+++ ../vasp.5.4.4_mod/src/wave_high.F	2020-07-05 14:28:52.839498219 +0100
@@ -53,6 +53,18 @@
      END SUBROUTINE ECCP_NL
   END INTERFACE
 
+! 2020-06-25 CCX: Addde for spn calculation
+  INTERFACE
+     SUBROUTINE ECCP_NL_SPN(LMDIM,LMMAXC,PAULI,CDIJ,CPROJ1,CPROJ2,CNL)
+       USE prec
+       COMPLEX(q):: PAULI
+       GDEF      CNL
+       INTEGER LMDIM, LMMAXC
+       OVERLAP CDIJ
+       GDEF CPROJ1,CPROJ2
+     END SUBROUTINE ECCP_NL_SPN
+  END INTERFACE
+
   INTERFACE
      SUBROUTINE OVERL(WDES1, LOVERL, LMDIM, CQIJ, CPROF, CRESUL)
        USE wave
@@ -634,6 +646,116 @@
       
   END FUNCTION W1_DOT
 
+!***********************************************************************
+!
+! 2020-06-25 CCX: added for spn calculation
+! calculate the dot product between two wavefunctions
+!  C=   <W1| Sigma| W2>
+! this is a substitue for the routine CINDPROD but mind
+! the W1 and W2 are interchanged
+!
+!***********************************************************************
+FUNCTION W1_SPN_DOT(W1, W2, CQIJ) RESULT (C)
+  IMPLICIT NONE
+  TYPE (wavefun1)    W1, W2
+  GDEF :: cdum1,cdum2
+!  GDEF :: cdum1_aug,cdum2_aug,sigma_x_aug,sigma_y_aug,sigma_z_aug
+  ! INTEGER NC                      ! stride of C
+  OVERLAP :: CQIJ(:,:,:,:) ! optional overlap operator
+!  OVERLAP, ALLOCATABLE :: SCQIJ_x(:,:,:,:),SCQIJ_y(:,:,:,:),SCQIJ_z(:,:,:,:) ! optional overlap operator * pauli matrix
+  COMPLEX(q), EXTERNAL :: ZDOTC
+  REAL(q), EXTERNAL ::  DDOT
+! local
+  COMPLEX(q) :: PAULI
+  GDEF :: CNLx,CNLy,CNLz,C(3)
+  INTEGER :: LMDIM, NPRO, NPRO_, ISPINOR, ISPINOR_, LMMAXC, NT, NI, NIS
+
+!  ALLOCATE(SCQIJ_x(1,1,W1%WDES1%NTYP,4),SCQIJ_y(1,1,W1%WDES1%NTYP,4),SCQIJ_z(1,1,W1%WDES1%NTYP,4))
+
+  ! DO ISPINOR=0,W1%WDES1%NRSPINORS-1
+  !   DO ISPINOR_=0,W1%WDES1%NRSPINORS-1
+  cdum1=ZDOTC( W1%WDES1%NPL/2,W1%CW(1),1,W2%CW(1+W1%WDES1%NPL/2*(W1%WDES1%NRSPINORS-1)),1)
+  cdum2=ZDOTC( W1%WDES1%NPL/2,W1%CW(1+W1%WDES1%NPL/2*(W1%WDES1%NRSPINORS-1)),1,W2%CW(1),1)
+  C(1)=cdum1+cdum2
+  C(2)=cmplx(0._q,1._q,q)*(cdum2-cdum1)
+  C(3)=zdotc(W1%WDES1%NPL/2,W1%CW(1),1,W2%CW(1),1)&
+         -zdotc(W1%WDES1%NPL/2,W1%CW(1+W1%WDES1%NPL/2*(W1%WDES1%NRSPINORS-1)),1,W2%CW(1+W1%WDES1%NPL/2*(W1%WDES1%NRSPINORS-1)),1)
+
+  ! getme SCQIJ
+!  WRITE(*,*) "number of type", W1%WDES1%NTYP
+!  WRITE(*,*) "CQIJ: ",CQIJ(1,1,1,:)
+!  DO NT=1,W1%WDES1%NTYP
+!    SCQIJ_x(1,1,NI,1+0+2*0)=CQIJ(1,1,NI,1+1+2*0)
+!    SCQIJ_x(1,1,NI,1+0+2*1)=CQIJ(1,1,NI,1+1+2*1)
+!    SCQIJ_x(1,1,NI,1+1+2*0)=CQIJ(1,1,NI,1+0+2*0)
+!    SCQIJ_x(1,1,NI,1+1+2*1)=CQIJ(1,1,NI,1+0+2*1)
+!
+!    SCQIJ_y(1,1,NI,1+0+2*0)=cmplx(0._q,-1._q,q)*CQIJ(1,1,NI,1+1+2*0)
+!    SCQIJ_y(1,1,NI,1+0+2*1)=cmplx(0._q,-1._q,q)*CQIJ(1,1,NI,1+1+2*1)
+!    SCQIJ_y(1,1,NI,1+1+2*0)=cmplx(0._q,1._q,q)*CQIJ(1,1,NI,1+0+2*0)
+!    SCQIJ_y(1,1,NI,1+1+2*1)=cmplx(0._q,1._q,q)*CQIJ(1,1,NI,1+0+2*1)
+!
+!    SCQIJ_z(1,1,NI,1+0+2*0)=CQIJ(1,1,NI,1+0+2*0)
+!    SCQIJ_z(1,1,NI,1+0+2*1)=CQIJ(1,1,NI,1+0+2*1)
+!    SCQIJ_z(1,1,NI,1+1+2*0)=-1._q*CQIJ(1,1,NI,1+1+2*0)
+!    SCQIJ_z(1,1,NI,1+1+2*1)=-1._q*CQIJ(1,1,NI,1+1+2*1)
+!  ENDDO
+
+!  WRITE(*,*) "SCQIJ_x: ",SCQIJ_x(1,1,1,:)
+!  WRITE(*,*) "SCQIJ_y: ",SCQIJ_y(1,1,1,:)
+!  WRITE(*,*) "SCQIJ_z: ",SCQIJ_z(1,1,1,:)
+
+  IF ( W1%WDES1%LOVERL .AND.  W1%WDES1%NPROD>0 ) THEN
+     CNLx=0
+     CNLy=0
+     CNLz=0
+
+     LMDIM = SIZE(CQIJ,1)
+
+     spinor: DO ISPINOR=0,W1%WDES1%NRSPINORS-1
+     DO ISPINOR_=0,W1%WDES1%NRSPINORS-1
+
+        NPRO =ISPINOR *(W1%WDES1%NPRO/2)
+        NPRO_=ISPINOR_*(W1%WDES1%NPRO/2)
+        NIS =1
+        DO NT=1,W1%WDES1%NTYP
+           LMMAXC=W1%WDES1%LMMAX(NT)
+           IF (LMMAXC/=0) THEN
+              DO NI=NIS,W1%WDES1%NITYP(NT)+NIS-1
+                 IF (ISPINOR==0 .AND. ISPINOR_==0 ) THEN
+                    CALL ECCP_NL_SPN(LMDIM,LMMAXC,CMPLX(1._q,0._q,q),CQIJ(1,1,NI,1+0+2*1),W2%CPROJ(NPRO_+1),W1%CPROJ(NPRO+1),CNLx)
+                    CALL ECCP_NL_SPN(LMDIM,LMMAXC,CMPLX(0._q,-1._q,q),CQIJ(1,1,NI,1+0+2*1),W2%CPROJ(NPRO_+1),W1%CPROJ(NPRO+1),CNLy)
+                    CALL ECCP_NL_SPN(LMDIM,LMMAXC,CMPLX(1._q,0._q,q),CQIJ(1,1,NI,1+0+2*0),W2%CPROJ(NPRO_+1),W1%CPROJ(NPRO+1),CNLz)
+                 ELSEIF (ISPINOR==0 .AND. ISPINOR_==1 ) THEN
+                    CALL ECCP_NL_SPN(LMDIM,LMMAXC,CMPLX(1._q,0._q,q),CQIJ(1,1,NI,1+1+2*1),W2%CPROJ(NPRO_+1),W1%CPROJ(NPRO+1),CNLx)
+                    CALL ECCP_NL_SPN(LMDIM,LMMAXC,CMPLX(0._q,-1._q,q),CQIJ(1,1,NI,1+1+2*1),W2%CPROJ(NPRO_+1),W1%CPROJ(NPRO+1),CNLy)
+                    CALL ECCP_NL_SPN(LMDIM,LMMAXC,CMPLX(1._q,0._q,q),CQIJ(1,1,NI,1+1+2*0),W2%CPROJ(NPRO_+1),W1%CPROJ(NPRO+1),CNLz)
+                 ELSEIF (ISPINOR==1 .AND. ISPINOR_==0 ) THEN
+                    CALL ECCP_NL_SPN(LMDIM,LMMAXC,CMPLX(1._q,0._q,q),CQIJ(1,1,NI,1+0+2*0),W2%CPROJ(NPRO_+1),W1%CPROJ(NPRO+1),CNLx)
+                    CALL ECCP_NL_SPN(LMDIM,LMMAXC,CMPLX(0._q,1._q,q),CQIJ(1,1,NI,1+0+2*0),W2%CPROJ(NPRO_+1),W1%CPROJ(NPRO+1),CNLy)
+                    CALL ECCP_NL_SPN(LMDIM,LMMAXC,CMPLX(-1._q,0._q,q),CQIJ(1,1,NI,1+0+2*1),W2%CPROJ(NPRO_+1),W1%CPROJ(NPRO+1),CNLz)
+                 ELSEIF (ISPINOR==1 .AND. ISPINOR_==1 ) THEN
+                    CALL ECCP_NL_SPN(LMDIM,LMMAXC,CMPLX(1._q,0._q,q),CQIJ(1,1,NI,1+1+2*0),W2%CPROJ(NPRO_+1),W1%CPROJ(NPRO+1),CNLx)
+                    CALL ECCP_NL_SPN(LMDIM,LMMAXC,CMPLX(0._q,1._q,q),CQIJ(1,1,NI,1+1+2*1),W2%CPROJ(NPRO_+1),W1%CPROJ(NPRO+1),CNLy)
+                    CALL ECCP_NL_SPN(LMDIM,LMMAXC,CMPLX(-1._q,0._q,q),CQIJ(1,1,NI,1+1+2*1),W2%CPROJ(NPRO_+1),W1%CPROJ(NPRO+1),CNLz)
+                 ENDIF
+                 NPRO = LMMAXC+NPRO
+                 NPRO_= LMMAXC+NPRO_
+              ENDDO
+           ENDIF
+           NIS = NIS+W1%WDES1%NITYP(NT)
+        ENDDO
+     ENDDO
+     ENDDO spinor
+     C(1)=C(1)+CNLx
+     C(2)=C(2)+CNLy
+     C(3)=C(3)+CNLz
+  ENDIF
+  !WRITE(*,*) C
+  CALLMPI( M_sum_g(W1%WDES1%COMM_INB, C(1), 3))
+  !DEALLOCATE(SCQIJ_x,SCQIJ_y,SCQIJ_z)
+
+END FUNCTION W1_SPN_DOT
 
 !***********************************************************************
 !
@@ -3158,6 +3282,43 @@
 
   END SUBROUTINE ECCP_NL
 
+!************************* SUBROUTINE ECCP_NL_SPN   ************************
+!
+! 2020-06-25 CCX: added for .spn calculation in mlwf.F
+! this subroutine calculates the expectation value of <c|SPN*H|cp>
+! where c and cp are two wavefunctions; non local part only
+! for one ion only
+! I have put this in a separate routine because optimization
+! is than easier
+!
+!***********************************************************************
+
+  SUBROUTINE ECCP_NL_SPN(LMDIM,LMMAXC,PAULI,CDIJ,CPROJ1,CPROJ2,CNL)
+    USE prec
+    IMPLICIT NONE
+    COMPLEX(q) :: PAULI ! paulimatrix element
+    GDEF      CNL
+    INTEGER LMDIM, LMMAXC
+    OVERLAP CDIJ(LMDIM,LMDIM)
+    GDEF CPROJ1(LMMAXC),CPROJ2(LMMAXC)
+ ! local
+    INTEGER L, LP
+
+!   PROFILING_START('eccp_nl')
+
+!DIR$ IVDEP
+!OCL NOVREL
+    DO L=1,LMMAXC
+       DO LP=1,LMMAXC
+          CNL=CNL+PAULI*CDIJ(LP,L)*CPROJ1(LP)*GCONJG(CPROJ2(L))
+       ENDDO
+    ENDDO
+
+!   PROFILING_STOP('eccp_nl')
+
+END SUBROUTINE ECCP_NL_SPN
+
+
 
 !************************* SUBROUTINE OVERL ***************************
 !
