diff --color -ruN src/mlwf.F ../vasp.5.4.4.pl2.mod/src/mlwf.F
--- src/mlwf.F	2019-11-04 13:45:34.000000000 +0000
+++ ../vasp.5.4.4.pl2.mod/src/mlwf.F	2022-05-31 14:02:45.947007332 +0100
@@ -3,15 +3,33 @@
       MODULE mlwf
       USE prec
       USE pead
- 
+
       ! write the wave functions to UNK files
       LOGICAL, PRIVATE, SAVE :: WRITE_UNK
+      LOGICAL, PRIVATE, SAVE :: UNK_FMTED
+      LOGICAL, PRIVATE, SAVE :: REDUCE_UNK
+
+      ! write the wave functions to UNK files
+      LOGICAL, PRIVATE, SAVE :: WRITE_SPN
+      LOGICAL, PRIVATE, SAVE :: SPN_FMTED
+
+      ! write the wave functions to UNK files
+      LOGICAL, PRIVATE, SAVE :: WRITE_UHU
+      LOGICAL, PRIVATE, SAVE :: UHU_FMTED
+
       ! write the mmn and amn files when WANNIER90 runs in lib mode
-      LOGICAL, PRIVATE, SAVE :: WRITE_MMN_AMN
+      LOGICAL, PRIVATE, SAVE :: CALC_MMN
+      LOGICAL, PRIVATE, SAVE :: CALC_AMN
+      LOGICAL, PRIVATE, SAVE :: WRITE_MMN
+      LOGICAL, PRIVATE, SAVE :: WRITE_AMN
+      LOGICAL, PRIVATE, SAVE :: WRITE_EIG
 
       ! read amn file instead of computing it
       LOGICAL, PRIVATE, SAVE :: READ_AMN
 
+      ! which collinear spin channel do we want?
+      INTEGER, PRIVATE, SAVE :: W90_SPIN
+
       ! wannier90_run variables: output
       COMPLEX(q), ALLOCATABLE, SAVE :: U_matrix(:,:,:,:)
       COMPLEX(q), ALLOCATABLE, SAVE :: U_matrix_opt(:,:,:,:)
@@ -34,7 +52,7 @@
       ! setup and run wannier90 in library mode
       LOGICAL, SAVE :: LWANNIER90_RUN=.FALSE.
 
-      !filename of Wannier projection matrices 
+      !filename of Wannier projection matrices
       CHARACTER(LEN=7),PUBLIC,PARAMETER :: WANPROJFILE='WANPROJ'
       ! write U_nm(k) matrix
       LOGICAL, PUBLIC, SAVE :: LWRITE_WANPROJ
@@ -80,7 +98,7 @@
           real(kind=dp), dimension(num_bands_tot_), intent(out) :: proj_zona_
           integer, dimension(num_bands_tot_), intent(out) :: exclude_bands_
 #ifdef VASP2WANNIER90v2
-          integer, dimension(num_bands_tot_), optional, intent(out) :: proj_s_  
+          integer, dimension(num_bands_tot_), optional, intent(out) :: proj_s_
           real(kind=dp), dimension(3,num_bands_tot_), optional, intent(out) :: proj_s_qaxis_
 #endif
         end subroutine wannier_setup
@@ -121,7 +139,7 @@
       CONTAINS
 
 !******************** SUBROUTINE MLWF_READER ***************************
-!      
+!
 !***********************************************************************
       SUBROUTINE MLWF_READER(IU5,IU6,IU0,LDOWNSAMPLE)
       USE base
@@ -173,18 +191,32 @@
       IF ( LWRITE_WANPROJ .AND. .NOT.LWANNIER90_RUN) THEN
          IF(IU0>=0)WRITE(IU0,*)'LWANNIER90_RUN forced by LWRITE_WANPROJ'
          LWANNIER90_RUN=.TRUE.
-      ENDIF 
-  
+      ENDIF
+
       !WANPROJ needs downsampling
       IF ( LWRITE_WANPROJ .AND. .NOT.LDOWNSAMPLE) THEN
          IF(IU0>=0)WRITE(IU0,*)'LDOWNSAMPLE forced by LWRITE_WANPROJ'
          LDOWNSAMPLE=.TRUE.
-      ENDIF 
-      
+      ENDIF
+
       IF (WANNIER90()) THEN
          ! Switch on the PEAD routines
          CALL PEAD_REQUEST
 
+         ! spin channel
+         W90_SPIN=0
+         CALL RDATAB(.FALSE.,INCAR,IU5,'W90_SPIN','=','#',';','I', &
+        &            W90_SPIN,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+         IF (((IERR/=0).AND.(IERR/=3)).OR. &
+        &                    ((IERR==0).AND.(N<1))) THEN
+            IF (IU0>=0) &
+               WRITE(IU0,*)'Error reading item ''LWRITE_UNK'' from file INCAR.'
+            W90_SPIN=0
+            IF (W90_SPIN/=0 .AND. W90_SPIN/=1 .AND. W90_SPIN/=2) &
+               WRITE(IU0,*)'Error reading item ''LWRITE_UNK'' from file INCAR.'
+            W90_SPIN=0
+         ENDIF
+
          ! Do we want to write UNK files?
          WRITE_UNK=.FALSE.
          CALL RDATAB(.FALSE.,INCAR,IU5,'LWRITE_UNK','=','#',';','L', &
@@ -195,17 +227,140 @@
                WRITE(IU0,*)'Error reading item ''LWRITE_UNK'' from file INCAR.'
             WRITE_UNK=.FALSE.
          ENDIF
+
+         ! 2020-06-22 CCX: added to determine UNK is formatted or not
+         UNK_FMTED=.FALSE.
+         CALL RDATAB(.FALSE.,INCAR,IU5,'LUNK_FMTED','=','#',';','L', &
+        &            IDUM,RDUM,CDUM,UNK_FMTED,CHARAC,N,1,IERR)
+         IF (((IERR/=0).AND.(IERR/=3)).OR. &
+        &                    ((IERR==0).AND.(N<1))) THEN
+            IF (IU0>=0) &
+               WRITE(IU0,*)'Error reading item ''LUNK_FMTED'' from file INCAR.'
+            UNK_FMTED=.FALSE.
+         ENDIF
+
+         ! 2020-07-04 CCX: added to determine UNK is formatted or not
+         REDUCE_UNK=.FALSE.
+         CALL RDATAB(.FALSE.,INCAR,IU5,'LREDUCE_UNK','=','#',';','L', &
+        &            IDUM,RDUM,CDUM,REDUCE_UNK,CHARAC,N,1,IERR)
+         IF (((IERR/=0).AND.(IERR/=3)).OR. &
+        &                    ((IERR==0).AND.(N<1))) THEN
+            IF (IU0>=0) &
+               WRITE(IU0,*)'Error reading item ''LREDUCE_UNK'' from file INCAR.'
+            REDUCE_UNK=.FALSE.
+         ENDIF
+
+         ! 2020-06-25 CCX: Do we want to write the spn file?
+         WRITE_SPN=.FALSE.
+         CALL RDATAB(.FALSE.,INCAR,IU5,'LWRITE_SPN','=','#',';','L', &
+        &            IDUM,RDUM,CDUM,WRITE_SPN,CHARAC,N,1,IERR)
+         IF (((IERR/=0).AND.(IERR/=3)).OR. &
+        &                    ((IERR==0).AND.(N<1))) THEN
+            IF (IU0>=0) &
+               WRITE(IU0,*)'Error reading item ''LWRITE_SPN'' from file INCAR.'
+            WRITE_SPN=.FALSE.
+         ENDIF
+
+         ! 2020-06-25 CCX: Do we want to write the spn file formated?
+         SPN_FMTED=.FALSE.
+         CALL RDATAB(.FALSE.,INCAR,IU5,'LSPN_FMTED','=','#',';','L', &
+        &            IDUM,RDUM,CDUM,SPN_FMTED,CHARAC,N,1,IERR)
+         IF (((IERR/=0).AND.(IERR/=3)).OR. &
+        &                    ((IERR==0).AND.(N<1))) THEN
+            IF (IU0>=0) &
+               WRITE(IU0,*)'Error reading item ''LSPN_FMTED'' from file INCAR.'
+            SPN_FMTED=.FALSE.
+         ENDIF
+
+         ! 2020-06-25 CCX: Do we want to write the uHu file?
+         WRITE_uHu=.FALSE.
+         CALL RDATAB(.FALSE.,INCAR,IU5,'LWRITE_UHU','=','#',';','L', &
+        &            IDUM,RDUM,CDUM,WRITE_UHU,CHARAC,N,1,IERR)
+         IF (((IERR/=0).AND.(IERR/=3)).OR. &
+        &                    ((IERR==0).AND.(N<1))) THEN
+            IF (IU0>=0) &
+               WRITE(IU0,*)'Error reading item ''LWRITE_UHU'' from file INCAR.'
+            WRITE_SPN=.FALSE.
+         ENDIF
+
+         ! 2020-06-25 CCX: Do we want to write the uHu file formated?
+         uHu_FMTED=.FALSE.
+         CALL RDATAB(.FALSE.,INCAR,IU5,'LUHU_FMTED','=','#',';','L', &
+        &            IDUM,RDUM,CDUM,UHU_FMTED,CHARAC,N,1,IERR)
+         IF (((IERR/=0).AND.(IERR/=3)).OR. &
+        &                    ((IERR==0).AND.(N<1))) THEN
+            IF (IU0>=0) &
+               WRITE(IU0,*)'Error reading item ''LUHU_FMTED'' from file INCAR.'
+            UHU_FMTED=.FALSE.
+         ENDIF
+
+
          ! Do we want to write the mmn and amn files
          ! even though WANNIER90 runs in library mode?
-         WRITE_MMN_AMN=.NOT.LWANNIER90_RUN
-         CALL RDATAB(.FALSE.,INCAR,IU5,'LWRITE_MMN_AMN','=','#',';','L', &
-        &            IDUM,RDUM,CDUM,WRITE_MMN_AMN,CHARAC,N,1,IERR)
+         ! 2020-07-04 CCX: do we really need to calculate MMN AMN and write EIG?
+         CALC_MMN=.TRUE.
+         CALL RDATAB(.FALSE.,INCAR,IU5,'LCALC_MMN','=','#',';','L', &
+        &            IDUM,RDUM,CDUM,CALC_MMN,CHARAC,N,1,IERR)
          IF (((IERR/=0).AND.(IERR/=3)).OR. &
         &                    ((IERR==0).AND.(N<1))) THEN
             IF (IU0>=0) &
-               WRITE(IU0,*)'Error reading item ''LWRITE_MMN_AMN'' from file INCAR.'
-            WRITE_MMN_AMN=.NOT.LWANNIER90_RUN
+               WRITE(IU0,*)'Error reading item ''LCALC_MMN'' from file INCAR.'
+            ! this is counterintuitive, we want to calculate MMN by default
+            CALC_MMN=.TRUE.
          ENDIF
+         ! if wannier90_run, we need mmn calculation
+         IF ((LWANNIER90_RUN) .AND. (.NOT.CALC_MMN)) CALC_MMN=.TRUE.
+
+
+         WRITE_MMN=.NOT.LWANNIER90_RUN
+         CALL RDATAB(.FALSE.,INCAR,IU5,'LWRITE_MMN','=','#',';','L', &
+        &            IDUM,RDUM,CDUM,WRITE_MMN,CHARAC,N,1,IERR)
+         IF (((IERR/=0).AND.(IERR/=3)).OR. &
+        &                    ((IERR==0).AND.(N<1))) THEN
+            IF (IU0>=0) &
+               WRITE(IU0,*)'Error reading item ''LWRITE_MMN'' from file INCAR.'
+            WRITE_MMN=.NOT.LWANNIER90_RUN
+         ENDIF
+         ! if we dont calculate mmn, we cannot write mmn...
+         IF (.NOT.CALC_MMN) WRITE_MMN=.FALSE.
+
+
+         CALC_AMN=.TRUE.
+         CALL RDATAB(.FALSE.,INCAR,IU5,'LCALC_AMN','=','#',';','L', &
+        &            IDUM,RDUM,CDUM,CALC_AMN,CHARAC,N,1,IERR)
+         IF (((IERR/=0).AND.(IERR/=3)).OR. &
+        &                    ((IERR==0).AND.(N<1))) THEN
+            IF (IU0>=0) &
+               WRITE(IU0,*)'Error reading item ''LCALC_AMN'' from file INCAR.'
+            ! this is counterintuitive, we want to calculate MMN by default
+            CALC_AMN=.TRUE.
+         ENDIF
+         ! if wannier90_run, we need amn calculation
+         IF ((LWANNIER90_RUN) .AND. (.NOT.CALC_AMN)) CALC_AMN=.TRUE.
+
+         WRITE_AMN=.NOT.LWANNIER90_RUN
+         CALL RDATAB(.FALSE.,INCAR,IU5,'LWRITE_AMN','=','#',';','L', &
+        &            IDUM,RDUM,CDUM,WRITE_AMN,CHARAC,N,1,IERR)
+         IF (((IERR/=0).AND.(IERR/=3)).OR. &
+        &                    ((IERR==0).AND.(N<1))) THEN
+            IF (IU0>=0) &
+               WRITE(IU0,*)'Error reading item ''LWRITE_AMN'' from file INCAR.'
+            WRITE_AMN=.NOT.LWANNIER90_RUN
+         ENDIF
+         ! if we dont calculate amn, we cannot write amn...
+         IF (.NOT.CALC_AMN) WRITE_AMN=.FALSE.
+
+
+         WRITE_EIG=.NOT.LWANNIER90_RUN
+         CALL RDATAB(.FALSE.,INCAR,IU5,'LWRITE_EIG','=','#',';','L', &
+        &            IDUM,RDUM,CDUM,WRITE_EIG,CHARAC,N,1,IERR)
+         IF (((IERR/=0).AND.(IERR/=3)).OR. &
+        &                    ((IERR==0).AND.(N<1))) THEN
+            IF (IU0>=0) &
+               WRITE(IU0,*)'Error reading item ''LWRITE_EIG'' from file INCAR.'
+            WRITE_EIG=.NOT.LWANNIER90_RUN
+         ENDIF
+
          ! Do we want to read the amn file instead of
          ! computing it anew?
          READ_AMN=.FALSE.
@@ -254,7 +409,7 @@
       IMPLICIT NONE
       LOGICAL WANNIER90RUN
       WANNIER90RUN=LWANNIER90_RUN
-      END FUNCTION WANNIER90RUN 
+      END FUNCTION WANNIER90RUN
 
       SUBROUTINE WANNIER90_RUN_REQUEST
       IMPLICIT NONE
@@ -263,7 +418,7 @@
       END SUBROUTINE WANNIER90_RUN_REQUEST
 
 !******************** SUBROUTINE MLWF_WANNIER90 ************************
-!      
+!
 !***********************************************************************
       SUBROUTINE MLWF_WANNIER90(&
      & WDES,W,P,CQIJ,T_INFO,LATT_CUR,INFO,IO &
@@ -320,6 +475,9 @@
       REAL(q), ALLOCATABLE :: proj_x(:,:)
       REAL(q), ALLOCATABLE :: proj_zona(:)
       INTEGER, ALLOCATABLE :: exclude_bands(:)
+      ! CCX_2019-05-05: define proj_s and proj_s_qaxis
+      INTEGER, ALLOCATABLE :: proj_s(:)
+      REAL(q), ALLOCATABLE :: proj_s_qaxis(:,:)
       ! wannier90_run variables: input
       COMPLEX(q), ALLOCATABLE :: M_matrix(:,:,:,:,:)
       COMPLEX(q), ALLOCATABLE :: A_matrix(:,:,:,:)
@@ -329,6 +487,22 @@
       INTEGER NI,MI,NK,NKP,ICNTR
       INTEGER NKI,NKJ,ISP,ISPINOR,L,M,N,NP
       INTEGER NEXCLB,NPROJ
+
+      ! CCX_2022-05-30: add local variables for uHu and uIu
+      INTEGER NB1, NB2
+      INTEGER LLI, LL
+      REAL(q) KB1(3), KB2(3)
+      COMPLEX(q), ALLOCATABLE :: uHu_matrix(:,:,:,:,:,:)
+      CHARACTER (len=60)       :: uHu_header
+      ! CCX_2022-05-30: end definition
+
+
+      ! CCX_2019-05-06: spin quantization local variables
+      LOGICAL spin_z_pos,spin_z_neg
+      COMPLEX(q) FAC(2)
+      REAL(q) :: eps6=0.000001_q
+      REAL(q) xnorm
+      ! CCX_2019-05-06: end definition
       REAL(q) POS(3)
       REAL(q) KI(3),KJ(3)
       INTEGER IDUM,IERR
@@ -347,9 +521,16 @@
       REAL(q), ALLOCATABLE :: ROTYLM(:,:)
       REAL(q), ALLOCATABLE :: HYBRID_ORBITAL(:)
 
+      ! 2020-06-25 CCX added for spn matrix calc
+      GDEF, ALLOCATABLE :: SPN(:,:,:)
+      GDEF, ALLOCATABLE :: spin_mat(:,:)
+      INTEGER :: spn_counter
+      CHARACTER (len=60)       :: SPN_header
+      ! CCX_2019-05-06: end definition
+
       LOGICAL, ALLOCATABLE :: EXCLUDE_BAND(:)
       LOGICAL LUSE_BLOCH_PHASES
-      
+
       INTEGER, PARAMETER :: LMAX=3
       CHARACTER(LEN=11):: UNKFILE
       CHARACTER(LEN=2) :: SP(2)=(/"up","dn"/)
@@ -357,20 +538,48 @@
       INTEGER num_bands_on_file,num_kpts_on_file,NPROJ_on_file
 
       IF (.NOT.WANNIER90()) RETURN
+      IF (IO%IU0>=0) WRITE(IO%IU0,*) "*---------------------------------------*"
+      IF (IO%IU0>=0) WRITE(IO%IU0,*) "*             VASP2WANNIER90            *"
+      IF (IO%IU0>=0) WRITE(IO%IU0,*) "*---------------------------------------*"
+
+      ! CCX-2022-05-31: as of now, we need to calculate MMN (and EIG) to calculate UHU.
+      ! manually setting them here.
+      ! TODO: add read mmn routine, check if MMN exist. If do, skip MMN calculation.
+      IF (WRITE_UHU .AND. .NOT. (CALC_MMN .AND. WRITE_EIG)) THEN
+         IF (IO%IU0>=0) WRITE(IO%IU0,*) '*  WRITE_UHU sets CALC_MMN & WRITE_EIG  *'
+         CALC_MMN = .TRUE.
+         ! WRITE_MMN = .TRUE.
+         WRITE_EIG = .TRUE.
+      ENDIF
 
-#ifdef MPI
+      ! 2020-06-28 CCX: I moved this to here so we can have control over collinear spin channels.
+      ! loop over spin
+      spin: DO ISP=1,WDES%ISPIN
+
+      IF ((.not. WDES%LNONCOLLINEAR) .AND. (W90_SPIN==2) .AND. (ISP==1)) CYCLE spin
+      IF ((.not. WDES%LNONCOLLINEAR) .AND. (W90_SPIN==1) .AND. (ISP==2)) CYCLE spin
+      IF ((.not. WDES%LNONCOLLINEAR) .AND. (WDES%ISPIN==2) .AND. (IO%IU0>=0)) &
+         WRITE(IO%IU0,*)'*          Collinear spin -> '//SP(ISP)//'         *'
+      IF ((WDES%LNONCOLLINEAR) .AND. (IO%IU0>=0)) &
+         WRITE(IO%IU0,*)'*          Non-collinear spin           *'
+      IF ((.not. WDES%LNONCOLLINEAR) .AND. (WDES%ISPIN==1) .AND. (IO%IU0>=0)) &
+         WRITE(IO%IU0,*)'*         No spin polarization          *'
+
+!#ifdef MPI
 !     IF (WDES%COMM_KINTER%NCPU.NE.1) THEN
 !        CALLMPI( M_stop('MLWF_WANNIER90: KPAR>1 not implemented, sorry.') )
 !        STOP
 !     END IF
-#endif
+!#endif
+
+! 2020-06-22 CCX: wannier90 CAN plot spinors.
       ! WANNIER90 cannot plot spinors
-      IF (WRITE_UNK.AND.WDES%LNONCOLLINEAR) THEN
-         IF (IO%IU0>=0) WRITE(IO%IU0,*) &
-        & 'MLWF_WANNIER90: ERROR: will not write spinors to UNK files, sorry ...'
-         WRITE_UNK=.FALSE.
-      ENDIF
-!
+!      IF (WRITE_UNK.AND.WDES%LNONCOLLINEAR) THEN
+!         IF (IO%IU0>=0) WRITE(IO%IU0,*) &
+!        & 'MLWF_WANNIER90: ERROR: will not write spinors to UNK files, sorry ...'
+!         WRITE_UNK=.FALSE.
+!      ENDIF
+
 ! allocation
       ALLOCATE(S(WDES%NB_TOT,WDES%NB_TOT))
 
@@ -422,8 +631,25 @@
       ! A minimal wannier90.win file must exist; it must at least
       ! contain the keyword "num_wann"
       IF (IO%IU6>=0) THEN
-         INQUIRE(FILE=seed_name//'.win',EXIST=LWIN_FOUND)         
+         IF ((.not. spinors) .AND. (WDES%ISPIN==2)) THEN
+            INQUIRE(FILE=seed_name//'.'//SP(ISP)//'.win',EXIST=LWIN_FOUND)
+         ELSE
+            INQUIRE(FILE=seed_name//'.win',EXIST=LWIN_FOUND)
+         ENDIF
+
          IF (LWIN_FOUND) THEN
+            IF ((.not. spinors) .AND. (WDES%ISPIN==2)) THEN
+               OPEN(UNIT=99,FILE=seed_name//'.'//SP(ISP)//'.win',STATUS='OLD')
+               CALL RDATAB(.FALSE.,seed_name//'.'//SP(ISP)//'.win',99,'num_wann','=','#',';','I', &
+              &            IDUM,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+               IF (((IERR/=0).AND.(IERR/=3)).OR. &
+              &                    ((IERR==0).AND.(N<1))) THEN
+                  IF (IO%IU0>=0) &
+                     WRITE(IO%IU0,*)'Error reading item ''num_wann'' from file '//seed_name//'.win'
+                  STOP
+               ENDIF
+               IF (IERR==3) WRITE(99,'(A,I6,2X,A)') ' num_wann =',WDES%NB_TOT,'! set to NBANDS by VASP'
+            ELSE
             OPEN(UNIT=99,FILE=seed_name//'.win',STATUS='OLD')
             CALL RDATAB(.FALSE.,seed_name//'.win',99,'num_wann','=','#',';','I', &
            &            IDUM,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
@@ -434,11 +660,17 @@
                STOP
             ENDIF
             IF (IERR==3) WRITE(99,'(A,I6,2X,A)') ' num_wann =',WDES%NB_TOT,'! set to NBANDS by VASP'
+            ENDIF
+         ELSE
+            IF ((.not. spinors) .AND. (WDES%ISPIN==2)) THEN
+               OPEN(UNIT=99,FILE=seed_name//'.'//SP(ISP)//'.win',STATUS='REPLACE')
+               WRITE(99,'(A,I6,2X,A)') ' num_wann =',WDES%NB_TOT,'! set to NBANDS by VASP'
          ELSE
             OPEN(UNIT=99,FILE=seed_name//'.win',STATUS='REPLACE')
             WRITE(99,'(A,I6,2X,A)') ' num_wann =',WDES%NB_TOT,'! set to NBANDS by VASP'
          ENDIF
-         CLOSE(99) 
+         ENDIF
+         CLOSE(99)
       ENDIF
 
       ! Initialize everything to zero
@@ -449,21 +681,50 @@
 
       ALLOCATE(proj_site(3,num_bands_tot),proj_l(num_bands_tot),proj_m(num_bands_tot), &
      &   proj_radial(num_bands_tot),proj_z(3,num_bands_tot),proj_x(3,num_bands_tot), &
-     &   proj_zona(num_bands_tot),exclude_bands(num_bands_tot))
+     &   proj_zona(num_bands_tot),exclude_bands(num_bands_tot), &
+#ifdef VASP2WANNIER90v2
+! CCX_2019-05-05: allocate proj_s and proj_s_qaxis.
+     &   proj_s(num_bands_tot),proj_s_qaxis(3,num_bands_tot) &
+#endif
+     &   )
       proj_site=0; proj_l=0; proj_m=0; proj_radial=0; proj_z=0; proj_x=0; proj_zona=0; exclude_bands=0
 
+! CCX_2019-05-05: initialize proj_s and proj_s_qaxis.
+#ifdef VASP2WANNIER90v2
+      proj_s=0; proj_s_qaxis=0
+#endif
+
       ! Only one node will do the actual work,
       ! otherwise all will write to wannier90.wout
 #ifdef VASP2WANNIER90
-      IF (IO%IU6>=0) &
+      IF (IO%IU6>=0) THEN
+         IF ((.not.spinors) .AND. (WDES%ISPIN==2)) THEN
+      CALL wannier_setup(seed_name//'.'//SP(ISP),mp_grid,num_kpts,real_lattice,recip_lattice, &
+     &                   kpt_latt,num_bands_tot,num_atoms,atom_symbols,atoms_cart, &
+     &                   gamma_only,spinors,nntot,nnlist,nncell,num_bands,num_wann, &
+     &                   proj_site,proj_l,proj_m,proj_radial,proj_z,proj_x,proj_zona, &
+     &                   exclude_bands, &
+#ifdef VASP2WANNIER90v2
+! CCX_2019-05-05: call wannier_setup to calculate proj_s and proj_s_qaxis
+     &                   proj_s,proj_s_qaxis &
+#endif
+     &                   )
+         ELSE
       CALL wannier_setup(seed_name,mp_grid,num_kpts,real_lattice,recip_lattice, &
      &                   kpt_latt,num_bands_tot,num_atoms,atom_symbols,atoms_cart, &
      &                   gamma_only,spinors,nntot,nnlist,nncell,num_bands,num_wann, &
      &                   proj_site,proj_l,proj_m,proj_radial,proj_z,proj_x,proj_zona, &
-     &                   exclude_bands)
+     &                   exclude_bands, &
+#ifdef VASP2WANNIER90v2
+! CCX_2019-05-05: call wannier_setup to calculate proj_s and proj_s_qaxis
+     &                   proj_s,proj_s_qaxis &
+#endif
+     &                   )
+         ENDIF
+      ENDIF
 #endif
       ! Now communicate the output to the other nodes
-      CALLMPI( M_sum_i(WDES%COMM,nntot,1) ) 
+      CALLMPI( M_sum_i(WDES%COMM,nntot,1) )
       CALLMPI( M_sum_i(WDES%COMM,nnlist,num_kpts*num_nnmax) )
       CALLMPI( M_sum_i(WDES%COMM,nncell,3*num_kpts*num_nnmax) )
       CALLMPI( M_sum_i(WDES%COMM,num_bands,1) )
@@ -476,6 +737,11 @@
       CALLMPI( M_sum_d(WDES%COMM,proj_x,3*num_bands_tot) )
       CALLMPI( M_sum_d(WDES%COMM,proj_zona,num_bands_tot) )
       CALLMPI( M_sum_i(WDES%COMM,exclude_bands,num_bands_tot) )
+! CCX_2019-05-05: bcast proj_s and proj_s_qaxis
+#ifdef VASP2WANNIER90v2
+      CALLMPI( M_sum_i(WDES%COMM,proj_s,num_bands_tot) )
+      CALLMPI( M_sum_d(WDES%COMM,proj_s_qaxis,3*num_bands_tot) )
+#endif
 
       ALLOCATE(EXCLUDE_BAND(num_bands_tot))
       EXCLUDE_BAND=.FALSE. ; NEXCLB=0
@@ -520,7 +786,7 @@
       ! Here the work starts in earnest
       ! We need to calculate M(m,n,j,i) = < u_m,k_i | u_n,k_j >
       ! where k_i = kpt_latt(:,i), and k_j = kpt_latt(:,nnlist(i,j))+nncell(:,i,j)
-      ! U(m,n,j,i) is then written to the file seed_name.mmn 
+      ! U(m,n,j,i) is then written to the file seed_name.mmn
 
       ALLOCATE(M_matrix(num_bands,num_bands,nntot,num_kpts,WDES%ISPIN))
       ALLOCATE(A_matrix(num_bands,num_wann,num_kpts,WDES%ISPIN))
@@ -530,18 +796,18 @@
       ! nullify pointers by default
       R%R=>NULL(); R%SI=>NULL()
 
-      ! loop over spin
-      spin: DO ISP=1,WDES%ISPIN
-
-      IF (IO%IU6>=0.AND.WRITE_MMN_AMN) THEN
+      IF (IO%IU6>=0.AND.WRITE_MMN) THEN
          IF (WDES%ISPIN==1) THEN
             OPEN(UNIT=99,FILE=seed_name//'.mmn',STATUS='REPLACE')
          ELSE
-            OPEN(UNIT=99,FILE=seed_name//'.'//SP(ISP)//'.mmn',STATUS='REPLACE')            
+            OPEN(UNIT=99,FILE=seed_name//'.'//SP(ISP)//'.mmn',STATUS='REPLACE')
          ENDIF
          WRITE(99,'(A)') 'File generated by VASP: '//INFO%SZNAM1
          WRITE(99,'(3I12)') num_bands,num_kpts,nntot
       ENDIF
+
+      ! 2020-07-04 CCX: do we want to calculate mmn matrix
+      IF (CALC_MMN) THEN
       ! runs over all k-points
       ki_loop: DO NKI=1,num_kpts
          KI(:)=kpt_latt(:,NKI)
@@ -553,7 +819,7 @@
 #endif
             CALL PEAD_CALC_OVERLAP(W,KI,KJ,ISP,P,CQIJ,LATT_CUR,T_INFO,S,LQIJB=.TRUE.)
 
-            IF (IO%IU6>=0.AND.WRITE_MMN_AMN) WRITE(99,'(5I5)') NKI,nnlist(NKI,NKJ),nncell(:,NKI,NKJ)
+            IF (IO%IU6>=0.AND.WRITE_MMN) WRITE(99,'(5I5)') NKI,nnlist(NKI,NKJ),nncell(:,NKI,NKJ)
 
             NI=0
             n_loop: DO N=1,WDES%NB_TOT
@@ -563,7 +829,7 @@
                   IF (EXCLUDE_BAND(M)) CYCLE m_loop
                   MI=MI+1
                   M_matrix(MI,NI,NKJ,NKI,ISP)=S(M,N)
-                  IF (IO%IU6>=0.AND.WRITE_MMN_AMN) WRITE(99,'(2F18.12)') S(M,N)
+                  IF (IO%IU6>=0.AND.WRITE_MMN) WRITE(99,'(2F18.12)') S(M,N)
                ENDDO m_loop
             ENDDO n_loop
             ! check consistency
@@ -575,18 +841,102 @@
          ENDDO kj_loop
       ENDDO ki_loop
 
-      IF (IO%IU6>=0.AND.WRITE_MMN_AMN) CLOSE(99)
+
+      IF (IO%IU6>=0.AND.WRITE_MMN) CLOSE(99)
+      IF (IO%IU0>=0) WRITE(IO%IU0,*) "*            MMN calculated.            *"
+      !2020-07-04
+      ENDIF
+
+
+      ! 2020-06-25 CCX: write SPN matrix
+      IF (WRITE_SPN .AND. (.NOT. spinors)) THEN
+         IF (IO%IU0>=0) WRITE(*,*) 'MLWF_WANNIER90: WRITE_SPN only works in non-collinear, skipping.'
+         WRITE_SPN=.FALSE.
+      ENDIF
+
+      IF (WRITE_SPN .AND. WDES%COMM%NCPU.NE.1) THEN
+         IF (IO%IU0>=0) WRITE(*,*) 'MLWF_WANNIER90: WRITE_SPN only works in serial, skipping.'
+         WRITE_SPN=.FALSE.
+      ENDIF
+
+
+      IF (IO%IU6>=0.AND.WRITE_SPN) THEN
+         IF (WDES%NRSPINORS==1) THEN
+            IF (IO%IU0>=0) WRITE(*,*) 'MLWF_WANNIER90: ERROR: WRITE_SPN specified, but collinear calculation.'
+            STOP
+         ELSE
+            IF (SPN_FMTED) THEN
+               OPEN(UNIT=99,FILE=seed_name//'.spn',FORM="FORMATTED",STATUS='REPLACE')
+               SPN_header = 'File generated by VASP: '//INFO%SZNAM1
+               WRITE(99,'(A)') SPN_header
+               WRITE(99,'(3I12)') num_bands,num_kpts
+            ELSE
+               OPEN(UNIT=99,FILE=seed_name//'.spn',FORM="UNFORMATTED",STATUS='REPLACE')
+               SPN_header = 'File generated by VASP: '//INFO%SZNAM1
+               WRITE(99) SPN_header
+               WRITE(99) num_bands,num_kpts
+            ENDIF
+         ENDIF
+      ENDIF
+
+      IF (WDES%NRSPINORS/=1.AND.WRITE_SPN) THEN
+      ALLOCATE(spin_mat((num_bands+1)*num_bands/2,3))
+      ALLOCATE(SPN(WDES%NB_TOT,WDES%NB_TOT,3))
+      ! runs over all k-points
+      spn_ki_loop: DO NKI=1,num_kpts
+         KI(:)=kpt_latt(:,NKI)
+
+         CALL CALC_SPN_EXP(W,KI,P,CQIJ,LATT_CUR,T_INFO,SPN)
+
+         !now, we nned to exclude some bands.
+         NI=0
+         spn_n_loop: DO N=1,WDES%NB_TOT
+            IF (EXCLUDE_BAND(N)) CYCLE spn_n_loop
+               spn_m_loop: DO M=1,N
+                  IF (EXCLUDE_BAND(M)) CYCLE spn_m_loop
+                  NI=NI+1
+                  DO spn_counter=1,3
+                     spin_mat(NI,spn_counter)=SPN(M,N,spn_counter)
+                  ENDDO
+               ENDDO spn_m_loop
+         ENDDO spn_n_loop
+
+         ! writing spn matrix to file
+         IF (SPN_FMTED) THEN
+            DO N=1,(num_bands+1)*num_bands/2
+               IF (IO%IU6>=0.AND.WRITE_SPN) WRITE(99,'(2ES26.16)') (spin_mat(N,spn_counter), spn_counter=1,3)
+            ENDDO
+         ELSE
+               IF (IO%IU6>=0.AND.WRITE_SPN) WRITE(99) ((spin_mat(N,spn_counter), spn_counter=1,3), N=1,(num_bands+1)*num_bands/2)
+         ENDIF
+      ENDDO spn_ki_loop
+
+      ! some deallocation for spn mat
+      DEALLOCATE(spin_mat)
+      DEALLOCATE(SPN)
+
+      IF (IO%IU6>=0.AND.WRITE_SPN) CLOSE(99)
+      IF (IO%IU0>=0) WRITE(IO%IU0,*) "*            SPN calculated.            *"
+      ENDIF
+      ! 2020-06-25 CCX: spin matrix calculated
 
       ! and we might want to read an existing amn file
       IF (READ_AMN) THEN
-      ! compute NPROJ 
+      ! compute NPROJ
       NPROJ=0
       DO ISPINOR=1,WDES%NRSPINORS
       DO ICNTR=1,num_bands_tot
          IF (proj_l(ICNTR)==0.AND.proj_m(ICNTR)==0.AND.proj_radial(ICNTR)==0) CYCLE
+! CCX_2019-05-05: only calculate corresponding spin channel
+#ifdef VASP2WANNIER90v2
+         IF (WDES%NRSPINORS/=1.AND.proj_s(ICNTR)==1.AND.ISPINOR==2) CYCLE
+         IF (WDES%NRSPINORS/=1.AND.proj_s(ICNTR)==-1.AND.ISPINOR==1) CYCLE
+#endif
+
          NPROJ=NPROJ+1
       ENDDO
       ENDDO
+
       ! check if amn file exists
       IF (WDES%ISPIN==1) THEN
          INQUIRE(FILE=seed_name//'.amn',EXIST=LAMN_FOUND)
@@ -627,7 +977,8 @@
       ENDIF
       ENDIF ! finished reading A_matrix
 
-      IF (.NOT.READ_AMN) THEN
+      ! 2020-07-04 CCX: added to control amn calculaiton
+      IF ( .NOT. READ_AMN .AND. CALC_AMN) THEN
       ! we need to calculate the projection of the wave functions
       ! onto a set of trial functions {g}: A(m,n,i) = < \psi_m,k_i | g_n >
       ! A(m,n,i) is then written to the file seed_name.amn
@@ -642,12 +993,37 @@
       ALLOCATE(A(WDES%NB_TOT,(LMAX+1)**2),AP(WDES%NB_TOT,(LMAX+1)**2))
       ALLOCATE(ROTYLM((LMAX+1)**2,(LMAX+1)**2),HYBRID_ORBITAL((LMAX+1)**2))
 
-      NPROJ=0 
-!     CALL START_TIMING("T1")
+      NPROJ=0
+      ! CCX_2020-06-15: initialize A matrix
+      A_matrix=0
       ! runs over all projector sites
-      spinor: DO ISPINOR=1,WDES%NRSPINORS
       sites : DO ICNTR=1,num_bands_tot
          IF (proj_l(ICNTR)==0.AND.proj_m(ICNTR)==0.AND.proj_radial(ICNTR)==0) CYCLE sites
+        ! CCX_2019-05-06: determin spin quantization axis along z axis or not.
+        spin_z_pos=.false.
+        spin_z_neg=.false.
+        ! CCX_2019-06-10: renormalize spin quantization axis
+        xnorm=SQRT(proj_s_qaxis(1,ICNTR)*proj_s_qaxis(1,ICNTR)+proj_s_qaxis(2,ICNTR)*proj_s_qaxis(2,ICNTR)+proj_s_qaxis(3,ICNTR)*proj_s_qaxis(3,ICNTR))
+        proj_s_qaxis(1,ICNTR)=proj_s_qaxis(1,ICNTR)/xnorm
+        proj_s_qaxis(2,ICNTR)=proj_s_qaxis(2,ICNTR)/xnorm
+        proj_s_qaxis(3,ICNTR)=proj_s_qaxis(3,ICNTR)/xnorm
+
+        IF ((abs(proj_s_qaxis(1,ICNTR)-0.0d0)<eps6).and.(abs(proj_s_qaxis(2,ICNTR)-0.0d0)<eps6) &
+           .and.(abs(proj_s_qaxis(3,ICNTR)-1.0d0)<eps6)) then
+           spin_z_pos=.true.
+        ELSEIF(abs(proj_s_qaxis(1,ICNTR)-0.0d0)<eps6.and.abs(proj_s_qaxis(2,ICNTR)-0.0d0)<eps6 &
+           .and.abs(proj_s_qaxis(3,ICNTR)+1.0d0)<eps6) then
+           spin_z_neg=.true.
+        ENDIF
+        ! CCX_2019-05-06: [start] if proj_s_qaxis lies along z, normal projections are done.
+        IF (spin_z_pos .OR. spin_z_neg .OR. WDES%NRSPINORS==1) THEN ! if not spinor, still use this routine.
+        spinor1: DO ISPINOR=1,WDES%NRSPINORS
+           IF (spin_z_pos.AND.WDES%NRSPINORS/=1.AND.proj_s(ICNTR)==1.AND.ISPINOR==2) CYCLE spinor1
+           IF (spin_z_pos.AND.WDES%NRSPINORS/=1.AND.proj_s(ICNTR)==-1.AND.ISPINOR==1) CYCLE spinor1
+           ! if neg then swap up and down definition
+           IF (spin_z_neg.AND.WDES%NRSPINORS/=1.AND.proj_s(ICNTR)==1.AND.ISPINOR==1) CYCLE spinor1
+           IF (spin_z_neg.AND.WDES%NRSPINORS/=1.AND.proj_s(ICNTR)==-1.AND.ISPINOR==2) CYCLE spinor1
+
          NPROJ=NPROJ+1
          ! setup the Ylm rotation matrix in accordance with proj_z and proj_x
          CALL SETROTYLM(proj_x(:,ICNTR),proj_z(:,ICNTR),LMAX,ROTYLM)
@@ -659,7 +1035,7 @@
             ENDDO
          ENDIF
 #endif
-         ! translate between VASP and the orbital definition of wannier90  
+         ! translate between VASP and the orbital definition of wannier90
          CALL WANNIER90_ORBITAL_DEFINITIONS(proj_l(ICNTR),proj_m(ICNTR),HYBRID_ORBITAL)
          ! setup the radial functions (real space)
          CALL SETRGRID(RSTART/proj_zona(ICNTR),REND,H,R)
@@ -673,9 +1049,9 @@
          ENDDO
 
 
-!        CALL START_TIMING("T2")
+      !        CALL START_TIMING("T2")
          ! runs over all k-points
-         kpoints : DO NKI=1,num_kpts
+            kpoints1 : DO NKI=1,num_kpts
             CALL CALC_OVERLAP_GN( &
            &   LMAX,FG,proj_site(:,ICNTR),W,kpt_latt(:,NKI),ISP,ISPINOR,P,CQIJ,LATT_CUR,T_INFO,A)
             ! and rotate them in accordance with proj_z and proj_x
@@ -685,7 +1061,7 @@
                DO NP=1,(LMAX+1)**2
                   AP(M,N)=AP(M,N)+A(M,NP)*ROTYLM(N,NP)
                ENDDO
-            ENDDO   
+            ENDDO
             ENDDO
 #ifdef debug
             IF (IO%IU6>=0) THEN
@@ -712,15 +1088,111 @@
                A_matrix(MI,NPROJ,NKI,ISP)=CPROJ
             ENDDO
 
+            ENDDO kpoints1
+
+         DEALLOCATE(FTMP,FR,FGTMP,FG)
+
+         IF (IO%IU0>=0) WRITE(IO%IU0,'(X,A,I3,A,I3,A)') '*       Projection [',NPROJ,'/',num_wann,'] done.      *'
+      !        CALL STOP_TIMING("T2",IO%IU6,'  OVL')
+      !        CALL STOP_TIMING("T1",IO%IU6,'ICNTR')
+        ENDDO spinor1
+        ! CCX_2019-05-06: [end] end normal routine.
+
+        ELSE ! CCX_2019-05-06: quantization axis does not lies along z axis, do special projection routine.
+        ! CCX_2019-05-06: generate spinor eigenvectors.
+        ! CCX_2019-06-10: renormalize spin quantization axis
+          xnorm=SQRT(proj_s_qaxis(1,ICNTR)*proj_s_qaxis(1,ICNTR)+proj_s_qaxis(2,ICNTR)*proj_s_qaxis(2,ICNTR)+proj_s_qaxis(3,ICNTR)*proj_s_qaxis(3,ICNTR))
+          proj_s_qaxis(1,ICNTR)=proj_s_qaxis(1,ICNTR)/xnorm
+          proj_s_qaxis(2,ICNTR)=proj_s_qaxis(2,ICNTR)/xnorm
+          proj_s_qaxis(3,ICNTR)=proj_s_qaxis(3,ICNTR)/xnorm
+
+          IF (proj_s(ICNTR)==1) THEN ! up channel
+              FAC(1)=(1.0d0/SQRT(1+proj_s_qaxis(3,ICNTR)))*(proj_s_qaxis(3,ICNTR)+1)*CMPLX(1.0d0,0.0d0,q)
+              FAC(2)=(1.0d0/SQRT(1+proj_s_qaxis(3,ICNTR)))*CMPLX(proj_s_qaxis(1,ICNTR),proj_s_qaxis(2,ICNTR),q)
+              NPROJ=NPROJ+1
+          ELSE ! down channel
+              FAC(1)=(1.0d0/SQRT(1-proj_s_qaxis(3,ICNTR)))*(proj_s_qaxis(3,ICNTR)-1)*CMPLX(1.0d0,0.0d0,q)
+              FAC(2)=(1.0d0/SQRT(1-proj_s_qaxis(3,ICNTR)))*CMPLX(proj_s_qaxis(1,ICNTR),proj_s_qaxis(2,ICNTR),q)
+              NPROJ=NPROJ+1
+          ENDIF
+
+          ! 2020-06-15 CCX: we no longer need ISPINOR loop since we are using full spinor guiding functions.
+          !spinor: DO ISPINOR=1,WDES%NRSPINORS
+           ! setup the Ylm rotation matrix in accordance with proj_z and proj_x
+          CALL SETROTYLM(proj_x(:,ICNTR),proj_z(:,ICNTR),LMAX,ROTYLM)
+#ifdef debug
+            IF (IO%IU6>=0) THEN
+               WRITE(*,'(I4,3F14.7)') ICNTR,proj_site(1:3,ICNTR)
+               DO N=10,MIN((LMAX+1)**2,16)
+                  WRITE(*,'(9F10.5)') (ROTYLM(N,M),M=10,MIN((LMAX+1)**2,16))
+               ENDDO
+            ENDIF
+#endif
+          ! translate between VASP and the orbital definition of wannier90
+          CALL WANNIER90_ORBITAL_DEFINITIONS(proj_l(ICNTR),proj_m(ICNTR),HYBRID_ORBITAL)
+
+          ! setup the radial functions (real space)
+          CALL SETRGRID(RSTART/proj_zona(ICNTR),REND,H,R)
+          ALLOCATE(FTMP(R%NMAX),FR(R%NMAX,LMAX+1))
+          ALLOCATE(FGTMP(NMAX,5),FG(NMAX,5,LMAX+1))
+
+          ! For now we use the same radial function for all L
+          DO L=0,LMAX
+             CALL RADIAL_FUNCTION(proj_radial(ICNTR),R,proj_zona(ICNTR),FTMP)
+             CALL BESSEL_TRANSFORM_RADIAL_FUNCTION(L,R,FTMP,REAL(SQRT(2._q*INFO%ENMAX/HSQDTM)/NMAX,KIND=q),FGTMP)
+             FR(:,L+1)=FTMP; FG(:,:,L+1)=FGTMP
+          ENDDO
+
+         !        CALL START_TIMING("T2")
+          ! runs over all k-points
+          kpoints : DO NKI=1,num_kpts
+             CALL CALC_OVERLAP_GN_ALL( &
+            &   LMAX,FG,proj_site(:,ICNTR),W,kpt_latt(:,NKI),ISP,FAC,P,CQIJ,LATT_CUR,T_INFO,A)
+             ! and rotate them in accordance with proj_z and proj_x
+             AP=0
+             DO M=1,WDES%NB_TOT
+             DO N=1,(LMAX+1)**2
+                DO NP=1,(LMAX+1)**2
+                   AP(M,N)=AP(M,N)+A(M,NP)*ROTYLM(N,NP)
+                ENDDO
+             ENDDO
+             ENDDO
+#ifdef debug
+               IF (IO%IU6>=0) THEN
+                  WRITE(*,'(I4,3F14.7)') NKI,kpt_latt(1:3,NKI)
+                  DO M=1,WDES%NB_TOT
+                     WRITE(*,'(4(2F14.7,2X))') (A(M,N),N=1,4)
+                  ENDDO
+                  WRITE(*,*)
+                  DO M=1,WDES%NB_TOT
+                     WRITE(*,'(4(2F14.7,2X))') (AP(M,N),N=1,4)
+                  ENDDO
+                  WRITE(*,*)
+               ENDIF
+#endif
+               ! Make the desired linear combinations
+               MI=0
+               DO M=1,WDES%NB_TOT
+                  IF (EXCLUDE_BAND(M)) CYCLE
+                  CPROJ=0
+                  DO N=1,(LMAX+1)**2
+                     CPROJ=CPROJ+AP(M,N)*HYBRID_ORBITAL(N)
+                  ENDDO
+                  MI=MI+1
+                  A_matrix(MI,NPROJ,NKI,ISP)=CPROJ
+               ENDDO
+
          ENDDO kpoints
 
          DEALLOCATE(FTMP,FR,FGTMP,FG)
 
-         IF (IO%IU0>=0) WRITE(IO%IU0,'(X,A,I3,A)') 'Projection ',NPROJ,' done.'
-!        CALL STOP_TIMING("T2",IO%IU6,'  OVL')
-!        CALL STOP_TIMING("T1",IO%IU6,'ICNTR')
+         !  IF (IO%IU0>=0) WRITE(IO%IU0,'(X,A,I3,A,I3,A)') 'Spin channel',ISPINOR,' done.'
+         !        CALL STOP_TIMING("T2",IO%IU6,'  OVL')
+         !        CALL STOP_TIMING("T1",IO%IU6,'ICNTR')
+      !ENDDO spinor
+          IF (IO%IU0>=0) WRITE(IO%IU0,'(X,A,I3,A,I3,A)') '* Projection [',NPROJ,'/',num_wann,'] done. [axis mod] *'
+        ENDIF ! quantization IF
       ENDDO sites
-      ENDDO spinor
 
       DEALLOCATE(A,AP,ROTYLM,HYBRID_ORBITAL)
 
@@ -733,20 +1205,21 @@
          IF (IO%IU0>=0) WRITE(*,*) 'MLWF_WANNIER90: ERROR: number of projections not equal to num_wann',NPROJ,num_wann
          STOP
       ENDIF
-
+      IF (IO%IU0>=0) WRITE(IO%IU0,*) "*            AMN calculated.            *"
       ENDIF ! finished computing A_matrix
 
+      IF (WRITE_AMN) THEN
       ! write A_matrix to file
       LUSE_BLOCH_PHASES=.FALSE.
       IF (NPROJ/=0) THEN
-         IF (IO%IU6>=0.AND.WRITE_MMN_AMN.AND..NOT.READ_AMN) THEN
+         IF (IO%IU6>=0.AND.WRITE_AMN.AND..NOT.READ_AMN) THEN
             IF (WDES%ISPIN==1) THEN
                OPEN(UNIT=99,FILE=seed_name//'.amn',STATUS='REPLACE')
             ELSE
-               OPEN(UNIT=99,FILE=seed_name//'.'//SP(ISP)//'.amn',STATUS='REPLACE')            
+               OPEN(UNIT=99,FILE=seed_name//'.'//SP(ISP)//'.amn',STATUS='REPLACE')
             ENDIF
             WRITE(99,'(A)') 'File generated by VASP: '//INFO%SZNAM1
-            WRITE(99,'(3I12)') num_bands,num_kpts,NPROJ     
+            WRITE(99,'(3I12)') num_bands,num_kpts,NPROJ
             DO NKI=1,num_kpts
             DO N=1,NPROJ
             DO M=1,num_bands
@@ -757,8 +1230,14 @@
             CLOSE(99)
          ENDIF
       ELSE
-         ! read use_bloch_phases from the .win file
-         OPEN(UNIT=99,FILE=seed_name//'.win',STATUS='OLD')
+	 ! 2022-04-04 CCX: added for spin polarized calculations
+         IF ((.not. spinors) .AND. (WDES%ISPIN==2)) THEN
+           ! read use_bloch_phases from the .win file
+	   OPEN(UNIT=99,FILE=seed_name//'.'//SP(ISP)//'.win',STATUS='OLD')
+	 ELSE
+           OPEN(UNIT=99,FILE=seed_name//'.win',STATUS='OLD')
+	 ENDIF
+
          CALL RDATAB(.FALSE.,seed_name//'.win',99,'use_bloch_phases','=','#',';','L', &
         &            IDUM,RDUM,CDUM,LUSE_BLOCH_PHASES,CHARAC,N,1,IERR)
          IF (((IERR/=0).AND.(IERR/=3)).OR. &
@@ -773,6 +1252,7 @@
             LUSE_BLOCH_PHASES=.TRUE.
          ENDIF
          CLOSE(99)
+
       ENDIF
       ! if we do not have starting projections and
       ! use_bloch_phases=.false. in the .win file
@@ -781,17 +1261,22 @@
       IF (NPROJ==0.AND.(.NOT.LUSE_BLOCH_PHASES).AND.WANNIER90RUN()) THEN
 !
       ENDIF
+      ! 2020-07-04
+      ENDIF
+
 
       ! and ...
       ! we should write the eigenvalues onto seed_name.eig
-      IF (IO%IU6>=0.AND.WRITE_MMN_AMN) THEN
+      IF (IO%IU6>=0.AND.WRITE_EIG) THEN
          IF (WDES%ISPIN==1) THEN
             OPEN(UNIT=99,FILE=seed_name//'.eig',STATUS='REPLACE')
          ELSE
-            OPEN(UNIT=99,FILE=seed_name//'.'//SP(ISP)//'.eig',STATUS='REPLACE')            
+            OPEN(UNIT=99,FILE=seed_name//'.'//SP(ISP)//'.eig',STATUS='REPLACE')
          ENDIF
       ENDIF
 
+      ! actually write eig file
+      IF (WRITE_EIG) THEN
       DO NKI=1,num_kpts
          NK=KPOINT_IN_FULL_GRID(kpt_latt(:,NKI),KPOINTS_FULL)
          NK=KPOINTS_FULL%NEQUIV(NK)
@@ -800,10 +1285,89 @@
             IF (EXCLUDE_BAND(M)) CYCLE
             MI=MI+1
             eigenvalues(MI,NKI,ISP)=REAL(W%CELTOT(M,NK,ISP))
-            IF (IO%IU6>0.AND.WRITE_MMN_AMN) WRITE(99,'(2I12,F22.12)') MI,NKI,REAL(W%CELTOT(M,NK,ISP))
+            IF (IO%IU6>0.AND.WRITE_EIG) WRITE(99,'(2I12,F22.12)') MI,NKI,REAL(W%CELTOT(M,NK,ISP))
          ENDDO
       ENDDO
-      IF (IO%IU6>=0.AND.WRITE_MMN_AMN) CLOSE(99)
+
+
+      IF (IO%IU6>=0.AND.WRITE_EIG) CLOSE(99)
+      IF (IO%IU0>=0.AND.WRITE_EIG) WRITE(IO%IU0,*) "*            EIG written.               *"
+      !2020-07-04
+      ENDIF
+
+      ! 2022-05-31 CCX: do we want to calculate uHu matrix
+      ! IF (IO%IU0>=0.AND.WRITE_UHU) WRITE(IO%IU0,*) "*           WRITTING UHU                *"
+      IF (IO%IU6>=0.AND.WRITE_UHU) THEN
+        IF (UHU_FMTED) THEN
+          OPEN(UNIT=99,FILE=seed_name//'.uHu',FORM="FORMATTED",STATUS='REPLACE')
+          UHU_header = 'File generated by VASP: '//INFO%SZNAM1
+          WRITE(99,'(A)') UHU_header
+          WRITE(99,'(3I12)') num_bands,num_kpts,nntot
+        ELSE
+          OPEN(UNIT=99,FILE=seed_name//'.uHu',FORM="UNFORMATTED",STATUS='REPLACE')
+          UHU_header = 'File generated by VASP: '//INFO%SZNAM1
+          WRITE(99) UHU_header
+          WRITE(99) num_bands,num_kpts,nntot
+        ENDIF
+      ENDIF
+
+      ALLOCATE(uHu_matrix(num_bands,num_bands,num_kpts,nntot,nntot,WDES%ISPIN))
+      UHU_matrix = 0
+
+
+      IF (WRITE_UHU) THEN
+      ! runs over all k-points
+      uhu_ki_loop: DO NKI=1,num_kpts
+        ! runs over the number of nearest-neighbours of k_b1
+        uhu_kj_loop: DO NB1=1,nntot
+          ! runs over the number of nearest-neighbours of k_b2
+          uhu_kk_loop: DO NB2=1,nntot
+            ! loop over bands
+            uhu_m_loop: DO MI=1,num_bands!,WDES%NB_TOT
+              uhu_n_loop: DO NI=1,num_bands!,WDES%NB_TOT
+                ! loop over dummy index l
+                uhu_l_loop: DO LL=1,num_bands
+                  ! UHU_matrix(MI,NI,NKI,NB1,NB2,ISP)=SUM(CONJG(M_matrix(NI,:,NB1,NKI,ISP))*eigenvalues(:,NKI,ISP)*M_matrix(:,MI,NB2,NKI,ISP))
+                  ! The following equation is obtained from: https://wannier-berri.org/docs/mmn2uHu.html
+                  ! UHU = < u_m,k+b1 | H_k | u_n,k+b2 >
+                  !     = (M_{lm}^{b1}(k))^* E_l(k) M_{ln}^{b2}(k)
+                  ! The order here seems to be messed up (NI and MI). This is the order that I find to be sort of working.
+                  ! TODO: double check this
+                  UHU_matrix(NI,MI,NKI,NB1,NB2,ISP)=UHU_matrix(NI,MI,NKI,NB1,NB2,ISP)+CONJG(M_matrix(LL,NI,NB1,NKI,ISP))*REAL(eigenvalues(LL,NKI,ISP))*M_matrix(LL,MI,NB2,NKI,ISP)
+                ENDDO uhu_l_loop
+              ENDDO uhu_n_loop
+            ENDDO uhu_m_loop
+          ENDDO uhu_kk_loop
+        ENDDO uhu_kj_loop
+      ENDDO uhu_ki_loop
+
+      ! write UHU to file
+      ! note that we need to have loops over b-vectors
+      ! because this is how it's read in postw90.x...
+        DO NKI=1,num_kpts
+          DO NB2=1,nntot
+            DO NB1=1,nntot
+              IF (UHU_FMTED) THEN
+              DO MI=1,num_bands
+                DO NI=1,num_bands
+                    IF (IO%IU6>=0.AND.WRITE_UHU) WRITE(99,'(2ES20.10)') (UHU_matrix(MI,NI,NKI,NB1,NB2,ISP))
+                ENDDO
+              ENDDO
+              ELSE
+                IF (IO%IU6>=0.AND.WRITE_UHU) WRITE(99) ((UHU_matrix(MI,NI,NKI,NB1,NB2,ISP), NI=1,num_bands),MI=1,num_bands)
+              ENDIF
+            ENDDO
+          ENDDO
+        ENDDO
+
+
+      ENDIF
+      IF (IO%IU6>=0.AND.WRITE_UHU) CLOSE(99)
+      IF (IO%IU0>=0.AND.WRITE_UHU) WRITE(IO%IU0,*) "*            UHU written.               *"
+      DEALLOCATE(uHu_matrix)
+      ! 2022-05-31 CCX: end uHu output
+
+
 
       ! and last but not least we may need to write UNK files
       ! which is a bit tricky since the bands at a certain k-point
@@ -811,41 +1375,65 @@
       ! to make matters worse, WANNIER90 works with the full k-mesh
       ! whereas VASP uses the symmetry reduced one.
  100  FORMAT('UNK',I5.5,'.',I1)
+ 101  FORMAT('UNK',I5.5,'.NC')
       IF (WRITE_UNK) THEN
          DO NKI=1,num_kpts
             IF (IO%IU6>=0) THEN
+               IF (W%WDES%NRSPINORS/=1) THEN
+                 WRITE(UNKFILE,101) NKI
+               ELSE
                WRITE(UNKFILE,100) NKI,ISP
+               ENDIF
+               IF (UNK_FMTED) THEN
+                 OPEN(UNIT=99,FILE=UNKFILE,FORM='FORMATTED',STATUS='REPLACE')
+                 IF (REDUCE_UNK) THEN
+                   WRITE(99,*) (W%WDES%GRID%NGX+1)/2,(W%WDES%GRID%NGY+1)/2,(W%WDES%GRID%NGZ+1)/2,NKI,num_bands
+                 ELSE
+                   WRITE(99,*) W%WDES%GRID%NGX,W%WDES%GRID%NGY,W%WDES%GRID%NGZ,NKI,num_bands
+                 ENDIF
+               ELSE
                OPEN(UNIT=99,FILE=UNKFILE,FORM='UNFORMATTED',STATUS='REPLACE')
+                 IF (REDUCE_UNK) THEN
+                   WRITE(99) (W%WDES%GRID%NGX+1)/2,(W%WDES%GRID%NGY+1)/2,(W%WDES%GRID%NGZ+1)/2,NKI,num_bands
+                 ELSE
                WRITE(99) W%WDES%GRID%NGX,W%WDES%GRID%NGY,W%WDES%GRID%NGZ,NKI,num_bands
             ENDIF
-            CALL WRITE_WAVE_FUNCTIONS(W,kpt_latt(:,NKI),ISP,EXCLUDE_BAND,P,LATT_CUR,99)   
+               ENDIF
+            ENDIF
+            CALL WRITE_WAVE_FUNCTIONS(W,kpt_latt(:,NKI),ISP,EXCLUDE_BAND,P,LATT_CUR,UNK_FMTED,REDUCE_UNK,99)
             IF (IO%IU6>=0) CLOSE(99)
          ENDDO
+      IF (IO%IU0>=0) WRITE(IO%IU0,*) "*            UNK written.               *"
       ENDIF
+      IF (IO%IU0>=0) WRITE(IO%IU0,*) "*---------------------------------------*"
 
-      ENDDO spin
-   
       ! Write information on seed_name.win
       IF (IO%IU6>=0) THEN
+         IF ((.NOT. spinors) .AND. (WDES%ISPIN==2)) THEN
+            OPEN(UNIT=99,FILE=seed_name//'.'//SP(ISP)//'.win',STATUS='OLD')
+!         ELSEIF ((.NOT. spinors) .AND. (WDES%RSPIN==1)) THEN
+!            OPEN(UNIT=99,FILE=seed_name//'.win',STATUS='OLD')
+         ELSE
          OPEN(UNIT=99,FILE=seed_name//'.win',STATUS='OLD')
-         
+         ENDIF
+
          IF (spinors) THEN
             CALL OCCURS_IN_FILE(99,'spinors',N)
             IF (N==0) THEN
                WRITE(99,'(/A)') 'spinors = .true.'
             ELSE
                WRITE(*,'(A,/A/)') 'MLWF_WANNIER90: WARNING: '//seed_name//'.win seems to contains', &
-              &                  'the SPINORS tag, I hope it applies to the current setup ...'            
+              &                  'the SPINORS tag, I hope it applies to the current setup ...'
             ENDIF
          ENDIF
-             
+
          CALL OCCURS_IN_FILE(99,'unit_cell_cart',N)
          IF (N==0) THEN
             WRITE(99,'(/A)') 'begin unit_cell_cart'
             WRITE(99,'(3F14.7)') real_lattice(1,:)
             WRITE(99,'(3F14.7)') real_lattice(2,:)
             WRITE(99,'(3F14.7)') real_lattice(3,:)
-            WRITE(99,'(A)')  'end unit_cell_cart'            
+            WRITE(99,'(A)')  'end unit_cell_cart'
          ELSE
             WRITE(*,'(A,/A/)') 'MLWF_WANNIER90: WARNING: '//seed_name//'.win seems to contains', &
            &                  'a UNIT_CELL_CART block already, I hope it applies to the current setup ...'
@@ -862,7 +1450,7 @@
                WRITE(99,'(A)')  'end atoms_cart'
             ELSE
                WRITE(*,'(A,/A/)') 'MLWF_WANNIER90: WARNING: '//seed_name//'.win seems to contains', &
-              &                  'a ATOMS_CART block already, I hope it applies to the current setup ...'              
+              &                  'a ATOMS_CART block already, I hope it applies to the current setup ...'
             ENDIF
          ELSE
             WRITE(*,'(A,/A/)') 'MLWF_WANNIER90: WARNING: '//seed_name//'.win seems to contains', &
@@ -919,9 +1507,9 @@
               &                 U_matrix(:,:,:,1),U_matrix_opt(:,:,:,1),lwindow(:,:,1), &
               &                 wann_centres(:,:,1),wann_spreads(:,1),spread(:,1))
            ELSE
-               DO ISP=1,WDES%ISPIN
+               !DO ISP=1,WDES%ISPIN
                ! copy wannier90.win to wannier90.(up/dn).win
-               CALL COPYFILE(seed_name//'.win',seed_name//'.'//SP(ISP)//'.win')
+               !CALL COPYFILE(seed_name//'.win',seed_name//'.'//SP(ISP)//'.win')
 
                ! run wannier90 for spin component ISP
                CALL wannier_run(seed_name//'.'//SP(ISP), &
@@ -932,7 +1520,7 @@
               &                 U_matrix(:,:,:,ISP),U_matrix_opt(:,:,:,ISP),lwindow(:,:,ISP), &
               &                 wann_centres(:,:,ISP),wann_spreads(:,ISP),spread(:,ISP))
 
-               ENDDO
+               !ENDDO
             ENDIF
          ENDIF
 #endif
@@ -951,17 +1539,25 @@
          !possibly write UWAN files
          IF (LWRITE_WANPROJ .AND. IO%IU6>=0) THEN
             WRITE(IO%IU0,*)' Writing '//WANPROJFILE//' file'
-            CALL WRITE_WANPROJ_FILE(WDES)                  
-         ENDIF 
+            CALL WRITE_WANPROJ_FILE(WDES)
+         ENDIF
       ENDIF
 
-      DEALLOCATE(atom_symbols,atoms_cart)
       DEALLOCATE(nnlist,nncell)
       DEALLOCATE(proj_site,proj_l,proj_m,proj_radial,proj_z,proj_x,proj_zona,exclude_bands)
+#ifdef VASP2WANNIER90v2
+! CCX_2019-05-05: deall
+      DEALLOCATE(proj_s,proj_s_qaxis)
+#endif
+
+      DEALLOCATE(atom_symbols,atoms_cart)
       DEALLOCATE(EXCLUDE_BAND)
       DEALLOCATE(M_matrix,A_matrix,eigenvalues)
       DEALLOCATE(S)
 
+      ! 2020-06-27 CCX: I moved this here so we can have total control of collinear spin channels.
+      ENDDO spin
+
       IF (ASSOCIATED(R%R)) THEN
          DEALLOCATE(R%R); NULLIFY(R%R)
       ENDIF
@@ -974,7 +1570,7 @@
 
 
 !******************** SUBROUTINE MLWF_ROTATE_ORBITALS ******************
-! 
+!
 !***********************************************************************
       SUBROUTINE MLWF_ROTATE_ORBITALS( &
      &   WDES,W,KPOINTS,GRID,T_INFO,P,NONL_S,SYMM,LATT_CUR,IO)
@@ -1010,8 +1606,8 @@
          CALL KPAR_SYNC_ALL(WDES,W)
          CALL RE_GEN_LAYOUT( GRID, WDES, KPOINTS, LATT_CUR, LATT_CUR,-1, IO%IU0)
          CALL REALLOCATE_WAVE( W, GRID, WDES, NONL_S, T_INFO, P, LATT_CUR)
-      ENDIF     
-      
+      ENDIF
+
       CALL MLWF_ROTATE_ORBITALS_FULLK(WDES,W)
 
       RETURN
@@ -1019,7 +1615,7 @@
 
 
 !******************** SUBROUTINE MLWF_ROTATE_ORBITALS_FULLK ************
-! 
+!
 !***********************************************************************
       SUBROUTINE MLWF_ROTATE_ORBITALS_FULLK(WDES,W)
       USE dfast
@@ -1035,7 +1631,7 @@
       INTEGER ISP,NK,NKP,NW,NB,NBEXCL,NBwin
       COMPLEX(q) CTMP
       GDEF, ALLOCATABLE :: U(:,:)
- 
+
       CALL CHECK_FULL_KPOINTS
 
       IF ((.NOT.ALLOCATED(U_matrix)).OR.(.NOT.ALLOCATED(U_matrix_opt))) THEN
@@ -1056,7 +1652,7 @@
       ENDDO
       IF ((NB+NBEXCL)/=WDES%NB_TOT) THEN
          WRITE(*,*) 'MLWF_ROTATE_ORBITALS_FULLK: ERROR: inconsistent number of bands:', &
-        &   NB+NBEXCL,WDES%NB_TOT 
+        &   NB+NBEXCL,WDES%NB_TOT
       ENDIF
 
       ALLOCATE(U(WDES%NB_TOT,WDES%NB_TOT))
@@ -1066,7 +1662,7 @@
             ! find the corresponding entry in KPOINTS_FULL_ORIG, that contains
             ! the set of k-points used in the computation of the rotation matrices
             DO NKP=1,KPOINTS_FULL_ORIG%NKPTS
-               IF (LIDENTICAL_KPOINT(KPOINTS_FULL%VKPT(:,NK),KPOINTS_FULL_ORIG%VKPT(:,NKP))) exit 
+               IF (LIDENTICAL_KPOINT(KPOINTS_FULL%VKPT(:,NK),KPOINTS_FULL_ORIG%VKPT(:,NKP))) exit
             ENDDO
             IF (NKP>KPOINTS_FULL_ORIG%NKPTS) THEN
                WRITE(*,*) 'MLWF_ROTATE_ORBITALS_FULLK: ERROR: no matching k-point found in KPOINTS_FULL_ORIG',NK
@@ -1116,10 +1712,10 @@
 
       RETURN
       END SUBROUTINE MLWF_ROTATE_ORBITALS_FULLK
- 
+
 
 !******************** SUBROUTINE MLWF_ROTATE_ORBITALS_NOSYMM ***********
-! 
+!
 !***********************************************************************
       SUBROUTINE MLWF_ROTATE_ORBITALS_NOSYMM(WDES,W)
       USE dfast
@@ -1135,7 +1731,7 @@
       INTEGER ISP,NK,NKP,NW,NB,NBEXCL,NBwin
       COMPLEX(q) CTMP
       GDEF, ALLOCATABLE :: U(:,:)
- 
+
       CALL CHECK_FULL_KPOINTS
 
       IF ((.NOT.ALLOCATED(U_matrix)).OR.(.NOT.ALLOCATED(U_matrix_opt))) THEN
@@ -1156,7 +1752,7 @@
       ENDDO
       IF ((NB+NBEXCL)/=WDES%NB_TOT) THEN
          WRITE(*,*) 'MLWF_ROTATE_ORBITALS_NOSYMM: ERROR: inconsistent number of bands:', &
-        &   NB+NBEXCL,WDES%NB_TOT 
+        &   NB+NBEXCL,WDES%NB_TOT
       ENDIF
 
       ALLOCATE(U(WDES%NB_TOT,WDES%NB_TOT))
@@ -1169,7 +1765,7 @@
             ! find the corresponding entry in KPOINTS_FULL, that contains
             ! the set of k-points used in the computation of the rotation matrices
             DO NKP=1,KPOINTS_FULL%NKPTS
-               IF (LIDENTICAL_KPOINT(WDES%VKPT(:,NK),KPOINTS_FULL%VKPT(:,NKP))) exit 
+               IF (LIDENTICAL_KPOINT(WDES%VKPT(:,NK),KPOINTS_FULL%VKPT(:,NKP))) exit
             ENDDO
             IF (NKP>KPOINTS_FULL%NKPTS) THEN
                WRITE(*,*) 'MLWF_ROTATE_ORBITALS: ERROR: no matching k-point found in KPOINTS_FULL',NK
@@ -1294,7 +1890,7 @@
       INTEGER ISP,IK,NK,IB,ISPINOR,IBG
       INTEGER IDIR,J,IDELTA,IORDER,ISGN
       REAL(q) K0(3),K(3),DK(3),KP(3)
-      COMPLEX(q), ALLOCATABLE :: CPHASE(:) 
+      COMPLEX(q), ALLOCATABLE :: CPHASE(:)
       LOGICAL LPHASE
 
       IORDER=4
@@ -1332,7 +1928,7 @@
                IF(IBG>MLWF_num_wann) EXIT
 #endif
 
-               CALL W1_COPY(ELEMENT(W,WDESK,IB,ISP),WK) 
+               CALL W1_COPY(ELEMENT(W,WDESK,IB,ISP),WK)
                CALL FFTWAV_W1(WK)
 
                IF (LPHASE) CALL APPLY_PHASE(WDESK%GRID,CPHASE,WK%CR,WK%CR)
@@ -1356,7 +1952,7 @@
          ENDDO dir
 
       ENDDO kpoint
-      ENDDO spin 
+      ENDDO spin
 
       RETURN
       END SUBROUTINE MLWF_DPSI_DK
@@ -1368,11 +1964,11 @@
 ! YLM(:,1)     -> s
 ! YLM(:,2:4)   -> p:= y, z, x
 ! YLM(:,5:9)   -> d:= xy, yz, z2, xz, x2
-! YLM(:,10:16) -> f:= y(3x2-y2), xyz, yz2, z3, xz2, z(x2-y2), x(x2-3y2)           
+! YLM(:,10:16) -> f:= y(3x2-y2), xyz, yz2, z3, xz2, z(x2-y2), x(x2-3y2)
 !
 ! This routine provides a translation between the aforementioned and
 ! the orbital definitions used in wannier90
-! 
+!
 !***********************************************************************
       SUBROUTINE WANNIER90_ORBITAL_DEFINITIONS( &
      &   L,M,HYBRID_ORBITAL &
@@ -1381,16 +1977,16 @@
       INTEGER L,M
       REAL(q) HYBRID_ORBITAL(:)
       ! local variables
-      
+
       ! we should be able to deal with anything up to and including L=3
       IF (SIZE(HYBRID_ORBITAL)<16) THEN
          WRITE(*,*) 'WANNIER90_ORBITAL_DEFINITIONS: ERROR: HYBRID_ORBITAL array too small', &
         &   SIZE(HYBRID_ORBITAL)
          STOP
       ENDIF
-      
+
       HYBRID_ORBITAL=0
-      
+
       SELECT CASE(L)
          CASE(0)
             ! s-function
@@ -1578,15 +2174,15 @@
             WRITE(*,'(A,I2,A,I2,A)')  &
            &   'WANNIER90_ORBITAL_DEFINITIONS: ERROR: L=',L,' M=',M,' not implemented'
             STOP
-         
+
       END SELECT
-      
+
       RETURN
       END SUBROUTINE WANNIER90_ORBITAL_DEFINITIONS
 
 
 !******************** SUBROUTINE SETROTYLM *****************************
-!           
+!
 !***********************************************************************
       SUBROUTINE SETROTYLM( &
      & XIN,ZIN,LMAX,ROTYLM &
@@ -1610,7 +2206,7 @@
       REAL(q), ALLOCATABLE :: YLM(:,:),YLMP(:,:)
       REAL(q), ALLOCATABLE :: WEIGHT(:),ABSCIS(:)
       EXTERNAL GAUSSI2
-      
+
       X=XIN; Z=ZIN
 
       LMMAX=(LMAX+1)**2
@@ -1633,7 +2229,7 @@
       XDOTZ=X(1)*Z(1)+X(2)*Z(2)+X(3)*Z(3)
       IF (ABS(XDOTZ)>TINY) THEN
          WRITE(*,*) 'SETROTYLM: ERROR: X and Z are not orthogonal (enough):',ABS(XDOTZ)
-         STOP         
+         STOP
       ENDIF
       ! y=Z \times X
       Y(1)=(Z(2)*X(3)-X(2)*Z(3))
@@ -1646,13 +2242,13 @@
 !     WRITE(*,'(3F10.5)') U(1,:)
 !     WRITE(*,'(3F10.5)') U(2,:)
 !     WRITE(*,'(3F10.5)') U(3,:)
-! test      
+! test
       SCALE=2*SQRT(PI) ! 1/Y00
 
 !========================================================================
 ! number of theta and phi pivot points to perform angular integration
-! since Exc=f(a*Yllmax,m) we need more pivot points than theoretically 
-! needed to integrate Yllmax,m. 
+! since Exc=f(a*Yllmax,m) we need more pivot points than theoretically
+! needed to integrate Yllmax,m.
 ! the factor 2 is the minium, 3 is more accurate
 !========================================================================
       PHPTS=3*(LMAX+1)
@@ -1660,9 +2256,9 @@
       NPTS=PHPTS*THPTS
       DELTAPHI=REAL(2_q*PI/PHPTS,KIND=q)
       ! allocate arrays
-      ALLOCATE(XYZPTS(NPTS,3),UXYZPTS(NPTS,3),RADPTS(NPTS,2),WEIGHT(THPTS),ABSCIS(THPTS), & 
+      ALLOCATE(XYZPTS(NPTS,3),UXYZPTS(NPTS,3),RADPTS(NPTS,2),WEIGHT(THPTS),ABSCIS(THPTS), &
      &     YLM(NPTS,LMMAX),YLMP(NPTS,LMMAX))
-      
+
       ! set phi positions, equally spaced
       RADPTS=0; WEIGHT=0; ABSCIS=0
       DO I=1,PHPTS
@@ -1689,9 +2285,9 @@
       DO I=1,NPTS
          UXYZPTS(I,1)=U(1,1)*XYZPTS(I,1)+U(1,2)*XYZPTS(I,2)+U(1,3)*XYZPTS(I,3)
          UXYZPTS(I,2)=U(2,1)*XYZPTS(I,1)+U(2,2)*XYZPTS(I,2)+U(2,3)*XYZPTS(I,3)
-         UXYZPTS(I,3)=U(3,1)*XYZPTS(I,1)+U(3,2)*XYZPTS(I,2)+U(3,3)*XYZPTS(I,3)         
+         UXYZPTS(I,3)=U(3,1)*XYZPTS(I,1)+U(3,2)*XYZPTS(I,2)+U(3,3)*XYZPTS(I,3)
       ENDDO
-      
+
       YLMP=0
       CALL SETYLM(LMAX,NPTS,YLMP,UXYZPTS(:,1),UXYZPTS(:,2),UXYZPTS(:,3))
 
@@ -1707,7 +2303,7 @@
             ROTYLM(LMP,LM)=ROTYLM(LMP,LM)+YLMP(NP,LMP)*YLM(NP,LM)*SIM_FAKT
          ENDDO
          ENDDO
-         
+
       ENDDO points
 
       DEALLOCATE(XYZPTS,UXYZPTS,RADPTS,WEIGHT,ABSCIS,YLM,YLMP)
@@ -1716,7 +2312,7 @@
 
 
 !******************** SUBROUTINE SETRGRID ******************************
-!      
+!
 !***********************************************************************
       SUBROUTINE SETRGRID( &
      & RSTART,REND,H,R &
@@ -1727,9 +2323,9 @@
       REAL(q) RSTART,REND,H
       ! local variables
       INTEGER I
-      
+
       I=0
-      DO 
+      DO
         I=I+1
         IF (RSTART*EXP(H*(I-1))>=REND) EXIT
       ENDDO
@@ -1743,7 +2339,7 @@
       ALLOCATE(R%R(I))
       DO I=1,R%NMAX
          R%R(I)=R%RSTART*EXP(H*(I-1))
-      ENDDO      
+      ENDDO
       R%REND=R%R(R%NMAX)
 
       IF (ASSOCIATED(R%SI)) THEN
@@ -1756,7 +2352,7 @@
 
 
 !******************** SUBROUTINE RADIAL_FUNCTION ***********************
-!      
+!
 !***********************************************************************
       SUBROUTINE RADIAL_FUNCTION( &
      & ITYP,R,ZA,FR &
@@ -1770,7 +2366,7 @@
 
       IF (SIZE(FR)<R%NMAX) THEN
          WRITE(*,*) 'RADIAL_FUNCTION: ERROR: FR too small:',SIZE(FR),R%NMAX
-      ENDIF      
+      ENDIF
       IF (ITYP==1) THEN
          FR(:)=2._q*ZA**(3._q/2._q)*EXP(-ZA*R%R(:))
       ELSEIF (ITYP==2) THEN
@@ -1781,13 +2377,13 @@
       ELSE
          WRITE(*,*) 'RADIAL_FUNCTION: TYPE does not exist',ITYP
       ENDIF
-      
+
       RETURN
       END SUBROUTINE RADIAL_FUNCTION
 
 
 !******************** SUBROUTINE CALC_OVERLAP_GN ***********************
-!      
+!
 !***********************************************************************
       SUBROUTINE CALC_OVERLAP_GN( &
      &   L,FG,POS,W,K,ISP,ISPINOR,P,CQIJ,LATT_CUR,T_INFO,S &
@@ -1811,25 +2407,25 @@
       REAL(q) FG(:,:,:)
       REAL(q) POS(3)
       OVERLAP CQIJ(:,:,:,:)
-      GDEF S(W%WDES%NB_TOT,(L+1)**2)      
+      GDEF S(W%WDES%NB_TOT,(L+1)**2)
       ! local variables
       TYPE(wavespin) WP
       TYPE(wavefuna) WK,WRYlm
       TYPE(wavedes1), TARGET :: WDESK
       TYPE(nonl_struct) NONL_S
-            
+
       TYPE(rotation_handle), POINTER :: ROT_HANDLE
 
       GDEF C
       REAL(q) WSCAL
       INTEGER NK,NB,N,NYLM
-      
+
       WP=W
       WP%WDES=>WDES_FULL_PEAD
-            
+
       CALL CHECK_FULL_KPOINTS
 
-      NULLIFY(ROT_HANDLE)      
+      NULLIFY(ROT_HANDLE)
 
       NYLM=(L+1)**2
 
@@ -1847,7 +2443,7 @@
 
       CALL NONL_ALLOC(NONL_S,T_INFO,P,WP%WDES,.FALSE.)
       CALL SPHER(WP%WDES%GRID,NONL_S,P,WP%WDES,LATT_CUR,1,NK)
-      CALL PHASE(WP%WDES,NONL_S,NK)      
+      CALL PHASE(WP%WDES,NONL_S,NK)
 
       CALL NEWWAVA(WRYlm,WDESK,NYLM)
       WRYlm%CW=0
@@ -1858,7 +2454,7 @@
       ENDDO
 
       ! calculate overlap between Wk and WRYlm: < w_{m,k1} | S | RYlm >
-      S=0    
+      S=0
       DO NB=1,WP%WDES%NBANDS
          DO N=1,NYLM
             C=W1_DOT(ELEMENT(WK,NB),ELEMENT(WRYlm,N),CQIJ)
@@ -1868,21 +2464,201 @@
       ENDDO
 
       CALLMPI( M_sum_g(WDESK%COMM_INTER,S(1,1),WDESK%NB_TOT*NYLM) )
-      
-      ! some deallocation to be done      
+
+      ! some deallocation to be done
       CALL DEALLOCATE_ROT_HANDLE(ROT_HANDLE)
 
       CALL DELWAVA(WRYlm)
-      IF (NK/=KPOINTS_FULL%NEQUIV(NK)) CALL DELWAVA(WK)      
+      IF (NK/=KPOINTS_FULL%NEQUIV(NK)) CALL DELWAVA(WK)
 
       CALL NONL_DEALLOC(NONL_S)
-            
+
       RETURN
       END SUBROUTINE CALC_OVERLAP_GN
 
+!******************** SUBROUTINE CALC_OVERLAP_GN_ALL *******************
+! 2020-06-15 CCX: added to use CONSTRUCT_FUNCTION_RYlm_ALL
+!                 for spin_quantization calculations
+!***********************************************************************
+      SUBROUTINE CALC_OVERLAP_GN_ALL( &
+     &   L,FG,POS,W,K,ISP,SPIN_FAC,P,CQIJ,LATT_CUR,T_INFO,S &
+     &)
+      USE pead
+      USE poscar
+      USE pseudo
+      USE lattice
+      USE full_kpoints
+      USE wave_high
+      USE nonl_high
+      IMPLICIT NONE
+      TYPE(wavespin) W
+      TYPE(potcar) P(:)
+      TYPE(latt) LATT_CUR
+      TYPE(type_info) T_INFO
+      INTEGER L
+      INTEGER ISP
+      ! 2020-06-15 CCX: read in SPIN_FAC
+      COMPLEX(q) SPIN_FAC(2)
+      REAL(q) K(3)
+      REAL(q) FG(:,:,:)
+      REAL(q) POS(3)
+      OVERLAP CQIJ(:,:,:,:)
+      GDEF S(W%WDES%NB_TOT,(L+1)**2)
+      ! local variables
+      TYPE(wavespin) WP
+      TYPE(wavefuna) WK,WRYlm
+      TYPE(wavedes1), TARGET :: WDESK
+      TYPE(nonl_struct) NONL_S
+
+      TYPE(rotation_handle), POINTER :: ROT_HANDLE
+
+      GDEF C
+      REAL(q) WSCAL
+      INTEGER NK,NB,N,NYLM
+
+      WP=W
+      WP%WDES=>WDES_FULL_PEAD
+
+      CALL CHECK_FULL_KPOINTS
+
+      NULLIFY(ROT_HANDLE)
+
+      NYLM=(L+1)**2
+
+      ! search for kpoint k in BZ
+      NK=KPOINT_IN_FULL_GRID(K,KPOINTS_FULL)
+      CALL SETWDES(WP%WDES,WDESK,NK)
+      IF (NK==KPOINTS_FULL%NEQUIV(NK)) THEN
+         ! k is a kpoint in the IBZ
+         WK=ELEMENTS(WP,WDESK,ISP)
+      ELSE
+         ! k is not a kpoint in the IBZ
+         CALL NEWWAVA(WK,WDESK,WDESK%NBANDS)
+         CALL PEAD_WA_ROTATE(WP,P,LATT_CUR,ISP,WK)
+      ENDIF
+
+      CALL NONL_ALLOC(NONL_S,T_INFO,P,WP%WDES,.FALSE.)
+      CALL SPHER(WP%WDES%GRID,NONL_S,P,WP%WDES,LATT_CUR,1,NK)
+      CALL PHASE(WP%WDES,NONL_S,NK)
+
+      CALL NEWWAVA(WRYlm,WDESK,NYLM)
+      WRYlm%CW=0
+      !WRITE(*,*) WRYlm%WDES1%LOVERL,   WRYlm%WDES1%NPROD
+      ! 2020-06-15 CCX: use CONSTRUCT_FUNCTION_RYlm_ALL.
+      CALL CONSTRUCT_FUNCTION_RYlm_ALL(L,FG,LATT_CUR,POS,NONL_S,SPIN_FAC,WRYlm)
+      ! and normalize the functions WRYlm
+      DO N=1,NYLM
+         CALL CNORMN(ELEMENT(WRYlm,N),CQIJ,1,WSCAL)
+      ENDDO
+
+      ! calculate overlap between Wk and WRYlm: < w_{m,k1} | S | RYlm >
+      S=0
+      DO NB=1,WP%WDES%NBANDS
+         DO N=1,NYLM
+            C=W1_DOT(ELEMENT(WK,NB),ELEMENT(WRYlm,N),CQIJ)
+            S(WDESK%NB_LOW+WDESK%NB_PAR*(NB-1),N)=C
+!           WRITE(*,*) WDESK%NB_LOW+WDESK%NB_PAR*(NB-1),N,C
+         ENDDO
+      ENDDO
+
+      CALLMPI( M_sum_g(WDESK%COMM_INTER,S(1,1),WDESK%NB_TOT*NYLM) )
+
+      ! some deallocation to be done
+      CALL DEALLOCATE_ROT_HANDLE(ROT_HANDLE)
+
+      CALL DELWAVA(WRYlm)
+      IF (NK/=KPOINTS_FULL%NEQUIV(NK)) CALL DELWAVA(WK)
+
+      CALL NONL_DEALLOC(NONL_S)
+
+      RETURN
+    END SUBROUTINE CALC_OVERLAP_GN_ALL
+
+!******************** SUBROUTINE CALC_SPN_EXP ***********************
+! 2020-06-15 CCX: a modified version of CALC_OVERLAP_GN
+!                 calculates expectation value of the
+!                 Pauli Matrix. Uses W1_SPN_DOT in wave_high.F
+! Note: This routine only works in serial.
+!***********************************************************************
+      SUBROUTINE CALC_SPN_EXP( &
+     &   W,K,P,CQIJ,LATT_CUR,T_INFO,S &
+     &)
+      USE pead
+      USE poscar
+      USE pseudo
+      USE lattice
+      USE full_kpoints
+      USE wave_high
+      USE nonl_high
+      IMPLICIT NONE
+      TYPE(wavespin) W
+      TYPE(potcar) P(:)
+      TYPE(latt) LATT_CUR
+      TYPE(type_info) T_INFO
+      ! INTEGER L
+      ! INTEGER ISP
+      ! INTEGER ISPINOR
+      REAL(q) K(3)
+      ! REAL(q) FG(:,:,:)
+      ! REAL(q) POS(3)
+      OVERLAP CQIJ(:,:,:,:)
+      GDEF S(W%WDES%NB_TOT,W%WDES%NB_TOT,3)
+      ! local variables
+      TYPE(wavespin) WP
+      TYPE(wavefuna) WK
+      TYPE(wavedes1), TARGET :: WDESK
+
+      TYPE(rotation_handle), POINTER :: ROT_HANDLE
+
+      GDEF C(3)
+      REAL(q) WSCAL
+      INTEGER NK,NB,N,NYLM
+
+      WP=W
+      WP%WDES=>WDES_FULL_PEAD
+
+      CALL CHECK_FULL_KPOINTS
+
+      NULLIFY(ROT_HANDLE)
+
+      ! search for kpoint k in BZ
+      NK=KPOINT_IN_FULL_GRID(K,KPOINTS_FULL)
+      CALL SETWDES(WP%WDES,WDESK,NK)
+      IF (NK==KPOINTS_FULL%NEQUIV(NK)) THEN
+         ! k is a kpoint in the IBZ
+         WK=ELEMENTS(WP,WDESK,1)
+      ELSE
+         ! k is not a kpoint in the IBZ
+         CALL NEWWAVA(WK,WDESK,WDESK%NBANDS)
+         CALL PEAD_WA_ROTATE(WP,P,LATT_CUR,1,WK)
+      ENDIF
+      ! calculate overlap between W1 and W2: < w_{m,k1} | sigma | w_{n,k1} >
+      ! everything is in W1_SPNDOT
+      S=0
+      DO NB=1,WP%WDES%NBANDS
+         DO N=1,WP%WDES%NBANDS
+            C=W1_SPN_DOT(ELEMENT(WK,NB),ELEMENT(WK,N),CQIJ)
+!            WRITE(*,*) N,NB
+            S(WDESK%NB_LOW+WDESK%NB_PAR*(NB-1),WDESK%NB_LOW+WDESK%NB_PAR*(N-1),1)=C(1)
+            S(WDESK%NB_LOW+WDESK%NB_PAR*(NB-1),WDESK%NB_LOW+WDESK%NB_PAR*(N-1),2)=C(2)
+            S(WDESK%NB_LOW+WDESK%NB_PAR*(NB-1),WDESK%NB_LOW+WDESK%NB_PAR*(N-1),3)=C(3)
+
+!           WRITE(*,*) WDESK%NB_LOW+WDESK%NB_PAR*(NB-1),WDESK%NB_LOW+WDESK%NB_PAR*(N-1)
+         ENDDO
+      ENDDO
+      !CALLMPI( M_sum_g(WDESK%COMM_INTER,S(1,1,1),WDESK%NB_TOT*WDESK%NB_TOT*3) )
+      ! some deallocation to be done
+      CALL DEALLOCATE_ROT_HANDLE(ROT_HANDLE)
+      ! CALL DELWAVA(WRYlm)
+      IF (NK/=KPOINTS_FULL%NEQUIV(NK)) CALL DELWAVA(WK)
+      ! CALL NONL_DEALLOC(NONL_S)
+
+      RETURN
+      END SUBROUTINE CALC_SPN_EXP
+
 
 !******************** SUBROUTINE CONSTRUCT_FUNCTION_RYlm ***************
-!      
+!
 !***********************************************************************
       SUBROUTINE CONSTRUCT_FUNCTION_RYlm( &
      &   LMAX,F,LATT_CUR,POS,NONL_S,ISPINOR,WRYLM &
@@ -1913,7 +2689,7 @@
 
       LMMAX=(LMAX+1)**2
 
-      NPL=WRYLM%WDES1%NGVECTOR      
+      NPL=WRYLM%WDES1%NGVECTOR
 
       IF (ISPINOR/=1.AND.(.NOT.WRYLM%WDES1%LNONCOLLINEAR)) THEN
          WRITE(*,*) 'CONSTRUCT_FUNCTION_RYlm: ERROR: ISPINOR=',ISPINOR,' but LNONCOLLINEAR=.FALSE.'
@@ -1926,7 +2702,7 @@
       ! loop over all G-vectors in the basis at this k-point
       DO IND=1,WRYLM%WDES1%NGVECTOR
          N1=MOD(WRYLM%WDES1%IGX(IND)+WRYLM%WDES1%GRID%NGX,WRYLM%WDES1%GRID%NGX)+1
-         N2=MOD(WRYLM%WDES1%IGY(IND)+WRYLM%WDES1%GRID%NGY,WRYLM%WDES1%GRID%NGY)+1 
+         N2=MOD(WRYLM%WDES1%IGY(IND)+WRYLM%WDES1%GRID%NGY,WRYLM%WDES1%GRID%NGY)+1
          N3=MOD(WRYLM%WDES1%IGZ(IND)+WRYLM%WDES1%GRID%NGZ,WRYLM%WDES1%GRID%NGZ)+1
 
          G1=(WRYLM%WDES1%GRID%LPCTX(N1)+WRYLM%WDES1%VKPT(1))
@@ -1985,15 +2761,133 @@
       ENDDO
 
       DEALLOCATE(G,FG,XS,YS,ZS,CFAKTX,YLM)
-      
+
       RETURN
       END SUBROUTINE CONSTRUCT_FUNCTION_RYlm
 
+!******************** SUBROUTINE CONSTRUCT_FUNCTION_RYlm_ALL ***********
+! 2020-06-15 CCX: added to construct full RYlm with 2 spinors.
+!                 the PAW projector are constructed with the new
+!                 spinor wavefunctions.
+!                 Also, see W1_DOT in wave_high.F
+!***********************************************************************
+      SUBROUTINE CONSTRUCT_FUNCTION_RYlm_ALL( &
+     &   LMAX,F,LATT_CUR,POS,NONL_S,SPIN_FAC,WRYLM &
+     &)
+      USE ini
+      USE asa
+      USE pead
+      USE lattice
+      USE constant
+      USE wave_high
+      USE nonl_high
+      IMPLICIT NONE
+      TYPE(latt) LATT_CUR
+      TYPE(wavefuna) WRYLM
+      TYPE (nonl_struct) NONL_S
+      REAL(q) F(:,:,:)
+      REAL(q) POS(3)
+      INTEGER LMAX
+      ! 2020-06-15 CCX: read in SPIN_FAC
+      COMPLEX(q) SPIN_FAC(2)
+      ! local variables
+      ! 2020-06-15 CCX: ISPINOR is now local variable
+      INTEGER ISPINOR
+      TYPE(wavefun1) W1
+      INTEGER N1,N2,N3,IND,NPL,LMMAX,L,M,LM,IG
+      REAL(q) G1,G2,G3,GKX,GKY,GKZ,FACTM,FAKT,FDER
+      REAL(q), ALLOCATABLE :: XS(:),YS(:),ZS(:),YLM(:,:)
+      REAL(q), ALLOCATABLE :: G(:),FG(:)
+      COMPLEX(q) CSET,CGDR
+      COMPLEX(q), ALLOCATABLE :: CFAKTX(:)
+
+      LMMAX=(LMAX+1)**2
+
+      NPL=WRYLM%WDES1%NGVECTOR
+
+      ! 2020-06-15 CCX: deleted this part, usually not usefull.
+      !IF (ISPINOR/=1.AND.(.NOT.WRYLM%WDES1%LNONCOLLINEAR)) THEN
+      !   WRITE(*,*) 'CONSTRUCT_FUNCTION_RYlm: ERROR: ISPINOR=',ISPINOR,' but LNONCOLLINEAR=.FALSE.'
+      !   STOP
+      !ENDIF
+
+      ALLOCATE(G(NPL),FG(NPL))
+      ALLOCATE(XS(NPL),YS(NPL),ZS(NPL),CFAKTX(NPL))
+
+      ! loop over all G-vectors in the basis at this k-point
+      DO IND=1,WRYLM%WDES1%NGVECTOR
+         N1=MOD(WRYLM%WDES1%IGX(IND)+WRYLM%WDES1%GRID%NGX,WRYLM%WDES1%GRID%NGX)+1
+         N2=MOD(WRYLM%WDES1%IGY(IND)+WRYLM%WDES1%GRID%NGY,WRYLM%WDES1%GRID%NGY)+1
+         N3=MOD(WRYLM%WDES1%IGZ(IND)+WRYLM%WDES1%GRID%NGZ,WRYLM%WDES1%GRID%NGZ)+1
+
+         G1=(WRYLM%WDES1%GRID%LPCTX(N1)+WRYLM%WDES1%VKPT(1))
+         G2=(WRYLM%WDES1%GRID%LPCTY(N2)+WRYLM%WDES1%VKPT(2))
+         G3=(WRYLM%WDES1%GRID%LPCTZ(N3)+WRYLM%WDES1%VKPT(3))
+
+         FACTM=1._q
+         IF (WRYLM%WDES1%LGAMMA .AND. (N1/=1 .OR. N2/=1 .OR. N3/=1)) FACTM=SQRT(2._q)
+
+         GKX=(G1*LATT_CUR%B(1,1)+G2*LATT_CUR%B(1,2)+G3*LATT_CUR%B(1,3))*TPI
+         GKY=(G1*LATT_CUR%B(2,1)+G2*LATT_CUR%B(2,2)+G3*LATT_CUR%B(2,3))*TPI
+         GKZ=(G1*LATT_CUR%B(3,1)+G2*LATT_CUR%B(3,2)+G3*LATT_CUR%B(3,3))*TPI
+
+         G(IND)=MAX(SQRT(GKX*GKX+GKY*GKY+GKZ*GKZ),1E-10_q)
+
+         ! phase factor e^{-i(k+G)R} where R is the origin
+         ! of the localized function
+         CGDR=CITPI*(G1*POS(1)+G2*POS(2)+G3*POS(3))
+!        CGDR=0
+         CFAKTX(IND)=FACTM*EXP(-CGDR)
+
+         XS(IND)  =GKX/G(IND)
+         YS(IND)  =GKY/G(IND)
+         ZS(IND)  =GKZ/G(IND)
+      ENDDO
+
+      ALLOCATE(YLM(NPL,LMMAX))
+      ! get me all the Y_lm up to and including l=LMAX
+      CALL SETYLM(LMAX,NPL,YLM,XS,YS,ZS)
+
+      ! Setup the plane wave part of the desired function
+      FAKT= 1/SQRT(LATT_CUR%OMEGA)
+      CSET=CMPLX(0._q,-1._q,q)
+
+!     WRYLM%CW=0
+      LM=1
+      DO L=0,LMAX
+         ! get me the Bessel transform of the radial function
+         DO IG=1,SIZE(G)
+            CALL SPLVAL(G(IG),FG(IG),FDER,F(:,:,L+1),SIZE(F,1),SIZE(F,1))
+         ENDDO
+         DO IND=1,NPL
+            DO M=1,2*L+1
+               ! 2020-06-15 CCX: added ISPINOR loop to construct full spinor WF
+               !                 each part dotted with SPIN_FAC for quant_axis.
+               DO ISPINOR=1,2
+                 WRYLM%CW(IND+(ISPINOR-1)*NPL,LM+M-1)= &
+                &   SPIN_FAC(ISPINOR)*FAKT*(CSET**L)*CFAKTX(IND)*FG(IND)*YLM(IND,LM+M-1)
+               ENDDO
+            ENDDO
+         ENDDO
+         LM=LM+2*L+1
+      ENDDO
+
+      ! and get the projections of RYlm onto the PAW projectors
+      WRYLM%CPROJ=0
+      DO LM=1,LMMAX
+         W1=ELEMENT(WRYLM,LM)
+         CALL PROJ1(NONL_S,WRYLM%WDES1,W1)
+      ENDDO
+
+      DEALLOCATE(G,FG,XS,YS,ZS,CFAKTX,YLM)
+
+      RETURN
+      END SUBROUTINE CONSTRUCT_FUNCTION_RYlm_ALL
 
 !******************** SUBROUTINE WRITE_WAVE_FUNCTIONS ******************
-!      
+!
 !***********************************************************************
-      SUBROUTINE WRITE_WAVE_FUNCTIONS(W,K,ISP,EXCLUDE_BAND,P,LATT_CUR,IU)
+      SUBROUTINE WRITE_WAVE_FUNCTIONS(W,K,ISP,EXCLUDE_BAND,P,LATT_CUR,UNK_FMTED,REDUCE_UNK,IU)
       USE pead
       USE pseudo
       USE lattice
@@ -2005,7 +2899,9 @@
       TYPE(latt) LATT_CUR
       INTEGER ISP,IU
       REAL(q) K(3)
-      LOGICAL EXCLUDE_BAND(W%WDES%NB_TOT) 
+      LOGICAL EXCLUDE_BAND(W%WDES%NB_TOT)
+      LOGICAL UNK_FMTED
+      LOGICAL REDUCE_UNK
      ! local variables
       TYPE(wavespin) WP
       TYPE(wavefuna) WK
@@ -2014,11 +2910,14 @@
 
       TYPE(rotation_handle), POINTER :: ROT_HANDLE
 
-      INTEGER NK,NB,ISTRIP
+      INTEGER NK,NB,ISTRIP,ISPINOR
+      INTEGER IX,IY,IZ,POS_RED
       INTEGER NX,NY,NZ,NC,NGX,NGY,NGZ,IND,I,NWRITTEN
       INTEGER, PARAMETER :: NSTRIP=1
 
       GDEF, ALLOCATABLE :: WVFN(:)
+      GDEF, ALLOCATABLE :: WVFN_RED(:)
+
 
       WP=W
       WP%WDES=>WDES_FULL_PEAD
@@ -2047,9 +2946,16 @@
          CALL NEWWAV(WCOLLECT(NB),WDESK,.TRUE.)
       ENDDO
 
+      ! 2020-06-22 CCX: added for non-collinear WF plot
+      IF (WP%WDES%NRSPINORS/=1) THEN
+        ALLOCATE(WVFN(NGX*NGY*NGZ*2))
+        IF (REDUCE_UNK) ALLOCATE(WVFN_RED((NGX+1)/2*(NGY+1)/2*(NGZ+1)/2*2))
+      ELSE
       ALLOCATE(WVFN(NGX*NGY*NGZ))
+        IF (REDUCE_UNK) ALLOCATE(WVFN_RED((NGX+1)/2*(NGY+1)/2*(NGZ+1)/2))
+      ENDIF
 
-      NWRITTEN=0 
+      NWRITTEN=0
 
       DO NB=1,WDESK%NBANDS,NSTRIP
          DO ISTRIP=NB,MIN(WDESK%NBANDS,NB+NSTRIP-1)
@@ -2073,7 +2979,14 @@
 #ifdef gammareal
                      WVFN(IND)=REAL(WCOLLECT(ISTRIP)%CR(NX+(NC-1)*WP%WDES%GRID%RL%NROW),KIND=q)
 #else
+                     ! 2020-06-22 CCX: added for non-collinear WF plot
+                     IF (WP%WDES%NRSPINORS/=1) THEN
+                       DO ISPINOR=0,WP%WDES%NRSPINORS-1
+                         WVFN(IND+ISPINOR*(NGX*NGY*NGZ))=WCOLLECT(ISTRIP)%CR(NX+(NC-1)*WP%WDES%GRID%RL%NROW+ISPINOR*(NGX*NGY*NGZ))
+                       ENDDO
+                     ELSE
                      WVFN(IND)=WCOLLECT(ISTRIP)%CR(NX+(NC-1)*WP%WDES%GRID%RL%NROW)
+                     ENDIF
 #endif
                   ENDDO
                ENDDO
@@ -2086,7 +2999,14 @@
 #ifdef gammareal
                      WVFN(IND)=REAL(WCOLLECT(ISTRIP)%CR(NZ+(NC-1)*WP%WDES%GRID%RL%NROW),KIND=q)
 #else
+                     ! 2020-06-22 CCX: added for non-collinear WF plot
+                     IF (WP%WDES%NRSPINORS/=1) THEN
+                       DO ISPINOR=0,W%WDES%NRSPINORS-1
+                         WVFN(IND+ISPINOR*(NGX*NGY*NGZ))=WCOLLECT(ISTRIP)%CR(NZ+(NC-1)*WP%WDES%GRID%RL%NROW+ISPINOR*(NGX*NGY*NGZ))
+                       ENDDO
+                     ELSE
                      WVFN(IND)=WCOLLECT(ISTRIP)%CR(NZ+(NC-1)*WP%WDES%GRID%RL%NROW)
+                     ENDIF
 #endif
                   ENDDO
                ENDDO
@@ -2094,13 +3014,84 @@
                WRITE(*,'(A)') 'WRITE_WAVE_FUNCTIONS: ERROR: W1 grid not set'
                STOP
             ENDIF
+
+            ! 2020-06-22 CCX: added for non-collinear WF plot
+            IF (WP%WDES%NRSPINORS/=1) THEN
+              CALLMPI(M_sum_g(WP%WDES%COMM_INB,WVFN(1),NGX*NGY*NGZ*2))
+            ELSE
             CALLMPI(M_sum_g(WP%WDES%COMM_INB,WVFN(1),NGX*NGY*NGZ))
+            ENDIF
 
             ! write WVFN to file
 #ifdef MPI
-            IF (WP%WDES%COMM%NODE_ME==WP%WDES%COMM%IONODE) THEN 
+            IF (WP%WDES%COMM%NODE_ME==WP%WDES%COMM%IONODE) THEN
 #endif
+
+            ! 2020-07-04 CCX: reduce UNK matrix, cannot just write it because Do loop will change binary format
+            IF (REDUCE_UNK) THEN
+            IF (WP%WDES%NRSPINORS/=1) THEN
+              DO ISPINOR=0,1
+                POS_RED=0
+              DO IZ=1,NGZ,2
+              DO IY=1,NGY,2
+              DO IX=1,NGX,2
+                POS_RED = POS_RED+1
+                WVFN_RED(POS_RED+((NGX+1)/2)*((NGY+1)/2)*((NGZ+1)/2)*ISPINOR) = (WVFN(IX+(IY-1)*NGX+(IZ-1)*NGX*NGY+NGX*NGY*NGZ*ISPINOR))
+              ENDDO
+              ENDDO
+              ENDDO
+              ENDDO
+            ELSE
+              POS_RED=0
+              DO IZ=1,NGZ,2
+              DO IY=1,NGY,2
+              DO IX=1,NGX,2
+                POS_RED = POS_RED+1
+                WVFN_RED(POS_RED) = (WVFN(IX+(IY-1)*NGX+(IZ-1)*NGX*NGY))
+              ENDDO
+              ENDDO
+              ENDDO
+            ENDIF
+            ENDIF
+
+               ! 2020-06-22 CCX: added for non-collinear WF plot
+               IF (WP%WDES%NRSPINORS/=1) THEN
+                 IF (UNK_FMTED) THEN
+                   DO ISPINOR=0,1
+                     ! 2020-07-04 CCX: reduce wfc
+                     IF (REDUCE_UNK) THEN
+                         WRITE(IU,'(2ES20.10)') (WVFN_RED(I),I=1+((NGX+1)/2)*((NGY+1)/2)*((NGZ+1)/2)*ISPINOR,((NGX+1)/2)*((NGY+1)/2)*((NGZ+1)/2)+((NGX+1)/2)*((NGY+1)/2)*((NGZ+1)/2)*ISPINOR)
+                     ELSE
+                       WRITE(IU,'(2ES20.10)') (WVFN(I),I=1+NGX*NGY*NGZ*ISPINOR,NGX*NGY*NGZ+NGX*NGY*NGZ*ISPINOR)
+                     ENDIF
+                   ENDDO
+                 ELSEIF (.NOT. UNK_FMTED) THEN
+                   DO ISPINOR=0,1
+                     ! 2020-07-04 CCX: reduce wfc
+                     IF (REDUCE_UNK) THEN
+                       WRITE(IU) (WVFN_RED(I),I=1+((NGX+1)/2)*((NGY+1)/2)*((NGZ+1)/2)*ISPINOR,((NGX+1)/2)*((NGY+1)/2)*((NGZ+1)/2)+((NGX+1)/2)*((NGY+1)/2)*((NGZ+1)/2)*ISPINOR)
+                     ELSE
+                       WRITE(IU) (WVFN(I),I=1+NGX*NGY*NGZ*ISPINOR,NGX*NGY*NGZ+NGX*NGY*NGZ*ISPINOR)
+                     ENDIF
+                   ENDDO
+                 ENDIF
+               ELSEIF (WP%WDES%NRSPINORS==1) THEN
+                 IF (UNK_FMTED) THEN
+                   ! 2020-07-04 CCX: reduce wfc
+                   IF (REDUCE_UNK) THEN
+                     WRITE(IU,'(2ES20.10)') (WVFN_RED(I),I=1,((NGX+1)/2)*((NGY+1)/2)*((NGZ+1)/2))
+                   ELSE
+                     WRITE(IU,'(2ES20.10)') (WVFN(I),I=1,NGX*NGY*NGZ)
+                   ENDIF
+                 ELSEIF (.NOT. UNK_FMTED) THEN
+                   ! 2020-07-04 CCX: reduce wfc
+                   IF (REDUCE_UNK) THEN
+                     WRITE(IU) (WVFN_RED(I),I=1,((NGX+1)/2)*((NGY+1)/2)*((NGZ+1)/2))
+                   ELSE
                WRITE(IU) (WVFN(I),I=1,NGX*NGY*NGZ)
+                   ENDIF
+                 ENDIF
+               ENDIF
 #ifdef MPI
             ENDIF
 #endif
@@ -2108,7 +3099,7 @@
          ENDDO
       ENDDO
 
-      ! some deallocation to be done      
+      ! some deallocation to be done
       CALL DEALLOCATE_ROT_HANDLE(ROT_HANDLE)
       IF (NK/=KPOINTS_FULL%NEQUIV(NK)) CALL DELWAVA(WK)
       DO NB=1,NSTRIP*WP%WDES%NB_PAR
@@ -2116,13 +3107,14 @@
       ENDDO
       DEALLOCATE(WSTRIP,WCOLLECT)
       DEALLOCATE(WVFN)
+      ! 2020-07-04 deallocate reduced wavefunctions
+      IF (REDUCE_UNK) DEALLOCATE(WVFN_RED)
 
       RETURN
       END SUBROUTINE WRITE_WAVE_FUNCTIONS
 
-
 !******************** SUBROUTINE OCCURS_IN_FILE ************************
-!      
+!
 !***********************************************************************
       SUBROUTINE OCCURS_IN_FILE(IUNIT,PATTERN,N)
       IMPLICIT NONE
@@ -2139,14 +3131,14 @@
       WRITE(PATT,'(A20)') PATTERN
       CALL STRIP(PATT,NN,'L')
       CALL UPPER(PATT)
-     
-      N=0 
+
+      N=0
       DO
          READ(IUNIT,'(A)',ERR=100,END=100) BUFLIN
          CALL UPPER(BUFLIN)
-         N=N+NOCCUR(BUFLIN,PATT,-1) 
-      ENDDO 
-    
+         N=N+NOCCUR(BUFLIN,PATT,-1)
+      ENDDO
+
  100  CONTINUE
       BACKSPACE(IUNIT)
       RETURN
@@ -2154,7 +3146,7 @@
 
 
 !******************** SUBROUTINE COPYFILE ******************************
-!      
+!
 !***********************************************************************
       SUBROUTINE COPYFILE(SRC,TRG)
       IMPLICIT NONE
@@ -2305,7 +3297,7 @@
         ENDDO
         IF ((NB+NBEXCL)/=WDES%NB_TOT) THEN
            WRITE(*,*) 'MLWF_GET_ROTATION_MATRICES: ERROR: inconsistent number of bands:', &
-                &   NB+NBEXCL,WDES%NB_TOT 
+                &   NB+NBEXCL,WDES%NB_TOT
         ENDIF
 
         ALLOCATE(U(WDES%NB_TOT,WDES%NB_TOT,WDES%NKPTS,WDES%ISPIN))
@@ -2316,7 +3308,7 @@
               ! the set of k-points used in the computation of the rotation matrices
 
               DO NKP=1,KPOINTS_FULL%NKPTS
-                 IF (LIDENTICAL_KPOINT(WDES%VKPT(:,NK),KPOINTS_FULL%VKPT(:,NKP))) exit 
+                 IF (LIDENTICAL_KPOINT(WDES%VKPT(:,NK),KPOINTS_FULL%VKPT(:,NKP))) exit
               ENDDO
               IF (NKP>KPOINTS_FULL%NKPTS) THEN
                  WRITE(*,*) 'MLWF_GET_ROTATION_MATRICES: ERROR: no matching k-point found in KPOINTS_FULL',NK,WDES%VKPT(:,NK)
@@ -2351,15 +3343,15 @@
         ! < w_m |H| w_n > =: H
         ! w_m = U_jm b_j
         ! eps = eps_j delta_ij
-        ! 
+        !
         ! therefore:
         ! H_mn = U*_jm U_in < b_j|H|b_i > = U*_jm U_in eps_j delta_ji = U*_jm U_jn eps_j
         HAM=0
         spin1: DO ISP=1,W%WDES%ISPIN
            kpoint1: DO IK=1,WDES%NKPTS
-              
+
               DO B1=1,W%WDES%NB_TOTK(IK,ISP)
-                 DO B2=1,W%WDES%NB_TOTK(IK,ISP) 
+                 DO B2=1,W%WDES%NB_TOTK(IK,ISP)
                     DO IB=1,W%WDES%NB_TOTK(IK,ISP)
                        HAM(B2,B1,IK,ISP)=HAM(B2,B1,IK,ISP)+GCONJG(U(IB,B2,IK,ISP))*W%CELTOT(IB,IK,ISP)*U(IB,B1,IK,ISP)
                     END DO
@@ -2395,19 +3387,19 @@
         INTEGER ISP,IK,NK,IB,ISPINOR,B1,B2
         INTEGER IDIR,J,IDELTA,IORDER,ISGN
         REAL(q) K0(3),K(3),DK(3),KP(3)
-       
+
         ! calculate derivative of Hamiltonian at each k-point
         IORDER=4
 
         DK(1)=1._q/REAL(KPOINTS_FULL%NKPX,KIND=q)
         DK(2)=1._q/REAL(KPOINTS_FULL%NKPY,KIND=q)
         DK(3)=1._q/REAL(KPOINTS_FULL%NKPZ,KIND=q)
-        
+
         DHAM=0
-        
+
         spin2: DO ISP=1,W%WDES%ISPIN
            kpoint2: DO IK=1,KPOINTS%NKPTS
-              
+
               K0(:)=KPOINTS%VKPT(:,IK)
 
               dir: DO IDIR=1,3
@@ -2417,24 +3409,24 @@
                        K(IDIR)=K0(IDIR)+ISGN*IDELTA*DK(IDIR)
                        NK=KPOINT_IN_FULL_GRID(K,KPOINTS_FULL)
                        KP(:)=KPOINTS_FULL%VKPT(:,NK)
- 
+
                        ! non-cartesian coordinates !!!
-                       DHAM(:,:,IK,ISP,IDIR)=DHAM(:,:,IK,ISP,IDIR)+CMPLX(ISGN*HAM(:,:,NK,ISP)*FAC(IDELTA,IORDER)/DK(IDIR)/TPI/2._q,KIND=q)                      
+                       DHAM(:,:,IK,ISP,IDIR)=DHAM(:,:,IK,ISP,IDIR)+CMPLX(ISGN*HAM(:,:,NK,ISP)*FAC(IDELTA,IORDER)/DK(IDIR)/TPI/2._q,KIND=q)
                        DO J=1,3
 !                          DHAM(:,:,IK,ISP,J)=DHAM(:,:,IK,ISP,J)+CMPLX(ISGN*LATT_CUR%A(J,IDIR)*HAM(:,:,NK,ISP)*FAC(IDELTA,IORDER)/DK(IDIR)/TPI/2._q,KIND=q)
                           ! derivative w.r.t. to dimensionless coordinate
 !                          DHAM(:,:,IK,ISP,J)=DHAM(:,:,IK,ISP,J)+CMPLX(ISGN*HAM(:,:,NK,ISP)*FAC(IDELTA,IORDER)/DK(IDIR)/TPI/2._q,KIND=q)
-                          
+
 
                        ENDDO
 
                     ENDDO sgn
                  ENDDO delta
               ENDDO dir
-              
+
            ENDDO kpoint2
         ENDDO spin2
-        
+
         RETURN
       END SUBROUTINE MLWF_DHAM_DK
 
@@ -2471,7 +3463,7 @@
         ENDDO
         IF ((NB+NBEXCL)/=WDES%NB_TOT) THEN
            WRITE(*,*) 'MLWF_GET_ROTATION_MATRICES: ERROR: inconsistent number of bands:', &
-                &   NB+NBEXCL,WDES%NB_TOT 
+                &   NB+NBEXCL,WDES%NB_TOT
         ENDIF
 
         spin: DO ISP=1,WDES%ISPIN
@@ -2480,7 +3472,7 @@
               ! the set of k-points used in the computation of the rotation matrices
 
               DO NKP=1,KPOINTS_FULL%NKPTS
-                 IF (LIDENTICAL_KPOINT(WDES%VKPT(:,NK),KPOINTS_FULL%VKPT(:,NKP))) exit 
+                 IF (LIDENTICAL_KPOINT(WDES%VKPT(:,NK),KPOINTS_FULL%VKPT(:,NKP))) exit
               ENDDO
               IF (NKP>KPOINTS_FULL%NKPTS) THEN
                  WRITE(*,*) 'MLWF_GET_ROTATION_MATRICES: ERROR: no matching k-point found in KPOINTS_FULL',NK,WDES%VKPT(:,NK)
@@ -2526,15 +3518,15 @@
         ! < w_m |H| w_n > =: H
         ! w_m = U_jm b_j
         ! eps = eps_j delta_ij
-        ! 
+        !
         ! therefore:
         ! H_mn = U*_jm U_in < b_j|H|b_i > = U*_jm U_in eps_j delta_ji = U*_jm U_jn eps_j
         HAM=0
         spin1: DO ISP=1,W%WDES%ISPIN
            kpoint1: DO IK=1,WDES%NKPTS
-              
+
               DO B1=1,W%WDES%NB_TOTK(IK,ISP)
-                 DO B2=1,W%WDES%NB_TOTK(IK,ISP) 
+                 DO B2=1,W%WDES%NB_TOTK(IK,ISP)
                     DO IB=1,W%WDES%NB_TOTK(IK,ISP)
                        HAM(B2,B1,IK,ISP)=HAM(B2,B1,IK,ISP)+GCONJG(U(IB,B2,IK,ISP))*W%CELTOT(IB,IK,ISP)*U(IB,B1,IK,ISP)
                     END DO
@@ -2550,7 +3542,7 @@
 !***********************************************************************
 
       SUBROUTINE WRITE_WANPROJ_FILE(WDES)
-         IMPLICIT NONE 
+         IMPLICIT NONE
          TYPE(wavedes) WDES
          COMPLEX(q), ALLOCATABLE :: U(:,:)
          INTEGER I,J,K,IP,IPP
@@ -2571,8 +3563,8 @@
          U=0
 
          OPEN(UNIT=99, FILE=WANPROJFILE, STATUS='REPLACE')
-            
-         WRITE(99,*)WDES%ISPIN,WDES%NKPTS,WDES%NB_TOT,NW  
+
+         WRITE(99,*)WDES%ISPIN,WDES%NKPTS,WDES%NB_TOT,NW
          DO NK=1,WDES%NKPTS
             WRITE(99,999)NK,WDES%VKPT(:,NK)
          ENDDO
@@ -2581,7 +3573,7 @@
                ! find the corresponding entry in kpt_latt, that contains
                ! the set of k-points used in the computation of the rotation matrices
                DO NKP=1,SIZE(kpt_latt,2)
-                  IF (LIDENTICAL_KPOINT(WDES%VKPT(:,NK),kpt_latt(:,NKP))) exit 
+                  IF (LIDENTICAL_KPOINT(WDES%VKPT(:,NK),kpt_latt(:,NKP))) exit
                ENDDO
                IF (NKP>KPOINTS_FULL%NKPTS) THEN
                   WRITE(*,*) &
@@ -2632,4 +3624,3 @@
 1001     FORMAT(2I6,2F26.16)
       ENDSUBROUTINE WRITE_WANPROJ_FILE
       END MODULE mlwf
-
diff --color -ruN src/wave_high.F ../vasp.5.4.4.pl2.mod/src/wave_high.F
--- src/wave_high.F	2019-11-04 13:45:35.000000000 +0000
+++ ../vasp.5.4.4.pl2.mod/src/wave_high.F	2022-05-31 14:02:40.686954343 +0100
@@ -53,6 +53,18 @@
      END SUBROUTINE ECCP_NL
   END INTERFACE
 
+! 2020-06-25 CCX: Addde for spn calculation
+  INTERFACE
+     SUBROUTINE ECCP_NL_SPN(LMDIM,LMMAXC,PAULI,CDIJ,CPROJ1,CPROJ2,CNL)
+       USE prec
+       COMPLEX(q):: PAULI
+       GDEF      CNL
+       INTEGER LMDIM, LMMAXC
+       OVERLAP CDIJ
+       GDEF CPROJ1,CPROJ2
+     END SUBROUTINE ECCP_NL_SPN
+  END INTERFACE
+
   INTERFACE
      SUBROUTINE OVERL(WDES1, LOVERL, LMDIM, CQIJ, CPROF, CRESUL)
        USE wave
@@ -634,6 +646,116 @@
       
   END FUNCTION W1_DOT
 
+!***********************************************************************
+!
+! 2020-06-25 CCX: added for spn calculation
+! calculate the dot product between two wavefunctions
+!  C=   <W1| Sigma| W2>
+! this is a substitue for the routine CINDPROD but mind
+! the W1 and W2 are interchanged
+!
+!***********************************************************************
+FUNCTION W1_SPN_DOT(W1, W2, CQIJ) RESULT (C)
+  IMPLICIT NONE
+  TYPE (wavefun1)    W1, W2
+  GDEF :: cdum1,cdum2
+!  GDEF :: cdum1_aug,cdum2_aug,sigma_x_aug,sigma_y_aug,sigma_z_aug
+  ! INTEGER NC                      ! stride of C
+  OVERLAP :: CQIJ(:,:,:,:) ! optional overlap operator
+!  OVERLAP, ALLOCATABLE :: SCQIJ_x(:,:,:,:),SCQIJ_y(:,:,:,:),SCQIJ_z(:,:,:,:) ! optional overlap operator * pauli matrix
+  COMPLEX(q), EXTERNAL :: ZDOTC
+  REAL(q), EXTERNAL ::  DDOT
+! local
+  COMPLEX(q) :: PAULI
+  GDEF :: CNLx,CNLy,CNLz,C(3)
+  INTEGER :: LMDIM, NPRO, NPRO_, ISPINOR, ISPINOR_, LMMAXC, NT, NI, NIS
+
+!  ALLOCATE(SCQIJ_x(1,1,W1%WDES1%NTYP,4),SCQIJ_y(1,1,W1%WDES1%NTYP,4),SCQIJ_z(1,1,W1%WDES1%NTYP,4))
+
+  ! DO ISPINOR=0,W1%WDES1%NRSPINORS-1
+  !   DO ISPINOR_=0,W1%WDES1%NRSPINORS-1
+  cdum1=ZDOTC( W1%WDES1%NPL/2,W1%CW(1),1,W2%CW(1+W1%WDES1%NPL/2*(W1%WDES1%NRSPINORS-1)),1)
+  cdum2=ZDOTC( W1%WDES1%NPL/2,W1%CW(1+W1%WDES1%NPL/2*(W1%WDES1%NRSPINORS-1)),1,W2%CW(1),1)
+  C(1)=cdum1+cdum2
+  C(2)=cmplx(0._q,1._q,q)*(cdum2-cdum1)
+  C(3)=zdotc(W1%WDES1%NPL/2,W1%CW(1),1,W2%CW(1),1)&
+         -zdotc(W1%WDES1%NPL/2,W1%CW(1+W1%WDES1%NPL/2*(W1%WDES1%NRSPINORS-1)),1,W2%CW(1+W1%WDES1%NPL/2*(W1%WDES1%NRSPINORS-1)),1)
+
+  ! getme SCQIJ
+!  WRITE(*,*) "number of type", W1%WDES1%NTYP
+!  WRITE(*,*) "CQIJ: ",CQIJ(1,1,1,:)
+!  DO NT=1,W1%WDES1%NTYP
+!    SCQIJ_x(1,1,NI,1+0+2*0)=CQIJ(1,1,NI,1+1+2*0)
+!    SCQIJ_x(1,1,NI,1+0+2*1)=CQIJ(1,1,NI,1+1+2*1)
+!    SCQIJ_x(1,1,NI,1+1+2*0)=CQIJ(1,1,NI,1+0+2*0)
+!    SCQIJ_x(1,1,NI,1+1+2*1)=CQIJ(1,1,NI,1+0+2*1)
+!
+!    SCQIJ_y(1,1,NI,1+0+2*0)=cmplx(0._q,-1._q,q)*CQIJ(1,1,NI,1+1+2*0)
+!    SCQIJ_y(1,1,NI,1+0+2*1)=cmplx(0._q,-1._q,q)*CQIJ(1,1,NI,1+1+2*1)
+!    SCQIJ_y(1,1,NI,1+1+2*0)=cmplx(0._q,1._q,q)*CQIJ(1,1,NI,1+0+2*0)
+!    SCQIJ_y(1,1,NI,1+1+2*1)=cmplx(0._q,1._q,q)*CQIJ(1,1,NI,1+0+2*1)
+!
+!    SCQIJ_z(1,1,NI,1+0+2*0)=CQIJ(1,1,NI,1+0+2*0)
+!    SCQIJ_z(1,1,NI,1+0+2*1)=CQIJ(1,1,NI,1+0+2*1)
+!    SCQIJ_z(1,1,NI,1+1+2*0)=-1._q*CQIJ(1,1,NI,1+1+2*0)
+!    SCQIJ_z(1,1,NI,1+1+2*1)=-1._q*CQIJ(1,1,NI,1+1+2*1)
+!  ENDDO
+
+!  WRITE(*,*) "SCQIJ_x: ",SCQIJ_x(1,1,1,:)
+!  WRITE(*,*) "SCQIJ_y: ",SCQIJ_y(1,1,1,:)
+!  WRITE(*,*) "SCQIJ_z: ",SCQIJ_z(1,1,1,:)
+
+  IF ( W1%WDES1%LOVERL .AND.  W1%WDES1%NPROD>0 ) THEN
+     CNLx=0
+     CNLy=0
+     CNLz=0
+
+     LMDIM = SIZE(CQIJ,1)
+
+     spinor: DO ISPINOR=0,W1%WDES1%NRSPINORS-1
+     DO ISPINOR_=0,W1%WDES1%NRSPINORS-1
+
+        NPRO =ISPINOR *(W1%WDES1%NPRO/2)
+        NPRO_=ISPINOR_*(W1%WDES1%NPRO/2)
+        NIS =1
+        DO NT=1,W1%WDES1%NTYP
+           LMMAXC=W1%WDES1%LMMAX(NT)
+           IF (LMMAXC/=0) THEN
+              DO NI=NIS,W1%WDES1%NITYP(NT)+NIS-1
+                 IF (ISPINOR==0 .AND. ISPINOR_==0 ) THEN
+                    CALL ECCP_NL_SPN(LMDIM,LMMAXC,CMPLX(1._q,0._q,q),CQIJ(1,1,NI,1+0+2*1),W2%CPROJ(NPRO_+1),W1%CPROJ(NPRO+1),CNLx)
+                    CALL ECCP_NL_SPN(LMDIM,LMMAXC,CMPLX(0._q,-1._q,q),CQIJ(1,1,NI,1+0+2*1),W2%CPROJ(NPRO_+1),W1%CPROJ(NPRO+1),CNLy)
+                    CALL ECCP_NL_SPN(LMDIM,LMMAXC,CMPLX(1._q,0._q,q),CQIJ(1,1,NI,1+0+2*0),W2%CPROJ(NPRO_+1),W1%CPROJ(NPRO+1),CNLz)
+                 ELSEIF (ISPINOR==0 .AND. ISPINOR_==1 ) THEN
+                    CALL ECCP_NL_SPN(LMDIM,LMMAXC,CMPLX(1._q,0._q,q),CQIJ(1,1,NI,1+1+2*1),W2%CPROJ(NPRO_+1),W1%CPROJ(NPRO+1),CNLx)
+                    CALL ECCP_NL_SPN(LMDIM,LMMAXC,CMPLX(0._q,-1._q,q),CQIJ(1,1,NI,1+1+2*1),W2%CPROJ(NPRO_+1),W1%CPROJ(NPRO+1),CNLy)
+                    CALL ECCP_NL_SPN(LMDIM,LMMAXC,CMPLX(1._q,0._q,q),CQIJ(1,1,NI,1+1+2*0),W2%CPROJ(NPRO_+1),W1%CPROJ(NPRO+1),CNLz)
+                 ELSEIF (ISPINOR==1 .AND. ISPINOR_==0 ) THEN
+                    CALL ECCP_NL_SPN(LMDIM,LMMAXC,CMPLX(1._q,0._q,q),CQIJ(1,1,NI,1+0+2*0),W2%CPROJ(NPRO_+1),W1%CPROJ(NPRO+1),CNLx)
+                    CALL ECCP_NL_SPN(LMDIM,LMMAXC,CMPLX(0._q,1._q,q),CQIJ(1,1,NI,1+0+2*0),W2%CPROJ(NPRO_+1),W1%CPROJ(NPRO+1),CNLy)
+                    CALL ECCP_NL_SPN(LMDIM,LMMAXC,CMPLX(-1._q,0._q,q),CQIJ(1,1,NI,1+0+2*1),W2%CPROJ(NPRO_+1),W1%CPROJ(NPRO+1),CNLz)
+                 ELSEIF (ISPINOR==1 .AND. ISPINOR_==1 ) THEN
+                    CALL ECCP_NL_SPN(LMDIM,LMMAXC,CMPLX(1._q,0._q,q),CQIJ(1,1,NI,1+1+2*0),W2%CPROJ(NPRO_+1),W1%CPROJ(NPRO+1),CNLx)
+                    CALL ECCP_NL_SPN(LMDIM,LMMAXC,CMPLX(0._q,1._q,q),CQIJ(1,1,NI,1+1+2*0),W2%CPROJ(NPRO_+1),W1%CPROJ(NPRO+1),CNLy)
+                    CALL ECCP_NL_SPN(LMDIM,LMMAXC,CMPLX(-1._q,0._q,q),CQIJ(1,1,NI,1+1+2*1),W2%CPROJ(NPRO_+1),W1%CPROJ(NPRO+1),CNLz)
+                 ENDIF
+                 NPRO = LMMAXC+NPRO
+                 NPRO_= LMMAXC+NPRO_
+              ENDDO
+           ENDIF
+           NIS = NIS+W1%WDES1%NITYP(NT)
+        ENDDO
+     ENDDO
+     ENDDO spinor
+     C(1)=C(1)+CNLx
+     C(2)=C(2)+CNLy
+     C(3)=C(3)+CNLz
+  ENDIF
+  !WRITE(*,*) C
+  CALLMPI( M_sum_g(W1%WDES1%COMM_INB, C(1), 3))
+  !DEALLOCATE(SCQIJ_x,SCQIJ_y,SCQIJ_z)
+
+END FUNCTION W1_SPN_DOT
 
 !***********************************************************************
 !
@@ -3160,6 +3282,43 @@
 
   END SUBROUTINE ECCP_NL
 
+!************************* SUBROUTINE ECCP_NL_SPN   ************************
+!
+! 2020-06-25 CCX: added for .spn calculation in mlwf.F
+! this subroutine calculates the expectation value of <c|SPN*H|cp>
+! where c and cp are two wavefunctions; non local part only
+! for one ion only
+! I have put this in a separate routine because optimization
+! is than easier
+!
+!***********************************************************************
+
+  SUBROUTINE ECCP_NL_SPN(LMDIM,LMMAXC,PAULI,CDIJ,CPROJ1,CPROJ2,CNL)
+    USE prec
+    IMPLICIT NONE
+    COMPLEX(q) :: PAULI ! paulimatrix element
+    GDEF      CNL
+    INTEGER LMDIM, LMMAXC
+    OVERLAP CDIJ(LMDIM,LMDIM)
+    GDEF CPROJ1(LMMAXC),CPROJ2(LMMAXC)
+ ! local
+    INTEGER L, LP
+
+!   PROFILING_START('eccp_nl')
+
+!DIR$ IVDEP
+!OCL NOVREL
+    DO L=1,LMMAXC
+       DO LP=1,LMMAXC
+          CNL=CNL+PAULI*CDIJ(LP,L)*CPROJ1(LP)*GCONJG(CPROJ2(L))
+       ENDDO
+    ENDDO
+
+!   PROFILING_STOP('eccp_nl')
+
+END SUBROUTINE ECCP_NL_SPN
+
+
 
 !************************* SUBROUTINE OVERL ***************************
 !
