diff -bruN src/mlwf.F ../vasp.5.4.4_mod/src/mlwf.F
--- src/mlwf.F	2017-04-20 10:03:58.000000000 +0100
+++ ../vasp.5.4.4_mod/src/mlwf.F	2020-06-23 12:41:51.058460377 +0100
@@ -6,6 +6,8 @@
  
       ! write the wave functions to UNK files
       LOGICAL, PRIVATE, SAVE :: WRITE_UNK
+      LOGICAL, PRIVATE, SAVE :: UNK_FMTED
+
       ! write the mmn and amn files when WANNIER90 runs in lib mode
       LOGICAL, PRIVATE, SAVE :: WRITE_MMN_AMN
 
@@ -195,6 +197,18 @@
                WRITE(IU0,*)'Error reading item ''LWRITE_UNK'' from file INCAR.'
             WRITE_UNK=.FALSE.
          ENDIF
+
+         ! 2020-06-22 CCX: added to determine UNK is formatted or not
+         UNK_FMTED=.FALSE.
+         CALL RDATAB(.FALSE.,INCAR,IU5,'LUNK_FMTED','=','#',';','L', &
+        &            IDUM,RDUM,CDUM,UNK_FMTED,CHARAC,N,1,IERR)
+         IF (((IERR/=0).AND.(IERR/=3)).OR. &
+        &                    ((IERR==0).AND.(N<1))) THEN
+            IF (IU0>=0) &
+               WRITE(IU0,*)'Error reading item ''LUNK_FMTED'' from file INCAR.'
+            UNK_FMTED=.FALSE.
+         ENDIF
+
          ! Do we want to write the mmn and amn files
          ! even though WANNIER90 runs in library mode?
          WRITE_MMN_AMN=.NOT.LWANNIER90_RUN
@@ -320,6 +334,9 @@
       REAL(q), ALLOCATABLE :: proj_x(:,:)
       REAL(q), ALLOCATABLE :: proj_zona(:)
       INTEGER, ALLOCATABLE :: exclude_bands(:)
+      ! CCX_2019-05-05: define proj_s and proj_s_qaxis
+      INTEGER, ALLOCATABLE :: proj_s(:)
+      REAL(q), ALLOCATABLE :: proj_s_qaxis(:,:)
       ! wannier90_run variables: input
       COMPLEX(q), ALLOCATABLE :: M_matrix(:,:,:,:,:)
       COMPLEX(q), ALLOCATABLE :: A_matrix(:,:,:,:)
@@ -329,6 +346,12 @@
       INTEGER NI,MI,NK,NKP,ICNTR
       INTEGER NKI,NKJ,ISP,ISPINOR,L,M,N,NP
       INTEGER NEXCLB,NPROJ
+      ! CCX_2019-05-06: spin quantization local variables
+      LOGICAL spin_z_pos,spin_z_neg
+      COMPLEX(q) FAC(2)
+      REAL(q) :: eps6=0.000001_q
+      REAL(q) xnorm
+      ! CCX_2019-05-06: end definition
       REAL(q) POS(3)
       REAL(q) KI(3),KJ(3)
       INTEGER IDUM,IERR
@@ -364,12 +387,14 @@
 !        STOP
 !     END IF
 #endif
+
+! 2020-06-22 CCX: wannier90 CAN plot spinors.
       ! WANNIER90 cannot plot spinors
-      IF (WRITE_UNK.AND.WDES%LNONCOLLINEAR) THEN
-         IF (IO%IU0>=0) WRITE(IO%IU0,*) &
-        & 'MLWF_WANNIER90: ERROR: will not write spinors to UNK files, sorry ...'
-         WRITE_UNK=.FALSE.
-      ENDIF
+!      IF (WRITE_UNK.AND.WDES%LNONCOLLINEAR) THEN
+!         IF (IO%IU0>=0) WRITE(IO%IU0,*) &
+!        & 'MLWF_WANNIER90: ERROR: will not write spinors to UNK files, sorry ...'
+!         WRITE_UNK=.FALSE.
+!      ENDIF
 !
 ! allocation
       ALLOCATE(S(WDES%NB_TOT,WDES%NB_TOT))
@@ -449,8 +474,17 @@
 
       ALLOCATE(proj_site(3,num_bands_tot),proj_l(num_bands_tot),proj_m(num_bands_tot), &
      &   proj_radial(num_bands_tot),proj_z(3,num_bands_tot),proj_x(3,num_bands_tot), &
-     &   proj_zona(num_bands_tot),exclude_bands(num_bands_tot))
+     &   proj_zona(num_bands_tot),exclude_bands(num_bands_tot), &
+#ifdef VASP2WANNIER90v2
+! CCX_2019-05-05: allocate proj_s and proj_s_qaxis.
+     &   proj_s(num_bands_tot),proj_s_qaxis(3,num_bands_tot) &
+#endif
+     &   )
       proj_site=0; proj_l=0; proj_m=0; proj_radial=0; proj_z=0; proj_x=0; proj_zona=0; exclude_bands=0
+#ifdef VASP2WANNIER90v2
+! CCX_2019-05-05: initialize proj_s and proj_s_qaxis.
+      proj_s=0; proj_s_qaxis=0
+#endif
 
       ! Only one node will do the actual work,
       ! otherwise all will write to wannier90.wout
@@ -460,7 +494,12 @@
      &                   kpt_latt,num_bands_tot,num_atoms,atom_symbols,atoms_cart, &
      &                   gamma_only,spinors,nntot,nnlist,nncell,num_bands,num_wann, &
      &                   proj_site,proj_l,proj_m,proj_radial,proj_z,proj_x,proj_zona, &
-     &                   exclude_bands)
+     &                   exclude_bands, &
+#ifdef VASP2WANNIER90v2
+! CCX_2019-05-05: call wannier_setup to calculate proj_s and proj_s_qaxis
+     &                   proj_s,proj_s_qaxis &
+#endif
+     &                   )
 #endif
       ! Now communicate the output to the other nodes
       CALLMPI( M_sum_i(WDES%COMM,nntot,1) ) 
@@ -476,6 +515,11 @@
       CALLMPI( M_sum_d(WDES%COMM,proj_x,3*num_bands_tot) )
       CALLMPI( M_sum_d(WDES%COMM,proj_zona,num_bands_tot) )
       CALLMPI( M_sum_i(WDES%COMM,exclude_bands,num_bands_tot) )
+#ifdef VASP2WANNIER90v2
+! CCX_2019-05-05: bcast proj_s and proj_s_qaxis
+      CALLMPI( M_sum_i(WDES%COMM,proj_s,num_bands_tot) )
+      CALLMPI( M_sum_d(WDES%COMM,proj_s_qaxis,3*num_bands_tot) )
+#endif
 
       ALLOCATE(EXCLUDE_BAND(num_bands_tot))
       EXCLUDE_BAND=.FALSE. ; NEXCLB=0
@@ -584,6 +628,11 @@
       DO ISPINOR=1,WDES%NRSPINORS
       DO ICNTR=1,num_bands_tot
          IF (proj_l(ICNTR)==0.AND.proj_m(ICNTR)==0.AND.proj_radial(ICNTR)==0) CYCLE
+#ifdef VASP2WANNIER90v2
+! CCX_2019-05-05: only calculate corresponding spin channel
+         IF (WDES%NRSPINORS/=1.AND.proj_s(ICNTR)==1.AND.ISPINOR==2) CYCLE
+         IF (WDES%NRSPINORS/=1.AND.proj_s(ICNTR)==-1.AND.ISPINOR==1) CYCLE
+#endif
          NPROJ=NPROJ+1
       ENDDO
       ENDDO
@@ -643,11 +692,36 @@
       ALLOCATE(ROTYLM((LMAX+1)**2,(LMAX+1)**2),HYBRID_ORBITAL((LMAX+1)**2))
 
       NPROJ=0 
-!     CALL START_TIMING("T1")
+      ! CCX_2020-06-15: initialize A matrix
+      A_matrix=0
       ! runs over all projector sites
-      spinor: DO ISPINOR=1,WDES%NRSPINORS
       sites : DO ICNTR=1,num_bands_tot
          IF (proj_l(ICNTR)==0.AND.proj_m(ICNTR)==0.AND.proj_radial(ICNTR)==0) CYCLE sites
+        ! CCX_2019-05-06: determin spin quantization axis along z axis or not.
+        spin_z_pos=.false.
+        spin_z_neg=.false.
+        ! CCX_2019-06-10: renormalize spin quantization axis
+        xnorm=SQRT(proj_s_qaxis(1,ICNTR)*proj_s_qaxis(1,ICNTR)+proj_s_qaxis(2,ICNTR)*proj_s_qaxis(2,ICNTR)+proj_s_qaxis(3,ICNTR)*proj_s_qaxis(3,ICNTR))
+        proj_s_qaxis(1,ICNTR)=proj_s_qaxis(1,ICNTR)/xnorm
+        proj_s_qaxis(2,ICNTR)=proj_s_qaxis(2,ICNTR)/xnorm
+        proj_s_qaxis(3,ICNTR)=proj_s_qaxis(3,ICNTR)/xnorm
+
+        IF ((abs(proj_s_qaxis(1,ICNTR)-0.0d0)<eps6).and.(abs(proj_s_qaxis(2,ICNTR)-0.0d0)<eps6) &
+           .and.(abs(proj_s_qaxis(3,ICNTR)-1.0d0)<eps6)) then
+           spin_z_pos=.true.
+        ELSEIF(abs(proj_s_qaxis(1,ICNTR)-0.0d0)<eps6.and.abs(proj_s_qaxis(2,ICNTR)-0.0d0)<eps6 &
+           .and.abs(proj_s_qaxis(3,ICNTR)+1.0d0)<eps6) then
+           spin_z_neg=.true.
+        ENDIF
+        ! CCX_2019-05-06: [start] if proj_s_qaxis lies along z, normal projections are done.
+        IF (spin_z_pos .OR. spin_z_neg.or.WDES%NRSPINORS==1) THEN ! if not spinor, still use this routine.
+          spinor1: DO ISPINOR=1,WDES%NRSPINORS
+            IF (spin_z_pos.AND.WDES%NRSPINORS/=1.AND.proj_s(ICNTR)==1.AND.ISPINOR==2) CYCLE spinor1
+            IF (spin_z_pos.AND.WDES%NRSPINORS/=1.AND.proj_s(ICNTR)==-1.AND.ISPINOR==1) CYCLE spinor1
+            ! if neg then swap up and down definition
+            IF (spin_z_neg.AND.WDES%NRSPINORS/=1.AND.proj_s(ICNTR)==1.AND.ISPINOR==1) CYCLE spinor1
+            IF (spin_z_neg.AND.WDES%NRSPINORS/=1.AND.proj_s(ICNTR)==-1.AND.ISPINOR==2) CYCLE spinor1
+
          NPROJ=NPROJ+1
          ! setup the Ylm rotation matrix in accordance with proj_z and proj_x
          CALL SETROTYLM(proj_x(:,ICNTR),proj_z(:,ICNTR),LMAX,ROTYLM)
@@ -673,9 +747,9 @@
          ENDDO
 
 
-!        CALL START_TIMING("T2")
+      !        CALL START_TIMING("T2")
          ! runs over all k-points
-         kpoints : DO NKI=1,num_kpts
+            kpoints1 : DO NKI=1,num_kpts
             CALL CALC_OVERLAP_GN( &
            &   LMAX,FG,proj_site(:,ICNTR),W,kpt_latt(:,NKI),ISP,ISPINOR,P,CQIJ,LATT_CUR,T_INFO,A)
             ! and rotate them in accordance with proj_z and proj_x
@@ -712,15 +786,111 @@
                A_matrix(MI,NPROJ,NKI,ISP)=CPROJ
             ENDDO
 
-         ENDDO kpoints
+            ENDDO kpoints1
 
          DEALLOCATE(FTMP,FR,FGTMP,FG)
 
          IF (IO%IU0>=0) WRITE(IO%IU0,'(X,A,I3,A)') 'Projection ',NPROJ,' done.'
-!        CALL STOP_TIMING("T2",IO%IU6,'  OVL')
-!        CALL STOP_TIMING("T1",IO%IU6,'ICNTR')
+      !        CALL STOP_TIMING("T2",IO%IU6,'  OVL')
+      !        CALL STOP_TIMING("T1",IO%IU6,'ICNTR')
+          ENDDO spinor1
+        ! CCX_2019-05-06: [end] end normal routine.
+        ELSE ! CCX_2019-05-06: quantization axis does not lies along z axis, do special projection routine.
+        ! CCX_2019-05-06: generate spinor eigenvectors.
+          ! CCX_2019-06-10: renormalize spin quantization axis
+          xnorm=SQRT(proj_s_qaxis(1,ICNTR)*proj_s_qaxis(1,ICNTR)+proj_s_qaxis(2,ICNTR)*proj_s_qaxis(2,ICNTR)+proj_s_qaxis(3,ICNTR)*proj_s_qaxis(3,ICNTR))
+          proj_s_qaxis(1,ICNTR)=proj_s_qaxis(1,ICNTR)/xnorm
+          proj_s_qaxis(2,ICNTR)=proj_s_qaxis(2,ICNTR)/xnorm
+          proj_s_qaxis(3,ICNTR)=proj_s_qaxis(3,ICNTR)/xnorm
+
+          IF (proj_s(ICNTR)==1) THEN ! up channel
+              FAC(1)=(1.0d0/SQRT(1+proj_s_qaxis(3,ICNTR)))*(proj_s_qaxis(3,ICNTR)+1)*CMPLX(1.0d0,0.0d0,q)
+              FAC(2)=(1.0d0/SQRT(1+proj_s_qaxis(3,ICNTR)))*CMPLX(proj_s_qaxis(1,ICNTR),proj_s_qaxis(2,ICNTR),q)
+              NPROJ=NPROJ+1
+          ELSE ! down channel
+              FAC(1)=(1.0d0/SQRT(1-proj_s_qaxis(3,ICNTR)))*(proj_s_qaxis(3,ICNTR)-1)*CMPLX(1.0d0,0.0d0,q)
+              FAC(2)=(1.0d0/SQRT(1-proj_s_qaxis(3,ICNTR)))*CMPLX(proj_s_qaxis(1,ICNTR),proj_s_qaxis(2,ICNTR),q)
+              NPROJ=NPROJ+1
+          ENDIF
+
+          ! 2020-06-15 CCX: we no longer need ISPINOR loop since we are using full spinor guiding functions.
+          !spinor: DO ISPINOR=1,WDES%NRSPINORS
+           ! setup the Ylm rotation matrix in accordance with proj_z and proj_x
+            CALL SETROTYLM(proj_x(:,ICNTR),proj_z(:,ICNTR),LMAX,ROTYLM)
+#ifdef debug
+            IF (IO%IU6>=0) THEN
+               WRITE(*,'(I4,3F14.7)') ICNTR,proj_site(1:3,ICNTR)
+               DO N=10,MIN((LMAX+1)**2,16)
+                  WRITE(*,'(9F10.5)') (ROTYLM(N,M),M=10,MIN((LMAX+1)**2,16))
+               ENDDO
+            ENDIF
+#endif
+            ! translate between VASP and the orbital definition of wannier90
+            CALL WANNIER90_ORBITAL_DEFINITIONS(proj_l(ICNTR),proj_m(ICNTR),HYBRID_ORBITAL)
+            ! setup the radial functions (real space)
+            CALL SETRGRID(RSTART/proj_zona(ICNTR),REND,H,R)
+            ALLOCATE(FTMP(R%NMAX),FR(R%NMAX,LMAX+1))
+            ALLOCATE(FGTMP(NMAX,5),FG(NMAX,5,LMAX+1))
+            ! For now we use the same radial function for all L
+            DO L=0,LMAX
+               CALL RADIAL_FUNCTION(proj_radial(ICNTR),R,proj_zona(ICNTR),FTMP)
+               CALL BESSEL_TRANSFORM_RADIAL_FUNCTION(L,R,FTMP,REAL(SQRT(2._q*INFO%ENMAX/HSQDTM)/NMAX,KIND=q),FGTMP)
+               FR(:,L+1)=FTMP; FG(:,:,L+1)=FGTMP
+            ENDDO
+
+
+         !        CALL START_TIMING("T2")
+            ! runs over all k-points
+            kpoints : DO NKI=1,num_kpts
+               CALL CALC_OVERLAP_GN_ALL( &
+              &   LMAX,FG,proj_site(:,ICNTR),W,kpt_latt(:,NKI),ISP,FAC,P,CQIJ,LATT_CUR,T_INFO,A)
+               ! and rotate them in accordance with proj_z and proj_x
+               AP=0
+               DO M=1,WDES%NB_TOT
+               DO N=1,(LMAX+1)**2
+                  DO NP=1,(LMAX+1)**2
+                     AP(M,N)=AP(M,N)+A(M,NP)*ROTYLM(N,NP)
+                  ENDDO
+               ENDDO
+               ENDDO
+#ifdef debug
+               IF (IO%IU6>=0) THEN
+                  WRITE(*,'(I4,3F14.7)') NKI,kpt_latt(1:3,NKI)
+                  DO M=1,WDES%NB_TOT
+                     WRITE(*,'(4(2F14.7,2X))') (A(M,N),N=1,4)
+                  ENDDO
+                  WRITE(*,*)
+                  DO M=1,WDES%NB_TOT
+                     WRITE(*,'(4(2F14.7,2X))') (AP(M,N),N=1,4)
+                  ENDDO
+                  WRITE(*,*)
+               ENDIF
+#endif
+               ! Make the desired linear combinations
+               MI=0
+               DO M=1,WDES%NB_TOT
+                  IF (EXCLUDE_BAND(M)) CYCLE
+                  CPROJ=0
+                  DO N=1,(LMAX+1)**2
+                     CPROJ=CPROJ+AP(M,N)*HYBRID_ORBITAL(N)
+                  ENDDO
+                  MI=MI+1
+                  ! CCX_2019-05-06: dot spin quantization coefficients FAC(ISPINOR).
+                  !A_matrix(MI,NPROJ,NKI,ISP)=A_matrix(MI,NPROJ,NKI,ISP)+FAC(ISPINOR)*CPROJ
+                  A_matrix(MI,NPROJ,NKI,ISP)=CPROJ
+               ENDDO
+
+            ENDDO kpoints
+
+            DEALLOCATE(FTMP,FR,FGTMP,FG)
+
+         !  IF (IO%IU0>=0) WRITE(IO%IU0,'(X,A,I3,A,I3,A)') 'Spin channel',ISPINOR,' done.'
+         !        CALL STOP_TIMING("T2",IO%IU6,'  OVL')
+         !        CALL STOP_TIMING("T1",IO%IU6,'ICNTR')
+      !ENDDO spinor
+          IF (IO%IU0>=0) WRITE(IO%IU0,'(X,A,I3,A)') 'Projection ',NPROJ,' done. [q_axis changed]'
+        ENDIF ! quantization IF
       ENDDO sites
-      ENDDO spinor
 
       DEALLOCATE(A,AP,ROTYLM,HYBRID_ORBITAL)
 
@@ -811,14 +981,24 @@
       ! to make matters worse, WANNIER90 works with the full k-mesh
       ! whereas VASP uses the symmetry reduced one.
  100  FORMAT('UNK',I5.5,'.',I1)
+ 101  FORMAT('UNK',I5.5,'.NC')
       IF (WRITE_UNK) THEN
          DO NKI=1,num_kpts
             IF (IO%IU6>=0) THEN
+               IF (W%WDES%NRSPINORS/=1) THEN
+                 WRITE(UNKFILE,101) NKI
+               ELSE
                WRITE(UNKFILE,100) NKI,ISP
+               ENDIF
+               IF (UNK_FMTED) THEN
+                 OPEN(UNIT=99,FILE=UNKFILE,FORM='FORMATTED',STATUS='REPLACE')
+                 WRITE(99,*) W%WDES%GRID%NGX,W%WDES%GRID%NGY,W%WDES%GRID%NGZ,NKI,num_bands
+               ELSE
                OPEN(UNIT=99,FILE=UNKFILE,FORM='UNFORMATTED',STATUS='REPLACE')
                WRITE(99) W%WDES%GRID%NGX,W%WDES%GRID%NGY,W%WDES%GRID%NGZ,NKI,num_bands
             ENDIF
-            CALL WRITE_WAVE_FUNCTIONS(W,kpt_latt(:,NKI),ISP,EXCLUDE_BAND,P,LATT_CUR,99)   
+            ENDIF
+            CALL WRITE_WAVE_FUNCTIONS(W,kpt_latt(:,NKI),ISP,EXCLUDE_BAND,P,LATT_CUR,UNK_FMTED,99)
             IF (IO%IU6>=0) CLOSE(99)
          ENDDO
       ENDIF
@@ -1880,6 +2060,104 @@
       RETURN
       END SUBROUTINE CALC_OVERLAP_GN
 
+!******************** SUBROUTINE CALC_OVERLAP_GN_ALL *******************
+! 2020-06-15 CCX: added to use CONSTRUCT_FUNCTION_RYlm_ALL
+!                 for spin_quantization calculations
+!***********************************************************************
+      SUBROUTINE CALC_OVERLAP_GN_ALL( &
+     &   L,FG,POS,W,K,ISP,SPIN_FAC,P,CQIJ,LATT_CUR,T_INFO,S &
+     &)
+      USE pead
+      USE poscar
+      USE pseudo
+      USE lattice
+      USE full_kpoints
+      USE wave_high
+      USE nonl_high
+      IMPLICIT NONE
+      TYPE(wavespin) W
+      TYPE(potcar) P(:)
+      TYPE(latt) LATT_CUR
+      TYPE(type_info) T_INFO
+      INTEGER L
+      INTEGER ISP
+      ! 2020-06-15 CCX: read in SPIN_FAC
+      COMPLEX(q) SPIN_FAC(2)
+      REAL(q) K(3)
+      REAL(q) FG(:,:,:)
+      REAL(q) POS(3)
+      OVERLAP CQIJ(:,:,:,:)
+      GDEF S(W%WDES%NB_TOT,(L+1)**2)
+      ! local variables
+      TYPE(wavespin) WP
+      TYPE(wavefuna) WK,WRYlm
+      TYPE(wavedes1), TARGET :: WDESK
+      TYPE(nonl_struct) NONL_S
+
+      TYPE(rotation_handle), POINTER :: ROT_HANDLE
+
+      GDEF C
+      REAL(q) WSCAL
+      INTEGER NK,NB,N,NYLM
+
+      WP=W
+      WP%WDES=>WDES_FULL_PEAD
+
+      CALL CHECK_FULL_KPOINTS
+
+      NULLIFY(ROT_HANDLE)
+
+      NYLM=(L+1)**2
+
+      ! search for kpoint k in BZ
+      NK=KPOINT_IN_FULL_GRID(K,KPOINTS_FULL)
+      CALL SETWDES(WP%WDES,WDESK,NK)
+      IF (NK==KPOINTS_FULL%NEQUIV(NK)) THEN
+         ! k is a kpoint in the IBZ
+         WK=ELEMENTS(WP,WDESK,ISP)
+      ELSE
+         ! k is not a kpoint in the IBZ
+         CALL NEWWAVA(WK,WDESK,WDESK%NBANDS)
+         CALL PEAD_WA_ROTATE(WP,P,LATT_CUR,ISP,WK)
+      ENDIF
+
+      CALL NONL_ALLOC(NONL_S,T_INFO,P,WP%WDES,.FALSE.)
+      CALL SPHER(WP%WDES%GRID,NONL_S,P,WP%WDES,LATT_CUR,1,NK)
+      CALL PHASE(WP%WDES,NONL_S,NK)
+
+      CALL NEWWAVA(WRYlm,WDESK,NYLM)
+      WRYlm%CW=0
+      !WRITE(*,*) WRYlm%WDES1%LOVERL,   WRYlm%WDES1%NPROD
+      ! 2020-06-15 CCX: use CONSTRUCT_FUNCTION_RYlm_ALL.
+      CALL CONSTRUCT_FUNCTION_RYlm_ALL(L,FG,LATT_CUR,POS,NONL_S,SPIN_FAC,WRYlm)
+      ! and normalize the functions WRYlm
+      DO N=1,NYLM
+         CALL CNORMN(ELEMENT(WRYlm,N),CQIJ,1,WSCAL)
+      ENDDO
+
+      ! calculate overlap between Wk and WRYlm: < w_{m,k1} | S | RYlm >
+      S=0
+      DO NB=1,WP%WDES%NBANDS
+         DO N=1,NYLM
+            C=W1_DOT(ELEMENT(WK,NB),ELEMENT(WRYlm,N),CQIJ)
+            S(WDESK%NB_LOW+WDESK%NB_PAR*(NB-1),N)=C
+!           WRITE(*,*) WDESK%NB_LOW+WDESK%NB_PAR*(NB-1),N,C
+         ENDDO
+      ENDDO
+
+      CALLMPI( M_sum_g(WDESK%COMM_INTER,S(1,1),WDESK%NB_TOT*NYLM) )
+
+      ! some deallocation to be done
+      CALL DEALLOCATE_ROT_HANDLE(ROT_HANDLE)
+
+      CALL DELWAVA(WRYlm)
+      IF (NK/=KPOINTS_FULL%NEQUIV(NK)) CALL DELWAVA(WK)
+
+      CALL NONL_DEALLOC(NONL_S)
+
+      RETURN
+    END SUBROUTINE CALC_OVERLAP_GN_ALL
+
 
 !******************** SUBROUTINE CONSTRUCT_FUNCTION_RYlm ***************
 !      
@@ -1989,11 +2267,129 @@
       RETURN
       END SUBROUTINE CONSTRUCT_FUNCTION_RYlm
 
+!******************** SUBROUTINE CONSTRUCT_FUNCTION_RYlm_ALL ***********
+! 2020-06-15 CCX: added to construct full RYlm with 2 spinors.
+!                 the PAW projector are constructed with the new
+!                 spinor wavefunctions.
+!                 Also, see W1_DOT in wave_high.F
+!***********************************************************************
+      SUBROUTINE CONSTRUCT_FUNCTION_RYlm_ALL( &
+     &   LMAX,F,LATT_CUR,POS,NONL_S,SPIN_FAC,WRYLM &
+     &)
+      USE ini
+      USE asa
+      USE pead
+      USE lattice
+      USE constant
+      USE wave_high
+      USE nonl_high
+      IMPLICIT NONE
+      TYPE(latt) LATT_CUR
+      TYPE(wavefuna) WRYLM
+      TYPE (nonl_struct) NONL_S
+      REAL(q) F(:,:,:)
+      REAL(q) POS(3)
+      INTEGER LMAX
+      ! 2020-06-15 CCX: read in SPIN_FAC
+      COMPLEX(q) SPIN_FAC(2)
+      ! local variables
+      ! 2020-06-15 CCX: ISPINOR is now local variable
+      INTEGER ISPINOR
+      TYPE(wavefun1) W1
+      INTEGER N1,N2,N3,IND,NPL,LMMAX,L,M,LM,IG
+      REAL(q) G1,G2,G3,GKX,GKY,GKZ,FACTM,FAKT,FDER
+      REAL(q), ALLOCATABLE :: XS(:),YS(:),ZS(:),YLM(:,:)
+      REAL(q), ALLOCATABLE :: G(:),FG(:)
+      COMPLEX(q) CSET,CGDR
+      COMPLEX(q), ALLOCATABLE :: CFAKTX(:)
+
+      LMMAX=(LMAX+1)**2
+
+      NPL=WRYLM%WDES1%NGVECTOR
+
+      ! 2020-06-15 CCX: deleted this part, usually not usefull.
+      !IF (ISPINOR/=1.AND.(.NOT.WRYLM%WDES1%LNONCOLLINEAR)) THEN
+      !   WRITE(*,*) 'CONSTRUCT_FUNCTION_RYlm: ERROR: ISPINOR=',ISPINOR,' but LNONCOLLINEAR=.FALSE.'
+      !   STOP
+      !ENDIF
+
+      ALLOCATE(G(NPL),FG(NPL))
+      ALLOCATE(XS(NPL),YS(NPL),ZS(NPL),CFAKTX(NPL))
+
+      ! loop over all G-vectors in the basis at this k-point
+      DO IND=1,WRYLM%WDES1%NGVECTOR
+         N1=MOD(WRYLM%WDES1%IGX(IND)+WRYLM%WDES1%GRID%NGX,WRYLM%WDES1%GRID%NGX)+1
+         N2=MOD(WRYLM%WDES1%IGY(IND)+WRYLM%WDES1%GRID%NGY,WRYLM%WDES1%GRID%NGY)+1
+         N3=MOD(WRYLM%WDES1%IGZ(IND)+WRYLM%WDES1%GRID%NGZ,WRYLM%WDES1%GRID%NGZ)+1
+
+         G1=(WRYLM%WDES1%GRID%LPCTX(N1)+WRYLM%WDES1%VKPT(1))
+         G2=(WRYLM%WDES1%GRID%LPCTY(N2)+WRYLM%WDES1%VKPT(2))
+         G3=(WRYLM%WDES1%GRID%LPCTZ(N3)+WRYLM%WDES1%VKPT(3))
+
+         FACTM=1._q
+         IF (WRYLM%WDES1%LGAMMA .AND. (N1/=1 .OR. N2/=1 .OR. N3/=1)) FACTM=SQRT(2._q)
+
+         GKX=(G1*LATT_CUR%B(1,1)+G2*LATT_CUR%B(1,2)+G3*LATT_CUR%B(1,3))*TPI
+         GKY=(G1*LATT_CUR%B(2,1)+G2*LATT_CUR%B(2,2)+G3*LATT_CUR%B(2,3))*TPI
+         GKZ=(G1*LATT_CUR%B(3,1)+G2*LATT_CUR%B(3,2)+G3*LATT_CUR%B(3,3))*TPI
+
+         G(IND)=MAX(SQRT(GKX*GKX+GKY*GKY+GKZ*GKZ),1E-10_q)
+
+         ! phase factor e^{-i(k+G)R} where R is the origin
+         ! of the localized function
+         CGDR=CITPI*(G1*POS(1)+G2*POS(2)+G3*POS(3))
+!        CGDR=0
+         CFAKTX(IND)=FACTM*EXP(-CGDR)
+
+         XS(IND)  =GKX/G(IND)
+         YS(IND)  =GKY/G(IND)
+         ZS(IND)  =GKZ/G(IND)
+      ENDDO
+
+      ALLOCATE(YLM(NPL,LMMAX))
+      ! get me all the Y_lm up to and including l=LMAX
+      CALL SETYLM(LMAX,NPL,YLM,XS,YS,ZS)
+
+      ! Setup the plane wave part of the desired function
+      FAKT= 1/SQRT(LATT_CUR%OMEGA)
+      CSET=CMPLX(0._q,-1._q,q)
+
+!     WRYLM%CW=0
+      LM=1
+      DO L=0,LMAX
+         ! get me the Bessel transform of the radial function
+         DO IG=1,SIZE(G)
+            CALL SPLVAL(G(IG),FG(IG),FDER,F(:,:,L+1),SIZE(F,1),SIZE(F,1))
+         ENDDO
+         DO IND=1,NPL
+            DO M=1,2*L+1
+               ! 2020-06-15 CCX: added ISPINOR loop to construct full spinor WF
+               !                 each part dotted with SPIN_FAC for quant_axis.
+               DO ISPINOR=1,2
+                 WRYLM%CW(IND+(ISPINOR-1)*NPL,LM+M-1)= &
+                &   SPIN_FAC(ISPINOR)*FAKT*(CSET**L)*CFAKTX(IND)*FG(IND)*YLM(IND,LM+M-1)
+               ENDDO
+            ENDDO
+         ENDDO
+         LM=LM+2*L+1
+      ENDDO
+
+      ! and get the projections of RYlm onto the PAW projectors
+      WRYLM%CPROJ=0
+      DO LM=1,LMMAX
+         W1=ELEMENT(WRYLM,LM)
+         CALL PROJ1(NONL_S,WRYLM%WDES1,W1)
+      ENDDO
+
+      DEALLOCATE(G,FG,XS,YS,ZS,CFAKTX,YLM)
+
+      RETURN
+    END SUBROUTINE CONSTRUCT_FUNCTION_RYlm_ALL
 
 !******************** SUBROUTINE WRITE_WAVE_FUNCTIONS ******************
 !      
 !***********************************************************************
-      SUBROUTINE WRITE_WAVE_FUNCTIONS(W,K,ISP,EXCLUDE_BAND,P,LATT_CUR,IU)
+      SUBROUTINE WRITE_WAVE_FUNCTIONS(W,K,ISP,EXCLUDE_BAND,P,LATT_CUR,UNK_FMTED,IU)
       USE pead
       USE pseudo
       USE lattice
@@ -2006,6 +2402,7 @@
       INTEGER ISP,IU
       REAL(q) K(3)
       LOGICAL EXCLUDE_BAND(W%WDES%NB_TOT) 
+      LOGICAL UNK_FMTED
      ! local variables
       TYPE(wavespin) WP
       TYPE(wavefuna) WK
@@ -2014,7 +2411,7 @@
 
       TYPE(rotation_handle), POINTER :: ROT_HANDLE
 
-      INTEGER NK,NB,ISTRIP
+      INTEGER NK,NB,ISTRIP,ISPINOR
       INTEGER NX,NY,NZ,NC,NGX,NGY,NGZ,IND,I,NWRITTEN
       INTEGER, PARAMETER :: NSTRIP=1
 
@@ -2047,7 +2444,12 @@
          CALL NEWWAV(WCOLLECT(NB),WDESK,.TRUE.)
       ENDDO
 
+      ! 2020-06-22 CCX: added for non-collinear WF plot
+      IF (WP%WDES%NRSPINORS/=1) THEN
+        ALLOCATE(WVFN(NGX*NGY*NGZ*2))
+      ELSE
       ALLOCATE(WVFN(NGX*NGY*NGZ))
+      ENDIF
 
       NWRITTEN=0 
 
@@ -2073,7 +2475,14 @@
 #ifdef gammareal
                      WVFN(IND)=REAL(WCOLLECT(ISTRIP)%CR(NX+(NC-1)*WP%WDES%GRID%RL%NROW),KIND=q)
 #else
+                     ! 2020-06-22 CCX: added for non-collinear WF plot
+                     IF (WP%WDES%NRSPINORS/=1) THEN
+                       DO ISPINOR=0,WP%WDES%NRSPINORS-1
+                         WVFN(IND+ISPINOR*(NGX*NGY*NGZ))=WCOLLECT(ISTRIP)%CR(NX+(NC-1)*WP%WDES%GRID%RL%NROW+ISPINOR*(NGX*NGY*NGZ))
+                       ENDDO
+                     ELSE
                      WVFN(IND)=WCOLLECT(ISTRIP)%CR(NX+(NC-1)*WP%WDES%GRID%RL%NROW)
+                     ENDIF
 #endif
                   ENDDO
                ENDDO
@@ -2086,7 +2495,14 @@
 #ifdef gammareal
                      WVFN(IND)=REAL(WCOLLECT(ISTRIP)%CR(NZ+(NC-1)*WP%WDES%GRID%RL%NROW),KIND=q)
 #else
+                     ! 2020-06-22 CCX: added for non-collinear WF plot
+                     IF (WP%WDES%NRSPINORS/=1) THEN
+                       DO ISPINOR=0,W%WDES%NRSPINORS-1
+                         WVFN(IND+ISPINOR*(NGX*NGY*NGZ))=WCOLLECT(ISTRIP)%CR(NZ+(NC-1)*WP%WDES%GRID%RL%NROW+ISPINOR*(NGX*NGY*NGZ))
+                       ENDDO
+                     ELSE
                      WVFN(IND)=WCOLLECT(ISTRIP)%CR(NZ+(NC-1)*WP%WDES%GRID%RL%NROW)
+                     ENDIF
 #endif
                   ENDDO
                ENDDO
@@ -2094,13 +2510,36 @@
                WRITE(*,'(A)') 'WRITE_WAVE_FUNCTIONS: ERROR: W1 grid not set'
                STOP
             ENDIF
+
+            ! 2020-06-22 CCX: added for non-collinear WF plot
+            IF (WP%WDES%NRSPINORS/=1) THEN
+              CALLMPI(M_sum_g(WP%WDES%COMM_INB,WVFN(1),NGX*NGY*NGZ*2))
+            ELSE
             CALLMPI(M_sum_g(WP%WDES%COMM_INB,WVFN(1),NGX*NGY*NGZ))
+            ENDIF
 
             ! write WVFN to file
 #ifdef MPI
             IF (WP%WDES%COMM%NODE_ME==WP%WDES%COMM%IONODE) THEN 
 #endif
+               ! 2020-06-22 CCX: added for non-collinear WF plot
+               IF (WP%WDES%NRSPINORS/=1) THEN
+                 IF (UNK_FMTED) THEN
+                   DO ISPINOR=0,1
+                     WRITE(IU,'(2ES20.10)') (WVFN(I),I=1+NGX*NGY*NGZ*ISPINOR,NGX*NGY*NGZ+NGX*NGY*NGZ*ISPINOR)
+                   ENDDO
+                 ELSEIF (.NOT. UNK_FMTED) THEN
+                   DO ISPINOR=0,1
+                     WRITE(IU) (WVFN(I),I=1+NGX*NGY*NGZ*ISPINOR,NGX*NGY*NGZ+NGX*NGY*NGZ*ISPINOR)
+                   ENDDO
+                 ENDIF
+               ELSEIF (WP%WDES%NRSPINORS==1) THEN
+                 IF (UNK_FMTED) THEN
+                   WRITE(IU,'(2ES20.10)') (WVFN(I),I=1,NGX*NGY*NGZ)
+                 ELSEIF (.NOT. UNK_FMTED) THEN
                WRITE(IU) (WVFN(I),I=1,NGX*NGY*NGZ)
+                 ENDIF
+               ENDIF
 #ifdef MPI
             ENDIF
 #endif
@@ -2120,7 +2559,6 @@
       RETURN
       END SUBROUTINE WRITE_WAVE_FUNCTIONS
 
-
 !******************** SUBROUTINE OCCURS_IN_FILE ************************
 !      
 !***********************************************************************
